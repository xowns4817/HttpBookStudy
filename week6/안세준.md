# 11장. 클라이언트 식별과 쿠키
> 서버가 통신하는 대상을 식별하는 기술

## 1. 개별 접촉

- 웹 서버는 요청을 보낸 사용자를 식별하기 위해 약간의 정보를 이용할 수 있다.
- Amazon.com 같이 유명한 온라인 쇼핑 사이트는 사이트를 개인화 시켜서 사용자에게 제공
  - 사용자에게 특화된 환영 메시지나 페이지 내용
  - 생일이나 중요한 날에 특별한 제품 제시
  - 복잡한 주소와 신용카드등, 저장된 사용자 정보를 사용
  - 사용자의 상태를 남김 (장바구니 등)
- 이렇게 상태를 유지하려면 HTTP 트랜잭션을 유지할 방법이 필요
  - 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
  - IP 주소로 사용자를 식별
  - 사용자 로그인 인증을 통한 식별
  - URL에 식별자를 포함하는 기술인 뚱뚱한 URL
  - 쿠키

## 2. HTTP 헤더

- 사용자에 대한 정보를 전달하는 가장 일반적인 7가지 HTTP 요청 헤더
  - From : 이메일 주소
    - 사용자의 이메일 주소를 포함
    - 각 사용자가 서로 다른 이메일주소를 가지므로 사용자 식별이 가능
    - 그러나, 악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송하는 문제가 있어서 From헤더를 보내는 브라우저는 많지 않다. 
  - User-Agent : 브라우저
    - 브라우저 이름과 버전정보, 어떤 경우에는 운영체제에 대한 정보까지 포함
    - 특정 사용자를 식별하는 데는 큰도움이 되지 않음
  - Referer : 현재 링크를 타고 온 근원 페이지
    - 현재 페이지로 유입하게 한 웹페이지의 URL을 가리킨다.
    - 사용자를 식별할 수는 없지만 이전에 어떤 페이지를 방문했는지는 알려줌. 
  위 헤더들은 확실히 식별하기에는 부족한 정보를 가진다.  
  - Authorization : 사용자 이름과 비밀번호 (뒤에서) 
  - Client-ip : 클라이언트의 IP 주소 (뒤에서)
  - X-Forwarded-For : 클라이언트의 IP 주소 (뒤에서)
  - Cookie : 서버가 생성한 ID 라벨 (뒤에서)
  

## 3. 클라이언트 IP 주소

- 클라이언트 IP주소로 식별하는 방식은 약점이 있다
  - 사용자가 아닌, 사용하는 컴퓨터를 가리킨다.
  - 동적으로 IP주소를 할당하는 경우 매번 다른 주소
  - 많은 사용자가 네으퉈크 주소 변환(NAT) 방화벽을 통해 인터넷을 사용
    - NAT 장비들은 실제 IP주소를 내부에서 사용하는 하나의 방화벽 IP주소로 변환
  - 프락시와 게이트웨이는 프락시 서버의IP주소를 본다.
- 클라이언트IP 주소로 식별하는 방식은 인트라넷 같이 제한된 영역에서는 적절할 수 있지만, 
  인터넷에서는IP주소를 임의로 변경할 수 있기 때문에 문제가 발생할 수 있다.



## 4. 사용자 로그인

- 사용자의 이름과 비밀번호로 인증을 요구해서 명시적으로 식별 요청을 할 수 있다. 
- 웹 사이트 로그인이 더 쉽도록 HTTP는 WWW-Authenticate, Authorization 헤더를 사용
- 한번 로그인하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로, 웹 서버는 그 로그인정보를 항상 사용할 수 있다 (12장에서 자세히 다룸)
- p302 그림 11-2
  1. 브라우저가 사이트를 요청
  2. 서버는 사용자의 식별정보를 모르니까 401 Login Required HTTP 응답 코드와 WWW-Authenticate 헤더를 반환하여 로그인을 요청
  3. 사용자가 이름과 비밀번호를 입력하고 브라우저는 기존 요청을 다시 보내서 식별을 시도
  4. 서버는 이제 식별정보를 알고, 이 시점 이후의 요청에 대해 자동으로 사용자 이름과 비밀번호를 포함
  5. 사이트에 한번 만 로그인하면 브라우저는 요청마다 해당 사용자의 식별정보 토큰을 Authorization 헤더에 담아 서버로 전송해서, 한 세션이 진행되는 내내 그 사용자에 대한 식별을 유지
- 매번 사이트마다 서로 다른 사용자 이름을과 비밀번호를 기억해서 로그인하는 건 귀찮은 일
  - 뚱뚱한URL로 이 문제를 해결하지만. . 그것도 문제가 있음
  

## 5. 뚱뚱한 URL

- 사용자의 상태 정보를 포함하고 있는 URL을 뚱뚱한 URL이라 부른다. 
- Amazon.com의 뚱뚱한 URL의 예 (p303)
  - 사용자에게 할당된 식별번호를 각 URL 뒤에 붙여서 사용자를 추적 
- 사용자가 웹사이트에 처음 방문하면 유일한 ID가 생성되고 그 값은 서버가 인식할 수 있는 방식으로 URL에 추가되며, 서버는 클라이언트를 이 뚱뚱한 URL로 리다이렉트 시킨다. 
- 이 기술에는 심각한 문제가 있다
  - 못생긴 URL : 새로운 사용자에게 혼란을 준다.
  - 공유하지 못하는 URL : 메일로 공유하거나 하면 그 주소의 누적된 개인 정보를 본의 아니게 공유할 수 도 있음 
  - 캐시 사용 못함 : URL이 달라지기 때문에 기존 캐시에 접근 못함
  - 서버 부하 가중 : HTML을 다시 그려야 함
  - 이탈 : 다른 사이트로 이동하게 되면 세션에서 이탈하기 쉽다
  - 세션 간 지속성의 부재 : 로그아웃하면 끝



## 6. 쿠키

사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식

앞의 기술들의 문제점을 겪지는 않지만

쿠키만으로 하기 힘든일에는 앞의 기술들을 함께 사용하기도 한다. 

#### 1. 쿠키의 타입

- 세션 쿠키와 지속쿠키로 나뉨
- 세션쿠키는 임시쿠키로 사용자가 브라우저를 닫으면 삭제
- 지속 쿠키는 디스크에 저장되어, 컴퓨터를 재시작해도 남아있음
- 두 쿠키의 차이점은 파기되는 시점 뿐
  - Expires 혹은 Max-Age 파라미터가 없으면 세션쿠키가 된다. 

#### 2. 쿠키는 어떻게 동작하는가

- 서버는 사용자의 첫 방문때는 모르지만, 다시 돌아오면 해당 사용자를 식별하려고 쿠키를 할당
- 이름=값 형태의 리스트
  - 리스트는 Set-Cookie 혹은 Set-Cookie2(확정 헤더) 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달
- 어떤 정보든 포함할 수도 있지만, 사용자 추적 용도로 생성한 유일한 단순 식별 번호만 포함하기도 함
- 데이터베이스에서 사용자의 정보등을 찾는데 사용할 수 있음

#### 3. 쿠키 상자 : 클라이언트 측 상태

- 쿠키의 기본적인 발상은 
  브라우저가 서버 관련 정보를 저장하고, 해당 서버에 접근할 때마다 그 정보를 함께 전송하게 하는 것.
- 브라우저는 쿠키 정보를 저장할 책임이 있는데 이 시스템을 클라이언트 측 상태라고 하고 공식적인 이름은 HTTP 상태 관리 체계 (HTTP State Management Mechanism) 이다.

#### 크롬 쿠키와 익스플로러 쿠키 

- 크롬 쿠키 (p307)
  - Cookies라는 SQLite 파일에 쿠키를 저장
- 익스플로러 쿠키(p307 그림 11-4)
  - 캐시 디렉터리에 각각의 개별 파일로 쿠키를 저장
    



#### 4. 사이트마다 각기 다른 쿠키들

- 브라우저는 수백,수천개의 쿠키를 가지고 있을 수 있지만 보통 각 사이트에 두,세개의 쿠키만을 보내는 이유는
  - 쿠키를 모두 전달하면 성능이 크게 저하
  - 대부분 사이트에서 인식하지 않는 무의미한 값
  - 개인정보 문제를 일으킬 수있다
  

#### 5. 쿠키 구성요소

- 현재 사용되는 쿠키 명세는 version0 쿠키와 version1(잘 안쓰임) 쿠키
  

#### 6. Version 0(넷스케이프) 쿠키

- 넷스케이프가 정의
- Set-Cookie 응답 헤더와 Cookie 요청 헤더와 쿠키를 조작하는 데 필드들을 정의
- Set-Cookie
  - 쿠키의 이름과 값을 가져야 한다
  - Expires 
    - 쿠키의 생명주기를 가리키는 날짜 문자열을 기술
    - Expires를 명시하지 않으면 그 쿠키는 사용자의 세션이 끝날때 파기될 것
  - Domain
    - 선택적인 속성. 
    - 브라우저는 이 속성에 기술된 도메인을 사용하는 서버 호스트 명만으로 쿠키를 전송
    -  명시되어 있지 않으면, Set-Cookie응답을 생성한 서버의 호스트명을 기본값으로 사용
  - Path
    - 선택적인 속성. 서버에 있는 특정 문서에만 쿠키를 할당
    - 명시하지 않으면, Set-Cookie응답을 전달하는 URL의 경로를 사용
  - Secure
    - 선택적인 속성
    - HTTP가 SSL 보안 연결을 사용할 때만 쿠키를 전송

#### 7. Version 1 (RFC 2965) 쿠키

- RFC 2965 쿠키 표준은 좀 더 복잡하며, 모든 브라우저나 서버가 완전히 지원하지 않음
  

#### 8. 쿠키와 세션 추적

- 쿠키는 사용자를 추적하는 데 사용
- 전자상거래 웹 사이트는 쇼핑카트를 유지하려 세션 쿠키를 사용
- p317 그림11-5에 amazon.com에 방문하면 일어나는 트랜잭션의 연속을 보여줌

#### 9. 쿠키와 캐싱

- 쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 함
  이전 사용자의 쿠키가 다른 사용자에게 할당되거나, 누군가의 개인정보가 다른 이에게 노츨되는 최악의 상황이 일어날 수도 있다
- 캐시를 다루는 기본 원칙
  - 캐시되지 말아야 할 문서가 있다면 표시하라
    - 명시적으로 Cache-Control: no-cache="Set-Cookie"를 기술해서 명확히 표시
    - 캐시를 해도 되는 문서에 Cache-Control:public을 사용하면 웹의 대역폭을 절약해줌
  - Set-Cookie 헤더를 캐시 하는 것에 유의하라
    - 같은 Set-Cookie헤더를 여러 사용자에게 보내면, 사용자 추적에 실패 할 것
  - Cookie 헤더를 가지고 있는 요청을 주의하라
    - 보수적인 캐시는 Cookie 헤더가 포함된 요청에 응답으로 오는 문서는 캐시하지 않을 것
      

#### 10. 쿠키, 보안 그리고 개인정보

- 사실 데이터베이스에 개인정보를 저장하고 해당 데이터의 키 값을 쿠키에 저장하는 방식을 표준으로 사용하면 예민한 데이터가 오가는 것을 줄일 수 있지만
- 개인정보를 다루거나 사용자를 추적하는 기술은 잘못된 의도로 사용할 수 있기 때문에 항상 조심하는것이 좋다
- 쿠키에 대한 부정적인 여론이 많지만, 유의한다면 위험성보다 트랜잭션상의 편리함이 더 크다



---

# 12장. 기본 인증

## 1. 인증

- 당신이 누구인지 증명하는 것
- 완벽한 인증이란 없다. 

#### 1. HTTP의 인증요구/ 응답 프레임워크

- HTTP는 자체 인증요구/응답 프레임워크를 제공. 
- 웹 애플리케이션이 HTTP 요청 메시지를 받으면 서버는인증요구로 응답 할 수 있다

#### 2. 인증 프로토콜과 헤더

- HTTP에는 기본인증, 다이제스트 인증(13장) 이라는 두가지 공식적인 인증 프로토콜이 있다.

#### 3. 보안 영역

- 웹 서버는 기밀문서를 보안 영역(realm) 그룹으로 나눔
  - 예를 들어 웹 서버가 두개의 보안영역을 가지고 있고, 한개는 회사의 재정정보, 하나는 개인의 가족문서라면 각 사용자에게 서로 다른 영역으로 접근한다. 
  - ex) realm="Family", realm="Corporate"
  - 위와 같이 해설 형식으로 되어 있어서 사용자가 권한의 범위를 이해하는데 도움이 되어야 한다. 



## 2. 기본 인증

#### 1. 기본 인증의 예

1. 사용자가 가족사진인 /family/jeff.jpf 를 요청
2. 서버는 401 Authorization Required 응답을 반환
3. 브라우저는 401 응답을 받고 입력창을 띄움
4. 사용자가 입력창에 이름과 비밀번호를 입력
5. 브라우저는 :으로 이어 붙이고, base-64 방식으로 인코딩하고 Authorization 헤더에 그 값을 담아 서버로 다시 보냄
6. 서버는 디코딩하고 정확한지 검사후 http 200 ok와 함께 문서를 보냄

#### 2. Base-64 사용자 이름/비밀번호 인코딩

- HTTP 기본인증은 사용자 이름과 비밀번호를 콜론으로 이어 합치고, base-64 인코딩 메서드를 사용해 인코딩
- base-64인코딩은 8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환
- 각 6비트 조각은 문자와 숫자로 이루어진 특별한 64개 문자중에서 선택

#### 3. 프락시 인증

- 접근 정책을 중앙 관리 할 수 있기 때문에 회사 리소스전체에 대해 통합적인 접근 제어를 하기 위해 프락시 서버를 사용하면 좋다 .



## 3. 기본 인증의 보안 결함

1. base-64로 인코딩된 정보는 쉽게 디코딩 가능
   이게 문제가 된다면 모든 HTTP 트랜잭션을 SSL암호화 채널을 통해 보내거나 다이제스트인증 사용
2. 재전송 공격을 예방하기 위한 어떤일도 하지 않음
3. 모든 사이트에 같은 아이디,비번을 사용한다면, 악의를 가지면 해당 정보로 은행사이트에 접근할 수 도 있음
4. 본래 의도를 바꿔버리는 프락시나 중개자가 개입하면 정상적인 동작 하지 않음
5. 가짜 서버의 위장에 취약



>기본인증은 암호화된 데이터 전송(SSL같은)과 함께 연계해서 사용할 수 있다
>이는 널시 사용하는 기술




