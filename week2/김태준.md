## 3장 HTTP 메시지
 - 3장에서 다룰 주제
   - 메시지가 어떻게 흘러가는가
   - HTTP 메시지의 세 부분 ( 시작줄, 해더, 본문)
   - 요청과 응답 메시지의 차이
   - 요청 메시지가 지원하는 여러 기능(메서드)들
   - 응답 메시지가 반환하는 여러 상태 코드들
   - 여러 HTTP 헤더들은 무슨일을 하는가

### 3.1 메시지의 흐름
  - HTTP 메시지는 HTTP 에플리케이션 간에 주고받는 데이터의 블록들이다.

#### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다.
 - HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다. ( 서버를 기준으로 생각한다. )
 - 인바운드 : 서버로 들어간다. ( ALL CLOSE )
 - 아웃바운드 : 서버에서 나간다. ( ALL OPEN )
  
#### 3.1.2. 다운 스트림으로 흐르는 메시지
  - 요청 메시지냐 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐른다.  ( 먼소린지 ? )

### 3.2 메시지의 각 부분
  - HTTP 메시지는 클라이언트의 요청이거나 서버로부터의 응답 중 하나이다.
  - 메시지는 시작줄, 헤더, 본문 이렇게 세 부분으로 구성된다. ( 본문이 없을 수도 있다. )
  - 시작줄과 해더는 줄 단위로 분리된 아스키 문자열이다. ( 각 줄은 캐리지 리턴과 개행문자로 구성된 두 글자의 줄바꿈 문자열로 끝난다. 이를 'CRLF'라 부른다.) - 
  - CR : 커서의 위치를 맨 앞으로 이동
  - LF :  현재 위치에서 바로 아래로 이동
  - 본문은 텍스트나 이진 데이터를 포함할 수도 있고 비어있을 수도 있다.
  
  #### 3.2.1. 메시지 문법
   - 모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.  ( 요청, 응답 모두 기본적인 구조는 같다. 
   - 해더나 엔터티 본문이 없더라도 HTTP 해더의 집합은 항상 빈 줄로 끝나야 한다. ( 테스트 해보기 )
   - 요청 메시지의 형식
     -  <메서드> <요청 URL> <버전>
     -  <헤더>
  
     -  <엔터디 본문>
  -  응답 메시지의 형식
     -  <버전> <상태 코드> <사유 구절>
     -  <헤더>
  
     -  <엔터티 본문>

#### 3.2.2 시작줄
 - 모든 HTTP 메시지는 시작줄로 시작한다.
 - 요청줄 : 요청 메시지는 서버에게 리소스에 대해 무언가 해달라고 부탁한다. 
 - 응답줄 : 응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다.
 - 메서드 : 요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다.
   - 메서드에 따라서 요청 메시지에 본문이 있는 경우도 있고 그렇지 않은 경우도 있다.

|메서드|설명|메시지 본문이 있는가 ?|
|------|---|---|
|GET|서버에서 어떤 문서를 가져온다.|없음|
|HEAD|서버에서 어떤 문서에 대해 해더만 가져온다.|없음|
|POST|서버가 처리해야 할 데이터를 보낸다.(서버에 데이터를 저장한다.)|있음|
|PUT|서버에 요청 메시지의 본문을 저장한다.|있음|
|FETCH|서버가 처리해야 할 데이터를 보낸다.|있음|
|TRACE|메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다.|없음|
|OPTIONS|서버가 어떤 메서드를 수행할 수 있는지 확인한다.|없음|
|DELETE|서버에서 문서를 제거한다.|없음|

- POST VS PUT
  - Post는 요청 횟수 만큼 서버에 자원이 생성된다.
  - Put은 몇번을 요청해도 서버에 1개의 자원만 생긴다. ( body에 있는 값으로 값을 교체)
  - 여기서 멱등성(Idempotent) 이라는 말이 나오는데, 멱등성이 있다는 것은 연산을 여러번 반복해도 결과가 같다는 뜻이다. 즉, PUT의 경우 멱등 하지만, Post의 경우는 멱등하지 않다.

- PUT VS FETCH
 - 둘다 자원을 수정할때 사용하지만, PUT의 경우 자원 전체를 수정할때, FETCH는 자원 일부만 수정할때 사용한다. PUT에서 body에 자원일부 값만 넣을경우 나머지 값들은 null로 변경된다.
 - 그런데, 이건 서버에서 구현하기 나름인거 같음. body에 값을 다 안넣고 PUT으로 요청해도 body안에 pk로 조회한번하고 update 치면 fetch랑 같지않나? fetch 요청을 받는 컨트롤러에서는 그럼 무조건 read, update 가 되야되는건가?

- 상태 코드 : 상태코드는 서버가 클라이언트에게 무엇이 일어났는지 말해준다. <-> 메서드
  - 상태코드는 응답의 시작줄에 위치한다.


|전체 범위|정의된 범위|분류|
|------|---|---|
|100-199|100-101|정보|
|200-299|200-206|성공|
|300-399|300-305|리다이랙션|
|400-499|400-415|클라이언트 에러|
|500-599|500-505|서버 에러|


- 사유 구절 : 상태 코드에 대한 글로 된 설명을 제공한다.
- 버전 번호 
  - 버전 번호는 HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다.
  - 자신이 사용하는 프로토콜 버전을 상대방에게 말해주는 수단이다. 
  - 버전 번호는 분수로 다루어지지 않는다. -> 더 큰 버전을 비교하기 위해서는 .을 기준으로 좌우 숫자를 따로비교한다.  ( HTTP/2.22 > HTTP/2.3 )

#### 3.2.3 헤더
 - 시작줄 다음에는 0개 혹은 그 이상의 HTTP 헤더가 온다.
 - Key-Value 구조이다.
  
### 3.3 메서드
 - 모든 서버가 모든 메서드를 구현하지는 않는다. ( 서버 개발자 마음이다.. 단지 규격일뿐..)

#### 3.3.1 안전한 메서드 ( Safe Method )
 - GET, HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없기 때문에 안전한 메서드라고 한다. ( 이것 또한 3.3 처럼 서버 개발자가 구현하기 나름이다.. GET인데 POST처럼 구현해 놓을수도 있다...)
#### 3.3.2 GET
  - 주로 서버에게 리소스를 요청하기 위해 사용한다.
  - 데이터를 서버에 넘길때는 질의 문자열로 넘긴다. ( ex. http://www.naver.com/search?query=item..)
#### 3.3.3 HEAD
  - 기본동작은 GET과 같지만 서버는 응답으로 헤더만 돌려준다. ( 특정 리소스가 있는지 확인만 할 용도라면 유용할듯함 )
  - HEAD를 사용하면 ?
    - 리소스를 가져오지 않고도 그에 대해 무엇인가(타입 ? - 해당 리소스의 Content-type을 말하는 듯 )를 알아낼 수 있다.
    - 응답의 상태 코드를 통해, 개채가 존재하는지 확인할 수 있다.
    - 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다. ( ? 어떻게 ?)
    - curl --head 서버주소 ( 해당 서버의 http version 확인 가능 )
#### 3.3.4 PUT
 - PUT메서드는 서버에 문서를 쓴다.
 - PUT 메서드의 의미는, 요청 URL에 해당하는 문서가 이미 서버에 있다면 본문에 있는 값으로 변경하고, 없다면 새 문서를 쓰는 것이다.
#### 3.3.5 POST
 - POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계되었다. ( html form을 지원하기 위해 주로 사용된다. )
#### 3.3.6 TRACE
 - TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
 - TRACE 메서드는 주로 진단을 위해 사용된다. 예를들어, 요청이 의도한 요청/응답 연쇄를 거쳐가는지 검사할 수 있다. 또한, 프락시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해보고자 할 때도 좋은 도구이다.
 - TRACE 요청은 어떠한 엔터티 본문도 보낼 수 없고, 응답 엔터티 본문에는 서버가 받은 요청이 그대로 들어있다.
 - curl -v -X TRACE 서버주소
  ```
  Rebuilt URL to: http://localhost:9999/
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 9999 (#0)
> TRACE / HTTP/1.1
> Host: localhost:9999
> User-Agent: curl/7.58.0
> Accept: */*
>
< HTTP/1.1 405
< Allow: HEAD, DELETE, POST, GET, OPTIONS, PUT
< Content-Type: message/http
< Content-Length: 83
< Date: Fri, 02 Oct 2020 12:59:05 GMT
<
TRACE /error HTTP/1.1
host: localhost:9999
user-agent: curl/7.58.0
accept: */*
  ```
#### 3.3.7 OPTIONS
 - OPTIONS 메서드는 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.
 - curl -i --request-target "*" -X OPTIONS 서버주소
  
  ```
    HTTP/1.1 200
    Allow: GET, HEAD, POST, PUT, DELETE, OPTIONS
    Content-Lenth: 0
    Date: Fri, 02 Oct 2020 1257:01 GMT
  ```
#### 3.3.8 DELETE
 - 서버에게 요청한 URL로 지정한 리소스를 삭제할 것을 요청한다.

### 3.4 상태 코드
#### 3.4.1 100-199: 정보성 상태 코드
 - 
|상태 코드|사유 구절|의미|
|------|---|---|
|100|Continue|요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야 함을 의미한다. 이것을 보낸 후, 서버는 반드시 요청을 받아 응답을 해야한다.|
|101|Switching Protocols |클라이언트가 Upgrade 해더에 내열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미한다.|

- 101 예시 ( 웹소켓 연결 )
- client -> server
  ```
    GET /chat HTTP/1.1
        Host: server.example.com
        Upgrade: websocket
        Connection: Upgrade
        Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
        Origin: http://example.com
        Sec-WebSocket-Protocol: chat, superchat
        Sec-WebSocket-Version: 13
  ```
- server -> client
- 
  ```
  HTTP/1.1 101 Switching Protocols 
  Upgrade: websocket 
  Connection: Upgrade 
  Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
  ```


- 100 Continue는 HTTP 클라이언트 애플리케이션이 서버에 엔티티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 할 때, 그 확인 작업을 최적화하기 위한 의도로 도입 된 것이다.

- 클라이언트와 100 Continue
- 서버와 100 Continue
- 프락시와 100 Continue
  
#### 3.4.2 200-299: 성공 상태 코드

|상태 코드|사유 구절|의미|
|------|---|---|
|200|OK|요청은 정상이고 본문은 요청된 리소스를 포함하고 있다.|
|201|Created|서버에 리소스를 생성하라는 요청(POST, PUT)을 위한 것. 응답은 생성된 리소스에 대한 참조가 담긴 Location 해더와 함께, 그 리소스를 참조할 수 있는 URL 엔티트를 포함한다.|
|202|Accepted|요청은 받아들여졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않음. 서버는 가급적 요청의 처리가 언제 완료 될 것인지에 대한 정보를 포함해야 한다.|
|203|Non-Authoritative Information|엔터디 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다.|
|204|No Content|응답 메시지는 엔티티 본문을 포함하지 않는다. 주로 웹브라우저를 새 문서로 이동 시키지 않고 갱신하고자 할때 사용 ( ex. 폼을 리프레시 )|
|205|Reset Content|브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 말한다.|
|206|Partial Content|부분 혹은 범위 요청이 성공했다. 206응답은 Content-Range와 Date 해더를 반드시 포함해야 하며, Etag와 Content-Location 중 하나의 해더도 반드시 포함해야 한다.|

#### 3.4.3 300-399: 리다이렉션 상태 코드
- 클라이언트가 요청하는 리소스의 이동을 의미한다. 해당 리소스를 어디서 찾을 수 있는지 클라이언트에게 알려주기 위해 리다이렉션 상태 코드와 ( 선택적으로 ) Location 해더를 보낼 수 있다.
- 리다이렉션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원본 서버와 비교했을 때 유효한지 확인하기 위해 사용된다. ( 그림 3-15 )

|상태 코드|사유 구절|의미|
|------|---|---|
|300|Multiple Choices|클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 리소스의 목록과 함께 반환한다. ( ex. 여러 언어 지원 html 페이지 )|
|301|Moved Permanently|요청한 URL이 옮겨졌을 때 사용한다. 응답은 Location 해더에 현재 리소스가 존재하고 있는 URL을 포함해야 한다.|
|302|Found|301 상태 코드와 같다. 그러나, 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다. 이후의 요청에서는 원래 URL을 사용해야 한다.|
|303|See Other|클라이언트에게 리소스를 다은 URL에서 가져와야 한다고 말해주고자 할때 쓰인다. 이 상태코드의 주 목적은 POST 요청에 대한 응답으로 클라이언트에게 리소스의 위치를 알려주는 것이다.|
|304|Not Modified|클라이언트는 해더를 이용해 주건부 요청을 만들 수 있다. ( 그림 3-15 참고 ) |
|305|Use Proxy|리소스가 반드시 프록시를 통해서 접근되어야 함을 나타내기 위해 사용한다. 프록시 위치는 Location 해더를 통해 주어진다.|
|306|(사용되지 않음)| 현재는 사용되지 않음|
|307|Temporary Redirect| 302와 차이가 뭔지 ?|

- 302, 303, 307 상태 코드 사이에 중복되는 부분이 존재한다. 이는 HTTP 버전으로 인한 변화라고 볼 수 있다.
  - HTTP/1.0 클라이언트가 POST요청을 보내면 HTTP/1.0 서버는 302 응답코드를 내려줌으로써 해당 리소스의 Location정보를 알려준다.
  - 그러나, HTTP/1.1 명세는 위와 같은 리다이렉션을 위해 303 응답코드를 사용한다.
  - 또한, 일시적인 리다이렉트를 위해 302 상태코드 대신 307 상태코드를 사용한다.
  - 이로써, 302 상태코드를 HTTP/1.0 클라이언트에게 사용하기 위해 남겨둘 수 있다.
  - 정리하면, 서버는 가장 적절한 리다이렉트 상태 코드를 선택하기 위해서는 클라이언트의 HTTP 버전을 검사할 필요가 있다.

#### 3.4.4 400-499: 클라이언트 에러 상태 코드
- ex) 존재하지 않는 URL요청, 파라미터를 잘못입력, 권한이 없음..등등

|전체 범위|정의된 범위|분류|
|------|---|---|
|400|Bad Request|클라이언트가 잘못된 요청을 보냈다.( ex. 파라미터 잘못 넣었을때. )|
|401|Unauthorized|리소스를 얻기 전에 클라이언트에게 인증을 하라고 요구한다.|
|402|Payment Required|현재는 사용되지 않는다.|
|403|Forbidden|요청이 서버에 의해 거부되었다. 보통 이 코드는 서버가 거절의 이유를 숨기고 싶을때 사용한다. ( 내 ip가 차단되었거나, 서버 재구동시 요청을 했거나..등등?|
|404|Not Found|요청한 URL을 찾을 수 없다.|
|405|Method Not Allowed|요청한 URL에 대해, 지원하지 않는 메서드로 요청 받았을 때 사용한다.|
|406|Not Acceptable|클라이언트는 자신이 어떤 종류의 엔터티를 받아들이고자 하는지에 대해 매개변수로 명시할 수 있다. 이 코드는 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없는 경우 사용한다.|
|407|Proxy Authentication Required|401 상태 코드와 같으나, 리소스에 대해 인증을 요구하는 프록시 서버를 위해 사용된다.|
|408|Request Timeout|클라이언트의 요청이 시간이 오래 걸리는 경우, 서버는 이 상태 코드로 응답하고 연결을 끊을 수 있다.|
|409|Conflict|서버는 요청이 충돌을 일으킬 염려가 있다고 생각될 때 이 요청을 보낼 수 있다. 응답은 충돌에 대해 설명하는 본문을 포함해야 한다.|
|410|Gone| 404와 비슷하나, 서버가 한때 그 리소스를 갖고 있었다는 점이 다르다.|
|411|Length Required|서버가 여청 메시지에 Content-length 해더가 있을 것을 요구할때 사용한다.|
|412|Precondition Failed|클라이언트가 조건부 요청을 했는데 그 중 하나가 실패했을 때 사용한다. ( 조건부 요청은 클라이언트가 Expect 해더를 포함했을 때 발생한다.)
|413|Request Entity Too Large|서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 크기의 요청을 클라이언트가 보냈을때 사용한다.|
|414|Request URI Too Long|서버가 처리할 수 있는 한계를 넘은 길이의 요청 URL이 포함된 요청을 클라이언트가 보냈을때 사용한다.|
|415|Unsupported Media Type|서버가 이해하거나 지원하지 못하는 내용 유형의 엔티티를 클라이언트가 보냈을 때 사용한다.|
|416|Requested Range Not Satisfable|요청 메시지가 리소스의 특정 범위를 요청하는데, 그 범위가 잘못되었을 경우 사용한다.|
|417|Expectation Failed|요청에 포함된 Expect 요청 헤더에 서버가 만족시킬 수 없는 기대가 담겨있는 경우 사용한다.|

#### 3.4.5 500-599: 서버 에러 상태 코드

|상태 코드|사유 구절|의미|
|------|---|---|
|500|Internal Server Error|서버 에러|
|501|Not Implemented|클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용한다. ??
|502|Bad Gateway|요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답을 받았을때 사용한다 ??|
|503|Service Unavailable|현재는 서버가 요청을 처리해 줄 수 없지만 나중에는 가능함을 의미한다. 만약, 서버가 그 리소스를 사용할수 있는 시점을 알고 있자면 Retry-After 헤더를 응답에 포함시킬 수 있다.|
|504|Gateway Timeout|408과 비슷하나, 게이트워이나 프락시에서 온 응답이라는 점이 다르다.|
|505|HTTP Version Not Supported|서버가 지원할 수 없는 버전의 프로토콜로 된 요청을 받았을 때 사용한다.|


### 3.5 헤더

- 일반 헤더(General Headers)
  - 일반 헤더는 클라이언트와 서버 양쪽 모두가 사용한다. ( ex. Date 헤더 - 메시지가 만들어진 일시를 가리킴)
- 요청 헤더(Request Headers)
  - 요청 메시지를 위한 헤더이다. 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공한다. 
  - 예를들어, Accept 해더는 클라이언트가 수용할 수 있는 미디어 타입을 알려준다. ( Aceept: */* -> 클라이언트는 어떠한 미디어 타입도 수용가능하다. )
- 응답 헤더 ( Response Headers )
  - 응답 헤더는 응답 메시지를 위한 헤더이다. ( ex. Server: Tiki-Hut/1.0 -> 클라이언트에게 Tiki-Hut 서버 1.0 버전과 대화하고 있음을 말해준다. )
- 엔터티 헤더(Entity Headers)
  - 엔터티 헤더란 엔터티 본문에 대한 헤더를 말한다. 
- 확장 헤더 
  - 확장 헤더는 어플리케이션 개발자들에 의해 만들어졌지만 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더이다.

#### 3.5.1 일반 헤더
- 메시지에 대한 아주 기본적인 정보를 제공한다.
- 메시지가 어떤 종류이든 상관없이 정보를 제공한다.
  

|헤더|설명|
|------|---|
|Connection|클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 해준다.|
|Date|메시지가 언제 만들어졌는지에 대한 날짜와 시간을 제공한다.|
|MINE_Version|발송자가 사용한 MIME의 버전을 알려준다.|
|Trailer chunked transfer|인코딩으로 인코딩된 메시지의 끝 부분에 위치한 헤더들의 목록을 나열한다.|
|Transfer-Encoding|메시지가 어떤 인코딩이 적용되었는지 알려준다.|
|Upgrade|발송자가 '업그레이드'하길 원하는 새 버전이나 프로토콜을 알려준다. ( ex. 웹소켓 연결할때|
|Via|메시지가 어떤 프락시를 거쳐서 왔는지 보여준다.|

##### 일반 캐시 헤더
 - HTTP/1.0은 매번 원 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 최초의 헤더를 도입.
  
  |헤더|설명|
|------|---|
|Cache-Control|메시지와 함께 캐시 지시자를 전달하기 위해 사용한다.|
|Pragma|메시지와 함께 지시자를 전달하는 또 다른 방법. 캐시에 국한되지 않음. - deprecated 될 예정|

#### 3.5.2 요청 헤더
 - 요청 헤더는 요청 메시지에서만 의미를 갖는 헤더이다.
 - 
  |헤더|설명|
|------|---|
|Client-IP|클라이언트가 실행된 컴퓨터의 IP를 제공한다.|
|From|클라이언트 사용자의 메일 주소를 제공한다.|
|Host|요청의 대상이 되는 서버의 호스트 명과 포트를 준다.|
|Referer|현재의 요청 URI가 들어있었던 문서의 URI를 제공한다.|
|UA-Color|클라이언트 기기 디스플레이의 색상 능력에 대한 정보를 제공한다.|
|UA-CPU|클라이언트 CPU의 종류나 제조사를 알려준다.|
|UA-Disp|클라이언트 디스플레이 능력에 대한 정보를 제공한다.|
|UA-OS|클라이언트 기기의 OS의 이름과 버전을 알려준다.|
|UA-Pixels|클라이언트 기기 디스플레이에 대한 픽셀 정보를 제공한다.|
|User-Agent|요청을 보낸 에플리케이션의 이름을 서버에게 알려준다.|


##### Accept 관련 헤더
 - 클라이언트는 Accept 관련 헤더들을 이용해 서버에게 자신의 선호와 능력을 알려준다.

  
  |헤더|설명|
|------|---|
|Accept|서버가 보내도 되는 미디어 종류를 말해준다.|
|Accept-Charset|서버가 보내도 되는 문자집합을 말해준다.|
|Accept-Encoding|서버가 보내도 되는 인코딩을 말해준다.|
|Accept-Language|서버가 보내도 되는 언어를 말해준다.|

##### 조건부 요청 헤더
- 조건부 요청 헤더를 사용하면, 클라이언트는 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있다.

|헤더|설명|
|------|---|
|Expect||
|Accept-Charset|서버가 보내도 되는 문자집합을 말해준다.|
|Accept-Encoding|서버가 보내도 되는 인코딩을 말해준다.|
|Accept-Language|서버가 보내도 되는 언어를 말해준다.|

##### 요청 보안 헤더
  - HTTP는 자체적으로 요청을 위한 간단한 인증/응답 체계를 갖고있다.

|헤더|요청|
|------|---|
|Authorization|클라이언트가 서버에게 제공하는 인증 그자체에 대한 정보를 담고있다.|
|Cookie|클라이언트가 서버에게 토큰을 전달할때 사용한다.|
|Cookies2|클라이언트가 지원하는 쿠키의 버전을 알려줄때 사용한다.|

##### 프락시 요청 헤더

|헤더|설명|
|------|---|
|Max-Forwards|요청이 원 서버로 향 하는 과정에서 다른 프록시나 게이트웨이로 전달될 수 있는 최대 횟수. Trace 메서드와 함께 사용된다.|
|Proxy-Authorization|Authorization과 같으나 프록시에서 인증을 할 때 쓰인다.| 
|Proxy-Connection|Connection 과 같으나 프락시에서 연결을 맺을 때 쓰인다.|

#### 3.5.3 응답 헤더
  - 응답헤더는 응답 메시지의 헤더로 클라이언트에게 부가 정보를 제공한다.

|헤더|설명|
|------|---|
|Age|응답이 얼마나 오래되었는지?|
|Public|서버가 특정 리소스에 대해 지원하는 요청 메서드의 목록 ( 최신 HTTP 명세인 RFC 7231에는 정의되어 있지 않음|
|Retry-After|현재 리소스 사용 불가능한 상태일 때, 언제 가능해지는지 날짜 혹은 시간을 알려줌|
|Server|서버의 이름과 버전|
|Title|HTML 문서의 주어진 것과 같은 제목|
|Warning|사유 구절에 있는 것보다 더 자세한 경고 메시지|


##### 협상 헤더
 - 서버에서 여러 언어로 번역된 HTML 문서가 있는 경우와 같이 여러가지 표현이 가능한 상황이라면, HTTP/1.1은 서버와 클라이언트가 어떤 표현을 선택할 것인지 협상 할 수 있도록 지원한다.

|헤더|요청|
|------|---|
|Accept-Ranges|서버가 자원에 대해 받아들일 수 있는 범위의 형태|
|Vary|응답에 영향을 줄 수 있는 헤더들 목록. ex) 리소스의 버전정보|

##### 응답 보안 헤더


|헤더|설명|
|------|---|
|Proxy-Authenticate|프락시에서 클라이언트로 보낸 인증요구의 목록|
|Set-Cookie|클라이언트 측에 토큰을 설정하기 위해 사용한다. ( ex. sessionId를 쿠키로 구워 클라이언트에게 전달한다.)|
|Set-Cookie2|Set-Cookie와 비슷하게 RFC 2965로 정의된 쿠키.|
|WWW-Authenticate|서버에서 클라이언트로 보낸 인증요구 목록|

#### 3.5.4 엔터티 헤더
 - 요청과 응답 양쪽 모두 엔터티를 포함할 수 있기 때문에, 이 헤더들은 양 타입의 메시지에 모두 나타날 수 있다.

|헤더|설명|
|------|---|
|Allow|이 엔터티에 대해 수행될 수 있는 요청 메서드들을 나열한다.|
|Location|클라이언트에게 엔터티가 실제로 어디에 위치하고 있는지 말해준다.|

##### 콘텐츠 헤더
 - 콘텐츠 헤더는 엔터티의 콘텐츠에 대한 구체적인 정보를 제공한다.

|헤더|설명|
|------|---|
|Content-Base|본문에서 사용된 상대 URL을 계산하기 위한 기저 URL|
|Content-Encoding|본문에 적용된 인코딩|
|Content-Language|본문에 사용된 언어|
|Content-length|본문의 길이|
|Content-Location|리소스가 실제로 어디에 위치하는지|
|Content-MD5|본문의 MD5 체크섬|
|Content-Range|전체 리소스에서 이 엔터티가 해당하는 범위를 바이트 단위로 표현|
|Content-Type|본문의 객체의 종류|

##### 엔터티 캐싱 헤더
 - 엔터티 캐싱 헤더는 엔터티 캐싱에 대한 정보를 제공한다. ( ex. 리소스에 대해 캐시된 사본이 아직 유효한지, 캐시된 리소스가 언제까지 유효한지. )
  
  
|헤더|설명|
|------|---|
|ETag|엔터티에 대한 엔터티 태그 ( 리소스의 특정 버전에 대한 식별자 )|
|Expires|이 엔터티의 만료시간|
|Last-Modified|가장 최근 이 엔터티가 변경된 일시|


## 4장 커넥션 관리
- 이 장에서 다룰 내용
  - HTTP는 어떻게 TCP 커넥션을 사용하는가
  - TCP 커넥션의 지연, 병목, 막힘
  - 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
  - 커넥션 관리를 위해 따라야 할 규칙들

###  4.1 TCP 커넥션
  - 모든 HTTP 통신은 TCP/IP를 통해 이루어진다. ( 그림 4-1 참조 )

#### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP
 - TCP 커넥션은 인터넷을 안정적으로 연결해준다. ( HTTP에게 신뢰할만한 통신 방식을 제공한다.)
 - TCP 커넥션의 한쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 정확히 전달된다.

#### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.
 - TCP는 IP 패킷(IP 데이터그램)이라고 불리는 작은 조각을 통해 데이터를 전송한다.
 - HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보낸다. ( TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달한다. 각 TCP 세그먼트는 하나의 IP 주소에서 다른 IP주소로 IP 패킷에 담겨 전달된다. - 그림 4.4 참고)
 - IP 패킷들은 다음을 포함한다.
   - IP 패킷 헤더(보통 20 바이트) : 발신지와 목적지 IP 주소, 크기, 기타 플래그를 가진다.
   - TCP 세그먼트 헤더 ( 보통 20 바이트 ) : TCP 포트 번호, TCP 제어 플래그, 데이터의 순서와 무결성을 검사 하기위해 사용되는 숫자값 포함.
   - TCP 데이터 조각(0 혹은 그 아상의 바이트)

#### 4.1.3 TCP 커넥션 유지하기
  - IP 주소는 해당 컴퓨터에 연결되고 포트 번호는 해당 어플리케이션에 연결된다.
  - TCP 커넥션은 다음 네 가지 값으로 식별된다.(아래 4가지 값으로 유일한 커넥션을 생성한다.)
    - <발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>


### 4.2 TCP의 성능에 대한 고려
 - HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.


#### 4.2.1 HTTP 트랜잭션 지연
 - 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생한다.
 - HTTP 트랜잭션을 지연시키는 원인은 여러가지 존재한다.
   - 1. 도메인 -> ip 로 변환하는 시간 ( 브라우져 캐시 -> dns 캐시(ipconfig /displaydns ) -> hosts 파일 -> DNS 서버)
   - 2. 클라이언트는 TCP 커넥션 요청을 서버에게 보내고 서버가 커넥션 허가 응답을 회신하기를 기다린다. ( 커넥션 설정 시간은 새로운 TCP 커넥션에서 항상 발생한다.)
   - 3. 요청 메시지가 인터넷을 통해 전달되고 서버에 의해 처리되는데 까지 시간이 소요된다.
   - 4. 웹서버가 HTTP 응답을 보내는 것 역시 시간이 소요된다.
   - 5. 1~4의 TCP 네트워크 지연은 하드웨어 성능, 네트워크와 서버의 전송 속도, 요청과 응답 메시지의 크기, 클라이언트와 서버 간의 거리에 따라 크게 달라진다. 또한, TCP 프로토콜의 기술적인 복잡성도 지연에 큰 영향을 끼친다.


#### 4.2.2 성능 관련 중요 요소
 - TCP 커넥션의 핸드셰이크 설정
 - 인터넷 혼밪을 제어하기 위한 TCP의 느린 시작(slow-start)
 - 데이터를 한데 모아 한 번에 전송하기 위한 네이글(nagle) 알고리즘
 - TCP의 편승 확인응답을 위한 확인응답 지연 알고리즘
 - TIME_WAIT 지연과 포트 고갈

#### 4.2.3 TCP 커넥션 핸드셰이크 지연
  - 어떤 데이터를 전송하든 새로운 TCP 커넥션을 열 때면, TCP 소프트웨어는 커넥션을 맺기 위한 조건을 맞추기 위해 연속으로 IP 패킷을 교환한다. ( 3 handshake )
  - TCP 커넥션의 핸드셰이크 순서 
    - 1. 클라이언트 -> 서버 ( SYN 플래그 전송 - 커넥션 생성 요청)
    - 2. 서버 -> 클라이언트 ( SYN + ACK - 커넥션 생성 요청 및 확인 응답신호 )
    - 3. 클라이언트 -> 서버 ( ACK - 확인 응답 신호)
 -  1, 2 단계에서 주로 지연이 발생한다. -> 크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP를 구성하는데 쓴다.

#### 4.2.4 확인응답 지연 ( 책 참고 )
  - 각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가진다. 
  - 각 세그먼트의 수신자는 세그먼트를 온전히 받으면 작은 확인응답 패킷을 송신자에게 반환한다. -> 만약, 송신자가 특정 시간 안에 확인응답 메시지를 받지 못하면 패킷이 파기되었거나 오류가 있는 것으로 판단하고 데이터를 재전송한다.
  - 확인응답은 크기가 작기 떄문에 TCP는 같은 방향으로 전송되는 데이터 패킷에 확인응답을 편승시킨다. ( TCP는 송출 데이터 패킷과 확인응답을 하나로 묶음으로써 네트워크를 좀 더 효율적으로 사용한다.)
  - 확인응답이 같은 방향으로 가는 데이터 패킷에 편승되는 경우를 늘리기 위해, 많은 TCP 스택은 '확인용 응답 지연' 알고리즘을 구현한다.


#### 4.2.5 TCP 느린 시작(slow start)
 - TCP 커넥션은 시간이 지나면서 자체적으로 "튜닝" 되어서, 처음에는 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라서 속도 제한을 높여 나간다. ( 이로써 인터넷의 급작스러운 부하와 혼잡을 방지할 수 있다. )
 - 새로운 커넥션 보다 이미 데이터를 주고 받은 커넥션이 더 빠르기 때문에 ( 보낼 수 있는 패킷의 양이 늘어남 ) HTTP에는 이미 존재하는 커넥션을 재사용하는 기능이 있다.

#### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY
 - 네이글 알고리즘은 네트워크 효율을 위해서, 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한 개의 덩어리로 합친다.
 - 네이글 알고리즘은 세그먼트가 최대 크기가 되지 않으면 전송을 하지 않는다. 다만, 다른 모든 패킷이 확인응답을 받았을 경우에는 최대 크기보다 작은 패킷의 전송을 허락한다.
 - -> 데이터를 받자마자 바로 보내지 않고 쌓았다가 한번에 보낸다. 매번 보낼경우 http 해더, tcp 해더, 플래그 같은 중복된 정보를 매번 넣어줘야 되서 네트워크 성능을 떨어 뜨릴 수 있다.
 - 네이글 알고리즘은 HTTP 성능 관련해 여러 문제를 발생시킨다.
   - 1. 크기가 작은 HTTP 메시지는 패킷을 채우기 못하기 때문에 추가적인 데이터를 기다리며 지연이 발생한다.
   - 2. 확인응답 지연 알고리즘과 함께 쓰일 경우 형편없이 동작한다. ( 네이글 알고리즘은 확인 응답이 도착할 떄까지 데이터 전송을 멈추고 있는 반면, 확인응답 지연 알고리즘은 확인응답을 0.1~0.2초 지연시킨다. )
 - -> 따라서, HTTP 애플리케이션은 성능 향상을 위해서 HTTP 스택에 TCP_NODELAY 파라미터 값을 설정하여 네이글 알고리즘을 비활성화 하기도 한다.


#### 4.2.7 TIME_WAIT의 누적과 포트 고갈
  - TCP 커넥션의 종단에서 TCP 커넥션을 끊으면, 종단에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 제어영역에 기록해 놓는다. ( 같은 주소와 포트번호를 사용하는 새로운 TCP 커넥션이 일정 시간동안 생성되지 않게 하기 위함.)

#### 3 handShake, 4 handShake 과정
 - https://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-22%ED%8E%B8-TCP-3-WayHandshake-4-WayHandshake
 - https://asfirstalways.tistory.com/356

### 4.3 HTTP 커넥션 관리

#### 4.3.1 흔히 잘못 이해하는 Connection 헤더
 -  HTTP Connection 헤더 필드는 커넥션 토큰을 쉼표로 구분하여 가지고 있으며, 그 값들은 다른 커넥션에 전달되지 않는다.
 - 커넥션 토큰이 HTTP 헤더 필드 명을 가지고 있으면, 필드들은 현재 커넥션만을 위한 정보이므로 다음 커넥션에 전달하면 안 된다.

#### 4.3.2 순차적인 트랜잭션 처리에 의한 지연
 - 여러 리소스를 받아와야 할때 동기적으로 처리되기 때문에 느리다.
 - 순차적인 트랜잭션 처리에 의한 지연을 해결하기 위해 병렬커넥션, 지속 커넥션, 파이프라인 커넥션, 다중 커넥션과 같은 방법들이 있다.

### 4.4 병렬 커넥션
 - HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러개의 HTTP 트랜잭션을 병렬로 처리한다. 

#### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다.
 - 그림 4-12 참조
#### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다.
 - 병렬 커넥션이 일반적으로 더 빠르기는 하지만 항상 그렇지는 않다. ( 네트워크 대역폭이 좁을때 -> 예를들면, 최대 1개의 TCP 커넥션의 데이터만을 전송가능한 대역폭에서 커넥션을 여러개 만들어서 병렬처리를 하면 1개의 커넥션으로 보내는 것보다 오히려 성능이 떨어질 수 있다. -> 커넥션 객체가 메모리를 잡아먹음 )
### 4.5 지속 커넥션
 - 웹 클라이언트는 보통 같은 사이트에 여러개의 커넥션을 맺는다.( 병렬 커넥션으로 리소스 가져오는듯 )
 - HTTP/1.1을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있다. ( 지속 커넥션 )
 - 비 지속 커넥션은 각 처리가 끝날 때마다 커넥션을 끊지만, 지속 커넥션은 클라이언트나 서버가 커넥션을 끊기 전까지는 트랜잭션 간에도 커넥션을 유지한다.

#### 4.5.1 지속 커넥션 vs 병렬 커넥션
 - 병렬 커넥션의 단점
   - 각 트랜잭션 마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요된다.
   - 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어진다.
   - 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있다.
 - 병렬 커넥션 대비 지속 커넥션의 장점
   - 커넥션을 맺기 위한 사전 작업과 지연을 줄여준다.
   - 커넥션 수를 줄여준다.
 - 가장 이상적인 방법
   - 병렬 커넥션과 지속 커넥션을 같이 사용한다. 즉, 적은수의 병렬커넥션을 유지 하되 각 커넥션은 지속커넥션으로 연결을 유지한다.
#### 4.5.2 HTTP/1.0+와 Keep-Alive 커넥션
 - Keep-Alive 커넥션 = 지속 커넥션 -> 커넥션을 끊지 않고 유지한다. ( 재사용 )
#### 4.5.3 Keep-Alive 동작
 - Keep-Alive는 사용하지 않기로 결정되어 HTTP/1.1 명세에서 빠졌다.
 - HTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해서 요청에 Connection:Keep-Alive 해더를 포함시킨다. ( 그림  4-14 참조 )
#### 4.5.4 Keep-Alive 옵션
 - Keep-Alive의 동작은 Keep-Alive 헤더의 쉼표로 구분된 옵션들로 제어할 수 있다.
 - Keep-Alive 헤더 사용은 선택 사항이지만, Connection:Keep-Alive 헤더가 있을 때만 사용할 수 있다.
 - timeout : 커넥션이 얼마간 유지될 것인지는 의미한다.
 - max : 커넥션이 몇 개의 HTTP 트랜잭션을 처리할 때 까지 유지될 것인지를 의미한다.
   ```
   // 서버가 5개의 트랜잭션이 처리될 동안 커넥션을 유지하거나, 2분동안 커넥션을 유지
    Connection: Keep-Alive
    Keep-Alive: max=5, timeout=120
   ```
 
 #### 4.5.5 Keep-Alive 커넥션 제한과 규칙
  - Keep-Alive는 HTTP/1.0에서 기본으로 사용되지 않는다. 클라이언트는 Keep-alive 커넥션을 사용하기 위해 Connection: Keep-Alive 요청 헤더를 보내야 한다.
  - 커넥션을 계속 유지하려면 모든 메시지에 Connection: Keep-Alive 헤더를 포함해 보내야 한다. 만약, 클라이언트가 Connection: Keep-Alive 해더를 보내지 않으면 서버는 요청을 처리한 후 커넥션을 끊을 것이다.
  - 클라이언트는 Connection: Keep-Alive 응답 헤더가 없는 것을 보고 서버가 응답 후에 커넥션을 끊을 것임을 알 수 있다.
  - 커넥션이 끊어지기 전에 엔터티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있다. (부정확한 Content-Lenth값 -> 트랙잭션이 끝나는 시점에 기존 메시지의 끝과 새로운 메시지의 시작점을 정확히 알 수 없음.)
  - 기술적으로 HTTP/1.0을 따르는 기기로부터 받은 모든 Connection 헤더 필드는 무시해야 된다.

#### 4.5.6 Keep-Alive와 멍청한 프락시
##### Connection 헤더의 무조건 전달
 - 프락시는 Connection 헤더를 이해하지 못해서 해당 헤더들을 삭제하지 않고 요청 그대로를 다음 프락시에 전달한다.
 - 그림 4-15 참고

#### 프락시와 홉별 헤더
  - 이런 종류의 잘못된 통신을 피하려면, 프락시는 Connection 헤더와 Connection 헤더에 명시된 헤더들은 절대 전달해서는 안된다.( Keep-Alive, Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade..)

#### 4.5.8 HTTP/1.1의 지속 커넥션
  - HTTP/1.1에서는 keep-alive 커넥션을 지원하지 않는 대신, 설계가 더 개선된 지속 커넥션을 지원한다.
  - HTTP/1.0의 keep-alive 커넥션과는 달리 HTTP/1.1의 지속 커넥션은 기본으로 활성화 되어있다. ( HTTP/1.1에서는 별도 설정을 하지 않는 한, 모든 커넥션을 지속 커넥션으로 취급한다.)
  - HTTP/1.1 애플리케이션은 트랜잭션이 끝난 다음 커넥션을 끊으려면 Connection:close 헤더를 명시해야 한다. ( HTTP/1.1 클라이언트는 응답에 Connection:close 헤더가 없으면 응답 후에도 HTTP/1.1 커넥션을 계속 유지하자는 것으로 추정한다.)

### 4.6 파이프라인 커넥션
 - HTTP/1.1은 지속 커넥션을 통해서 요청을 파이프라이닝 할 수 있다. 이는 keep-alive 커넥션의 성능을 더 높여준다. ( 그림 4-18 참조 )
 - 파이프라인에는 여러가지 제약 사항이 있다.
   - HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서는 안된다.
   - HTTP 응답은 요청 순서와 같게 와야 한다. HTTP 메시지는 순번이 있지 않아서 응답이 순서없이 오면 순서에 맞게 정렬할 방법이 없다.
   - 완료되지 않은 요청이 파이프라인에 있으면 언제든 다시 요청을 보낼 준비가 되어 있어야 한다.
   - HTTP 클라이언트는 POST 요청과 같이 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해 보내면 안된다. 그렇지 않으면 전송 커넥션이 예상치 못하게 끊어져 버렸을 때, 알 수 없는 결과를 초래할 수 있다. 비멱등인 요청을 다시 보내야 한다면, 이전 요청에 대한 응답을 받을 때까지 기다려야 한다.


### 4.7 커넥션 끊기에 대한 미스터리
#### 4.7.4 우아한 커넥션 끊기
 - TCP 커넥션은 양방향이다. ( TCP 커넥션의 양쪽에는 데이터를 읽거나 쓰기 위한 입력 큐와 출력 큐가 있다. - 그림 4-19 참조)

##### 전체 끊기와 절반 끊기
 - 애플리케이션은 TCP 입력 채널과 출력 채널 중 한 개만 끊거나 둘 다 끊을 수 있다.
 - close를 호출하면 TCP 커넥션의 입력 채널과 출력 채널의 커넥션을 모두 끊는다. ("전체 끊기")
 - 입력, 출력 채널 중 하나를 개별적으로 끊으려면 shutdowm( )을 호출한다. ( "절반 끊기")

##### TCP 끊기와 리셋 에러
 - 내 출력 채널을 끊고, 상대방의 커넥션에서 모든 데이터 전송이 완료되고 나서 입력채널을 끊는다. ( 내 입력채널을 먼저 끊을 경우 상대방이 아직 데이터를 보내고 있을 수도 있으므로...)

##### 우아하게 커넥션 끊기
- 일반적으로 에플리케이션이 우아한 커넥션 끊기를 구현하는 것은 애플리케이션 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것이다. ( 양쪽에서 더는 데이터 전송을 하지 않을 것이라고 알려주면 커넥션은 리셋의 위험 없이 온전히 종료된다. )

