3장 HTTP 메시지(p.49)
    3.1 메시지의 흐름(p.49)
        3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다.(p.50)
            - 클라이언트 -> 서버로 들어오는건 인바운드
              다시 클라이언트로 돌아가는건 아웃바운드. 서버 기준으로 생각하면 된다.
        3.1.2 다운스트림으로 흐르는 메시지(p.50)
            - 그냥 발송자 -> 수신자로 흐른다는 이야기를 어렵게 써놨다.
    3.2 메시지의 각 부분(p.50)
        - 앞서 나온것처럼 메시지는 시작줄, 헤더, 본문 이렇게 3부분으로 이루어진다.
        - 시작줄과 헤더를 구분할때 2글자로 된 캐리지 리턴 + 개행 문자로 줄을 바꾼다. (CRLF)
        - 오래되거나 잘못 만들어진 HTTP 애플리케이션들은 이들을 모두 항상 전송하지 않는 것도 있기 때문에 그냥 개행 문자도 받아들일 수 있도록 만들어져야함.
        - 반면 본문은 그냥 개행 문자가 포함될 수도 있기 때문에 개행 문자를 추가하지 않는다.(사실 뒤에 더 구분될 것도 없다.)
        - Content-Length는 본문의 길이를 의미한다.
        3.2.1 메시지 문법(p.52)
            - 메서드, 요청 URL, 버전, 상태 코드, 사유 구절, 헤더들, 엔터티 본문으로 이루어짐.
        3.2.2 시작줄(p.54)
            - 요청줄, 응답줄이 포함하고 있는게 조금 다르고
            - 메서드(요청줄), 상태코드(응답줄), 사유구절(응답줄), 버전 번호(공통)로 이루어짐
            - 메서드별로 POST, PUT은 본문이 있으나 나머지는 없음.
        3.2.3 헤더(p.58)
            - 해당 요청/응답에 대한 메타데이터를 가지고 있다.
            - 요청과 응답이 각각 다른 헤더를 가짐.
            - 모든 헤더에 대한 자세한 요약은 부록 C에 있다.
        3.2.4 엔터티 본문(p.59)
            - 보통 BODY라고 하고, 요청에도 있고 응답에도 있다.
        3.2.5 버전 0.9 메시지(p.60)
            - HTTP 프로토콜의 초기 버전(1991년)
            - 버전이 다른게 없었기 때문에 버전 정보가 없다.
            - 현재까지 해당 버전을 사용하는 애플리케이션도 있다.
    3.3 메서드(p.60)
        - 모든 서버가 모든 메서드를 구현하지는 않는다.
        - 또한 서버에서 리소스 상태를 변경할 수 있는 DELETE, PUT 과 같은 메소드는 아무나 실행시킬 수 없고, 대부분 권한있는 사용자만 실행시킬 수 있다.
        3.3.1 안전한 메서드(Safe Method)(p.61)
            - GET, HEAD를 안전한 메서드라고 할 수 있는데 이는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.
            - 안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 없다.(사실 그건 웹 개발자에게 달렸다.)
        3.3.2 GET(p.61)
            - 가장 흔히 쓰이는 메서드. 주로 서버에게 리소스를 달라고 요청하기 위해 사용
        3.3.3 HEAD(p.62)
            - GET처럼 행동하지만 서버의 응답으로 헤더만 돌려준다.
            - 해당 URL의 리소스의 타입을 알아낼 수 있고, 응답 상태 코드를 통해 개체가 존재하는지 확인, 변경되었는지도 확인 가능하다.
            - 서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야한다.
        3.3.4 PUT(p.63)
            - PUT 메서드는 서버에 문서를 쓰는 작업을 한다. (새로 만들거나 있다면 본문을 교체한다.)
            - 콘텐츠가 변경되기 때문에 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 로그인을 하도록 한다.
        3.3.5 POST(p.63)
            - 서버에 입력 데이터를 전송하기 위해 설계되었음.
        3.3.6 TRACE(p.63)
            - 게이트웨이, 프록시 등에서 원래 HTTP 요청이 수정될 수 있기 때문에 실제 서버에 도달했을 때 클라이언트의 요청이 어떻게 보이는지를 응답해준다.
            - TRACE의 응답의 엔티티 본문에는 서버가 받은 요청이 그대로 들어있다.
        3.3.7 OPTIONS(p.65)
            - 해당 웹서버가 해당 URL에 어떤 메소드를 지원하는지 알려준다.
            - 응답의 Allow 헤더에 담겨있음.
        3.3.8 DELETE(p.66)
            - 리소스를 삭제한다.
        3.3.9 확장 메서드(p.66)
            - 확장 메서드를 구현하는건 자유다. 하지만 서버와 클라이언트 모두에 정의되어야한다.
            - "엄격하게 보내고 관대하게 받아들여라"
    3.4 상태 코드(p.67)
        - HTTP 상태코드는 100 번대 ~ 500 번대로 총 5개의 구간으로 나뉜다.
        3.4.1 100-199: 정보성 상태 코드(p.67)
            - HTTP/1.1에서 추가되었고, 복잡함을 감수할 만한 가치가 있는지에 대해 논란이 되고 있음.
            - 100은 Continue로 요청의 시작 부분 일부가 받아들여졌고, 클라이언트가 나머지를 계속 이어서 보내야 한다는 것을 의미한다.
            - 요약하면 서버나 클라이언트, 프록시 등이 HTTP/1.1 버전 이상이어야하고, 100 Continue를 사용하기로 정의/구현 되어있어야한다.
        3.4.2 200-299: 성공 상태 코드(p.69)
            - 요청이 성공했음을 의미한다.
            - 많은 경우 (내가 개발할 때 포함) 200 OK로 퉁치고 있으나, HTTP를 잘 활용하려면 이러한 상태코드를 지켜서 응답을 해주면 좋겠다.
        3.4.3 300-399: 리다이렉션 상태 코드(p.70)
            - 클라이언트가 요청한 리소스가 다른 위치에 있다고 말해주거나 내용 대신 다른 대안을 응답으로 제공함.
            - 응답 해더의 Location 헤더에 어디로 리다이렉션 될지 지정해줄 수 있다.
            - 대개 브라우저가 사용자를 귀찮게 하지 않고 알아서 새로운 위치로 보내준다.
            - 301, 304, 307, 308(308은 표준은 아니라고함) 정도를 제일 많이 본 것 같다.
                - 참고 : HTTP 상태 코드 ‘308’이란?(http://www.techholic.co.kr/news/articleView.html?idxno=12935#rs)
        3.4.4 400-499: 클라이언트 에러 상태 코드(p.74)
            - 클라이언트 측 에러라고는 하지만, 클라이언트가 제대로 보내고 있고 사실 서버쪽에서 해당 기능을 잘못 구현해서 발생하는 경우도 많음.
            - 400, 401, 403, 404, 405, 408, 409, 410, 413, 414 정도는 많이 본 것 같음.
        3.4.5 500-599: 서버 에러 상태 코드(p.75)
            - 책에 나온 내용처럼 "클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우가 있다."가 핵심인듯.
            - 500, 502, 503, 504 정도를 많이 본 것 같다.
    3.5 헤더(p.76)
        - 요청/응답 메시지에 포함되는 헤더
        - 일반 헤더(공통), 요청 헤더, 응답 헤더, 엔티티 헤더, 확장 헤더가 있다.
        3.5.1 일반 헤더(p.78)
            - 요청 응답에 모두 사용되는 헤더임.
            - Cache-Control 헤더가 제일 중요한 것 같다.
        3.5.2 요청 헤더(p.78)
            - 요청 메시지에만 포함된다.
            - IP, Host(서버명), Referer(어느 문서를 통해 왔는지), User-Agent 등이 포함된다.
            - Accept 관련 헤더는 다국어 지원시 중요하다. ("서버는 클라이언트가 사용할 수도 없는 것을 전송하는데 시간과 대역폭을 낭비하지 않을 수 있다.")
            - 조건부 요청 헤더는 사용 안해봤으나 유용할듯.
            - 요청 보안 헤더의 경우 보안 관련 토큰이나 쿠키 등이 포함된다. -> 인증/인가 관련
            - 프락시 요청 헤더도 사용해보진 않았음. 프록시에 인증 기능이 포함된 경우 필요할 것 같다.
        3.5.3 응답 헤더(p.81)
            - 응답 메시지에 포함되는 헤더임.
            - Server에 서버 애플리케이션의 이름과 버전이 들어가지만 일반적으로 이 헤더는 응답 메시지에 포함하지 않도록 해야함(서버 버전 노출에 따른 취약점 노출)
            - 응답 보안 헤더에서 Set-Cookie 헤더가 있는데 이 헤더를 받은 클라이언트는 해당 호스트에서 다음 요청부터 해당 쿠키를 모든 요청에 붙인다.
        3.5.4 엔터티 헤더(p.82)
            - 엔티티에 대해 설명하기 위한 헤더임.
            - 컨텐츠 관련 헤더들이 포함된다.
            - 엔티티 캐싱 헤더에 Expires, Last-Modified 등을 이용해 컨텐츠를 캐싱할지 다시 보내줄지 판단할 수 있다.
