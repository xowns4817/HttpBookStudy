3장 HTTP 메시지(p.49)
    3.1 메시지의 흐름(p.49)
        3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다.(p.50)
            - 클라이언트 -> 서버로 들어오는건 인바운드
              다시 클라이언트로 돌아가는건 아웃바운드. 서버 기준으로 생각하면 된다.
        3.1.2 다운스트림으로 흐르는 메시지(p.50)
            - 그냥 발송자 -> 수신자로 흐른다는 이야기를 어렵게 써놨다.
    3.2 메시지의 각 부분(p.50)
        - 앞서 나온것처럼 메시지는 시작줄, 헤더, 본문 이렇게 3부분으로 이루어진다.
        - 시작줄과 헤더를 구분할때 2글자로 된 캐리지 리턴 + 개행 문자로 줄을 바꾼다. (CRLF)
        - 오래되거나 잘못 만들어진 HTTP 애플리케이션들은 이들을 모두 항상 전송하지 않는 것도 있기 때문에 그냥 개행 문자도 받아들일 수 있도록 만들어져야함.
        - 반면 본문은 그냥 개행 문자가 포함될 수도 있기 때문에 개행 문자를 추가하지 않는다.(사실 뒤에 더 구분될 것도 없다.)
        - Content-Length는 본문의 길이를 의미한다.
        3.2.1 메시지 문법(p.52)
            - 메서드, 요청 URL, 버전, 상태 코드, 사유 구절, 헤더들, 엔터티 본문으로 이루어짐.
        3.2.2 시작줄(p.54)
            - 요청줄, 응답줄이 포함하고 있는게 조금 다르고
            - 메서드(요청줄), 상태코드(응답줄), 사유구절(응답줄), 버전 번호(공통)로 이루어짐
            - 메서드별로 POST, PUT은 본문이 있으나 나머지는 없음.
        3.2.3 헤더(p.58)
            - 해당 요청/응답에 대한 메타데이터를 가지고 있다.
            - 요청과 응답이 각각 다른 헤더를 가짐.
            - 모든 헤더에 대한 자세한 요약은 부록 C에 있다.
        3.2.4 엔터티 본문(p.59)
            - 보통 BODY라고 하고, 요청에도 있고 응답에도 있다.
        3.2.5 버전 0.9 메시지(p.60)
            - HTTP 프로토콜의 초기 버전(1991년)
            - 버전이 다른게 없었기 때문에 버전 정보가 없다.
            - 현재까지 해당 버전을 사용하는 애플리케이션도 있다.
    3.3 메서드(p.60)
        - 모든 서버가 모든 메서드를 구현하지는 않는다.
        - 또한 서버에서 리소스 상태를 변경할 수 있는 DELETE, PUT 과 같은 메소드는 아무나 실행시킬 수 없고, 대부분 권한있는 사용자만 실행시킬 수 있다.
        3.3.1 안전한 메서드(Safe Method)(p.61)
            - GET, HEAD를 안전한 메서드라고 할 수 있는데 이는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.
            - 안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 없다.(사실 그건 웹 개발자에게 달렸다.)
        3.3.2 GET(p.61)
            - 가장 흔히 쓰이는 메서드. 주로 서버에게 리소스를 달라고 요청하기 위해 사용
        3.3.3 HEAD(p.62)
            - GET처럼 행동하지만 서버의 응답으로 헤더만 돌려준다.
            - 해당 URL의 리소스의 타입을 알아낼 수 있고, 응답 상태 코드를 통해 개체가 존재하는지 확인, 변경되었는지도 확인 가능하다.
            - 서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야한다.
        3.3.4 PUT(p.63)
            - PUT 메서드는 서버에 문서를 쓰는 작업을 한다. (새로 만들거나 있다면 본문을 교체한다.)
            - 콘텐츠가 변경되기 때문에 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 로그인을 하도록 한다.
        3.3.5 POST(p.63)
            - 서버에 입력 데이터를 전송하기 위해 설계되었음.
        3.3.6 TRACE(p.63)
            - 게이트웨이, 프록시 등에서 원래 HTTP 요청이 수정될 수 있기 때문에 실제 서버에 도달했을 때 클라이언트의 요청이 어떻게 보이는지를 응답해준다.
            - TRACE의 응답의 엔티티 본문에는 서버가 받은 요청이 그대로 들어있다.
        3.3.7 OPTIONS(p.65)
            - 해당 웹서버가 해당 URL에 어떤 메소드를 지원하는지 알려준다.
            - 응답의 Allow 헤더에 담겨있음.
        3.3.8 DELETE(p.66)
            - 리소스를 삭제한다.
        3.3.9 확장 메서드(p.66)
            - 확장 메서드를 구현하는건 자유다. 하지만 서버와 클라이언트 모두에 정의되어야한다.
            - "엄격하게 보내고 관대하게 받아들여라"
    3.4 상태 코드(p.67)
        - HTTP 상태코드는 100 번대 ~ 500 번대로 총 5개의 구간으로 나뉜다.
        3.4.1 100-199: 정보성 상태 코드(p.67)
            - HTTP/1.1에서 추가되었고, 복잡함을 감수할 만한 가치가 있는지에 대해 논란이 되고 있음.
            - 100은 Continue로 요청의 시작 부분 일부가 받아들여졌고, 클라이언트가 나머지를 계속 이어서 보내야 한다는 것을 의미한다.
            - 요약하면 서버나 클라이언트, 프록시 등이 HTTP/1.1 버전 이상이어야하고, 100 Continue를 사용하기로 정의/구현 되어있어야한다.
        3.4.2 200-299: 성공 상태 코드(p.69)
            - 요청이 성공했음을 의미한다.
            - 많은 경우 (내가 개발할 때 포함) 200 OK로 퉁치고 있으나, HTTP를 잘 활용하려면 이러한 상태코드를 지켜서 응답을 해주면 좋겠다.
        3.4.3 300-399: 리다이렉션 상태 코드(p.70)
            - 클라이언트가 요청한 리소스가 다른 위치에 있다고 말해주거나 내용 대신 다른 대안을 응답으로 제공함.
            - 응답 해더의 Location 헤더에 어디로 리다이렉션 될지 지정해줄 수 있다.
            - 대개 브라우저가 사용자를 귀찮게 하지 않고 알아서 새로운 위치로 보내준다.
            - 301, 304, 307, 308(308은 표준은 아니라고함) 정도를 제일 많이 본 것 같다.
                - 참고 : HTTP 상태 코드 ‘308’이란?(http://www.techholic.co.kr/news/articleView.html?idxno=12935#rs)
        3.4.4 400-499: 클라이언트 에러 상태 코드(p.74)
            - 클라이언트 측 에러라고는 하지만, 클라이언트가 제대로 보내고 있고 사실 서버쪽에서 해당 기능을 잘못 구현해서 발생하는 경우도 많음.
            - 400, 401, 403, 404, 405, 408, 409, 410, 413, 414 정도는 많이 본 것 같음.
        3.4.5 500-599: 서버 에러 상태 코드(p.75)
            - 책에 나온 내용처럼 "클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우가 있다."가 핵심인듯.
            - 500, 502, 503, 504 정도를 많이 본 것 같다.
    3.5 헤더(p.76)
        - 요청/응답 메시지에 포함되는 헤더
        - 일반 헤더(공통), 요청 헤더, 응답 헤더, 엔티티 헤더, 확장 헤더가 있다.
        3.5.1 일반 헤더(p.78)
            - 요청 응답에 모두 사용되는 헤더임.
            - Cache-Control 헤더가 제일 중요한 것 같다.
        3.5.2 요청 헤더(p.78)
            - 요청 메시지에만 포함된다.
            - IP, Host(서버명), Referer(어느 문서를 통해 왔는지), User-Agent 등이 포함된다.
            - Accept 관련 헤더는 다국어 지원시 중요하다. ("서버는 클라이언트가 사용할 수도 없는 것을 전송하는데 시간과 대역폭을 낭비하지 않을 수 있다.")
            - 조건부 요청 헤더는 사용 안해봤으나 유용할듯.
            - 요청 보안 헤더의 경우 보안 관련 토큰이나 쿠키 등이 포함된다. -> 인증/인가 관련
            - 프락시 요청 헤더도 사용해보진 않았음. 프록시에 인증 기능이 포함된 경우 필요할 것 같다.
        3.5.3 응답 헤더(p.81)
            - 응답 메시지에 포함되는 헤더임.
            - Server에 서버 애플리케이션의 이름과 버전이 들어가지만 일반적으로 이 헤더는 응답 메시지에 포함하지 않도록 해야함(서버 버전 노출에 따른 취약점 노출)
            - 응답 보안 헤더에서 Set-Cookie 헤더가 있는데 이 헤더를 받은 클라이언트는 해당 호스트에서 다음 요청부터 해당 쿠키를 모든 요청에 붙인다.
        3.5.4 엔터티 헤더(p.82)
            - 엔티티에 대해 설명하기 위한 헤더임.
            - 컨텐츠 관련 헤더들이 포함된다.
            - 엔티티 캐싱 헤더에 Expires, Last-Modified 등을 이용해 컨텐츠를 캐싱할지 다시 보내줄지 판단할 수 있다.


4장 커넥션 관리(p.85) -> https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x
    4.1 TCP 커넥션(p.85)
        - TCP/IP 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고 받는 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.
        - TCP/IP로 커넥션을 맺는 과정은 [그림 4-1] 참고
        4.1.1 신뢰할  수 있는 데이터 전송 통로인 TCP(p.87)
            - TCP는 HTTP에 신뢰할 만한 통신 방식을 제공한다.
        4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.(p.87)
            - TCP는 IP 패킷이라고 불리는 작은 조각을 통해 데이터가 전송된다.
            - HTTPS는 HTTP에서 애플리케이션 계층과 전송 계층 사이에 보안 계층이 추가된 것임.
            - 이 모든 것은 TCP/IP 소프트웨어에 의해 처리되며, 그 과정은 HTTP 프로그래머에게 보이지 않는다. (중요)
            - [그림 4-4]에 TCP 세그먼트의 그림이 나와있다. 와이어샤크로 실제 HTTP 패킷을 캡쳐해서 확인해보자.
        4.1.3 TCP 커넥션 유지하기(p.88)
            - 컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있다. (cmd를 켜서 netstat -nao 명령을 쳐보자.)
            - TCP 넥션은 다음 4가지 값으로 식별된다. (scr ip, src port, dest ip, dest port)
            - 서로 다른 커넥션이 같은 목적지 포트를 가리킬 수 있다.
        4.1.4 TCP 소켓 프로그래밍(p.90)
            - [표 4-2]는 유닉스 운영체제용으로 개발된 소켓 API들을 보여준다. C언어로 해당 API들을 직접 사용할 수 있다.
            - [그림 4-6]에서 클라이언트와 서버간에 HTTP 트랜잭션을 수행하는 슈도코드를 보여주고 있다. 요약하자면 다음과 같다.
                - 서버 소켓 생성 -> 서버 포트 바인딩 -> 서버 리슨 -> 클라이언트 소켓 생성 -> 클라이언트 연결 -> 서버와 클라이언트가 연결 -> HTTP 요청 응답 -> 클라이언트 클로즈 -> 서버 클로즈
    4.2 TCP의 성능에 대한 고려(p.91)
        - HTTP의 트랜잭션 성능은 TCP의 성능에 영향을 받음.
        4.2.1 HTTP 트랜잭션 지연(p.92)
            - 트랜잭션을 처리하는 시간은 TCP 커넥션을 맺고, 요청 응답 메시지를 전송하는 시간에 비하면 매우 짧다.(오버헤드가 크다는 뜻)
            - 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생한다.
            - 다음과 같은 것들이 지연을 초래한다.
                - DNS에서 도메인 -> IP로 변경되는 과정
                - 서버와 클라이언트가 커넥션을 맺는 과정
                - 요청/응답이 전송되는데 걸리는 시간
            - 위와 같은 과정들을 통틀어 보통 네트워크 비용이라고함.
        4.2.2 성능 관련 중요 요소(p.93)
            - 이후부터 다음과 같은 요소들을 다룬다.
                - TCP 커넥션 핸드셰이크
                - 혼잡 제어를 위한 TCP의 slow-start
                - 데이터를 모아 한번에 전송하기 위한 네이글(nagle) 알고리즘
                - TCP의 편성 확인응답을 위한 확인응답 지연 알고리즘
                - TIME_WAIT 지연과 포트 고갈
        4.2.3 TCP 커넥션 핸드셰이크 지연(p.93)
            - TCP는 Three Way Handshake를 하고, 이 과정은 한번의 HTTP 트랜잭션을 수행시키기 위해 동일하게 한번씩 수행된다.
            - 이는 아무리 작은 HTTP 요청/응답도 마찬가지임. 때문에 이후 절에서는 이러한 지연을 극복하기 위한 방법들이 나온다.
        4.2.4 확인응답 지연(p.95)
            - 인터넷 자체가 패킷 전송을 완벽히 보장하지는 않는다.(라우터가 과부하에 걸렸을 떄 마음대로 파기할 수 있음.)
            - TCP는 성공적인 데이터 전송을 위해 각 TCP 세그먼트의 순번과 데이터 무결성 체크섬을 가짐.
            - 각 세그먼트를 잘 받았으면 잘 받았다는 응답을 하고, 응답이 없으면 못받은 것으로 간주하고 다시 해당 세그먼트를 보낸다.
            - 이때 확인응답은 그 크기가 작아서, 같은 방향으로 이동하는 데이터 패킷에 확인응답을 편승시킴(데이터 패킷에 끼워 넣는다는 의미)
            - 편승시키기 위해서 확인응답을 보내는걸 0.1~0.2초 정도 지연시키는데, 이게 바로 확인응답 지연이다.
            - 하지만 HTTP는 요청/응답으로만 이루어져서 편승할 기회가 별로 없음. 때문에 HTTP에게는 확인응답 지연은 오히려 요청/응답을 지연시키는 부작용을 초래함.
            - 이를 위해 HTTP 애플리케이션은 확인응답 지연 관련 기능을 비활성화 할 것을 고려해봐야함.
        4.2.5 TCP 느린 시작(slow start)(p.95)
            - TCP는 처음에는 최대 속도를 낮게 제한하다가 데이터가 성공적으로 전송되면 속도 제한을 높인다. (실패하는 패킷을 전송하면 네트워크 낭비이기 때문)
            - 이를 위해 기존 이용하던 커넥션을 이용하면 slow start되어 요청/응답이 느리게 이루어지는 것을 회피할 수 있음.
        4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY
            - TCP 세그먼트는 40바이트 정도의 플래그와 헤더를 포함하기 때문에 작은 패킷 여러개 보다는 큰 패킷 하나로 묶을 수 있다면 트래픽을 절약할 수 있다.
            - 이를 합치는 알고리즘이 네이글 알고리즘이다.
            - 앞서 확인응답 지연과 마찬가지로 HTTP에는 별로 어울리지 않는다. 특히 이 두가지가 동시에 일어나면 정말 느려질 수 있다.
        4.2.7 TIME_WAIT의 누적과 포트 고갈(p.97)
            - TCP는 한 커넥션이 끊어져도 IP 주소와 포트 번호를 메모리에 기록해둔다. (동일한 커넥션이 중복으로 생성되는 것을 방지한다.)
            - 이는 대략 2분 정도 유지된다. 이 값을 수정하는 것은 조심해야되는데, 너무 짧으면 이전 커넥션의 패킷이 다음 커넥션에 삽입되어 TCP 데이터 충돌이 발생할 수 있다.
            - 일반적으로 2분 정도 유지되는 커넥션 종료 지연은 문제가 없으나, 성능 테스트를 하는 상황에서는 문제가 발생할 수 있음.
            - 커넥션이 빈번하게 맺고 끊어지면서 모든 port가 TIME_WAIT 상태로 대기하게될 수 있다.
    4.3 HTTP 커넥션 관리(p.98)
        4.3.1 흔히 잘못 이해하는 Connection 헤더(p.99)
            - 클라이언트와 서버 사이에 프록시 서버나 캐시 서버처럼 중개 서버가 놓일 수 있는데, 이때 Connection 헤더에 포함된 값을 통해 중개 서버 이후에도 전송할지를 결정할 수 있다.
        4.3.2 순차적인 트랜잭션 처리에 의한 지연(p.101)
            - 이미지가 3개 포함된 웹 페이지의 경우 각각을 순차적으로 처리할 경우 총 4번의 HTTP 트랜잭션이 발생하는 만큼의 지연시간이 발생한다.
            - 이를 극복하기 위해 다음과 같은 커넥션 방식들이 나온다.
                - 병렬 커넥션, 지속 커넥션, 파이프라인 커넥션, 다중 커넥션
    4.4 병렬 커넥션(p.101)
        - HTTP 클라이언트는 여러 개의 커넥션을 맺음으로써 여러개의 HTTP 트랜잭션을 병렬로 처리할 수 있다.
        4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다.(p.102)
        4.4.2 병렬 커넥션이 항상 더 빠르지는 않다.(p.102)
            - 네트워크 대역폭이 너무 적다면 성능상 장점이 사라짐.
            - 브라우저는 실제로 병렬 커넥션을 사용함(대부분 4개) -> 개발자 도구로 확인해보자.
        4.4.3 병렬 커넥션은 더 빠르게 '느껴질 수' 있다.(p.103)
            - 실제 순차적으로 받는것과 전체 시간이 동일하다고 하더라도, 여러 컨텐츠가 로딩되고 있는게 보이기 때문에 사용자는 더 빠르다고 느낄 수 있다.
    4.5 지속 커넥션(p.104)
        - HTTP/1.1을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지한다.
        4.5.1 지속 커넥션 vs 병렬 커넥션(p.104)
            - 지속 커넥션은 병렬 커넥션에 비해 몇 가지 장점이 있음. 하지만 잘못 관리할 경우 계속 연결될 상태로 커넥션이 쌓일 수 있다.
            - HTTP/1.0+에는 keep-alive 커넥션이 있고, 1.1에는 지속 커넥션이 있다.
        4.5.2 HTTP/1.0+의 Keep-Alive 커넥션
            - 1.1에서 개선되기 전의 지속 커넥션이다.
            - [그림 4-13]을 보면 커넥션을 맺는 시간을 줄여서 네트워크 시간을 줄일 수 있다.
        4.5.3 Keep-Alive 동작(p.106)
            - 클라이언트가 Connection:Keep-Alive를 헤더에 보내고 응답 해더에도 오면 클라이언트와 서버가 서로 지속 커넥션을 사용한다.
        4.5.4 Keep-Alive 옵션(p.106)
            - 해당 헤더는 커넥션을 유지하기를 바라는 요청일 뿐 꼭 따를 필요는 없다.
            - Keep-Alive 헤더를 추가하여 최대 Keep-Alive 커넥션의 수를 제한하거나 타임아웃을 설정할 수 있다.
        4.5.5 Keep-Alive 커넥션 제한과 규칙(p.107)
            - Keep-Alive 커넥션과 관련된 몇 가지 제한과 사용 방법이 나와있음. 중요한 내용은 뒤에서 다시 나옴.
        4.5.6 Keep-Alive와 멍청한(dumb) 프락시(p.108)
            - 프록시가 Connection 헤더를 이해하지 못하는 경우 이를 무조건 다음 홉으로 전송한다.
            - 하지만 원래 Connection 헤더는 홉 바이 홉 이라서 다음으로 전송되면 안된다.
            - Connection: Keep-Alive를 전송받은 서버가 프록시와 연결을 유지한다. 그리고 응답에도 해당 헤더를 포함한다.
            - 이는 다시 클라이언트에게도 전송된다. 클라이언트도 해당 커넥션이 유지되기를 기대한다.
            - 프록시는 클라이언트에게 데이터를 전송했기 때문에 서버가 커넥션을 끊기를 기다린다.
            - 하지만 서버는 Keep-Alive 상태이기 때문에 커넥션을 끊지 않고, 프록시에서 끊기까지 기다린다.
            - 이상태에서 클라이언트가 다음 요청을 기존과 같은 커넥션으로 요청한다.
            - 하지만 프록시는 같은 커넥션에서 다른 요청이 올거라고 기대하지 않아서 해당 요청을 무시한다.
            - 클라이언트는 응답을 받지 못하고, 서버도 요청을 받지 못하는 상태가 된다.
            - 이를 회피하려면 프록시는 Connection 헤더나 Keep-Alive 헤더를 전달하지 않도록 해야한다.(프록시 관리하는 사람이 할일)
        4.5.7 Proxy-Connection 살펴보기(p.110)
            - Connection 헤더 대신 Proxy-Connection 헤더를 사용하면 서버측에서 무시되기 때문에 프록시가 멍청해도 문제가 발생하지 않는다.
            - 하지만 해당 헤더를 이해하는 프록시라면 Proxy-Connection 헤더를 Connection 헤더로 바꿔서 원래 원하던 지속 커넥션을 달성할 수 있다.
            - [그림 4-16]이 잘 설명하고 있다.
            - 하지만 프록시가 여러개면 이 역시 문제가 있다.
            - 혹은 프록시 뿐만 아니라 네트워크 상에 있는 웹 애플리케이션들은 클라이언트와 서버 입장에서는 보이지 않는 경우가 많기 때문에 중간에 있는 웹 애플리케이션들이 지속 커넥션을 명확히 구현하는 것이 중요하다.
        4.5.8 HTTP/1.1의 지속 커넥션(p.112)
            - HTTP/1.1은 keep-alive 커넥션 대신 개선된 지속 커넥션을 지원한다.
            - 별도 설정하지 않는 한 모든 커넥션을 지속 커넥션으로 취급한다.
            - 트랜잭션이 끝난 다음 커넥션을 끊으려면 Connection: close 헤더를 명시해야 한다.
        4.5.9 지속 커넥션의 제한과 규칙(p.113)
            - Keep-Alive와 마찬가지로 몇가지 제한과 규칙이 있음.
    4.6 파이프라인 커넥션(p.114)
        - 지속 커넥션보다 더 대기 시간을 줄여준다.
        - 여기에도 몇가지 제약이 나온다. 사실 앞서 다른 제약들과 마찬가지로 End-Point 웹 애플리케이션 개발자한테는 크게 의미 없는 내용인 것 같다.
        - 다만 이런 내용은 눈여겨 볼만할 것 같음. 'HTTP 클라이언트는 POST 요청과 같이 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해 보내면 안 된다.
            에러가 발생하면 파이프라인을 통한 요청 중에 어떤 것들이 서버에서 처리되었는지 클라이언트가 알 방법이 없다.'
            -> POST 같이 비멱등 요청을 재차 보내면 발생할 수 있는 문제를 이야기하는 것 같다.
        - 웹 브라우저에서 이를 파이프라인 커넥션을 이용할지 말지를 선택할 때 메소드에 영향을 받는 것 같다.
        - 때문에 효율적으로 HTTP를 사용하려면 적절한 메소드를 사용하는게 좋을 것 같다.
        - MDN에 따르면 대부분의 모던 브라우저는 이를 사용하지 않는다고 한다.
    4.7 커넥션 끊기에 대한 미스터리(p.115)
        - 언제 커넥션을 끊는가 같은 커넥션 관리에 대한 명확한 기준은 없다.
        4.7.1 '마음대로' 커넥션 끊기(p.115)
            - 커넥션은 어떠한 상황에서도 끊을 수 있다. 헤더의 중간이나 다른 엉뚱한 곳에서도.
            - 하지만 한쪽이 임의로 커넥션을 끊을 경우 반대쪽은 이를 알지 못해 문제가 발생할 수 있다.
        4.7.2 Contont-Length와 Truncation(p.116)
            - 커넥션이 끊어졌다는 응답을 받은 후 실제 엔티티 길이와 Content-Length의 값이 일치하지 않으면 데이터의 정확한 길이를 서버에 물어봐야한다.
        4.7.3 커넥션 끊기의 허용, 재시도, 멱등성(p.116)
            - HTTP 애플리케이션은 예상치 못하게 커넥션이 끊어졌을 때에 적절하게 대응할 수 있는 준비가 되어있어야 한다.
            - 멱등성이 있는 메소드와 그렇지 않은 메소드를 구분하여 사용해야한다.
            - 때문에 대부분의 부라우저는 캐시된 POST 요청 페이지를 다시 로드하려고 할 때, 요청을 다시 보내기를 원하는지 묻는 대화상자를 보여준다.
        4.7.4 우아한 커넥션 끊기(p.117)
            - TCP 커넥션은 양방향이다.
            - 연결 중 한쪽만 끊을 수도 있고, 양쪽다 끊을 수도 있다.
            - 일반적으로 우아한 커넥션 끊기는 애플리케이션이 자신의 출력 채널을 먼저 끊고, 다른쪽에 있는 기기의 출력 채널이 끊기기를 기다리는 것이다.
