## 17장 내용 협상과 트랜스코딩(p.457)
- 종종 하나의 URL이 여러 리소스에 대응되어야 할 필요가 있는 경우가 있다.
- 예를들어 한 웹사이트의 문서를 여러 언어로 다국어 지원해야 하는경우에 그럴 필요가 있다.
- 이러한 서로 다른 버전을 배리언트(variant)라고 한다.
- 클라이언트와 서버 사이에서 동일 URL에 대해 어떤 컨텐츠를 보내줄 결정하는 과정을 내용 협상(content-negotiation)
- 이 장애서는 웹 애플리케이션이 어떻게 내용 협상을 하는지에 대해 알아본다.

### 17.1 내용 협상 기법(p.458)
- 내용 협상 기법에는 3가지가 존재한다.
    - 클라이언트 주도 : 요청 -> 선택지 응답 -> 재요청 -> 응답 으로 2번의 HTTP 트랜잭션이 필요하다.
    - 서버 주도 : 서버가 클라이언트의 요청 헤더를 보고 적절한 응답을 골라서 응답한다.
    - 투명 : 프록시 캐시 같은 중간 장치가 대신 협상을 한다.
- 가각에 대해선 뒤에서 다시 하나씩 다루게 된다.

### 17.2 클라이언트 주도 협상(p.458)
- 서버입장에서 가장 쉽다. 선택지를 주고 클라이언트가 선택하도록 하면되니까.
- 단점은 HTTP 트랜잭션이 2번 필요하다는 점이다.
- 클라이언트에게 주는 선택지의 표현 방법은 두 가지 방법이 있다.
    - 여러 가지 버전에 대한 링크와 각각에 대한 설명이 담긴 HTML 페이지를 돌려준다.
    - 300 Multiple Choices 응답 코드로 HTTP/1.1 응답을 돌려주는 것이다.
- 위의 선택지가 주어지면 클라이언트의 사용자에 의해 수동으로 링크가 선택된다.
- 이것은 대기시간 증가와 페이지당 여러 번의 요청이 필요하다는 문제 뿐만 아니라, 각 선택지별로 별도의 페이지와 URL이 필요하다는 문제가 있다.

### 17.3 서버 주도 협상(p.459)
- 서버 주도 협상은 Accept 관련 헤더나 클라이언트의 User-Agent 헤더에 기반하여 응답을 보내줄 수 있다.

#### 17.3.1 내용 협상 헤더(p.460)
- 내용 협상 관련 헤더들
    - Accept : 어떤 미디어 타입?(MIME) -> Content-Type
    - Accept-Language : 어떤 언어?  -> Content-Language
    - Accept-Charset : 어떤 차셋?   -> Content-Type
    - Accept-Encoding: 어떤 인코딩? -> Content-Encoding
- HTTP는 state-less 이기 때문에 이전 요청에 대한 정보를 기록하지 않는다. 때문에 클라이언트는 자신이 선호하는 내용이 무엇인지를 매 요청 헤더에 포함해야한다.
- 위 타입들 중 클라이언트는 본인이 선호하는 것의 우선순위를 q(quality value)를 통해 알려줄 수 있다. q 값이 높은 것 부터 우선순위에 따라 응답해준다.

#### 17.3.2 내용 협상 헤더의 품질값(p.461)
- 다음과 같은식으로 품질값이 표기된다.
```
Accept-Language: en;q=0.5, fr;0.5, nl;q=1.0, tr:q=0.0
```

#### 17.3.3 그 외의 헤더들에 의해 결정(p.461)
- 서버는 User-Agent와 같은 클라이언트의 요청 헤더에 따라 알맞응 응답을 만들어내려고 시도할 수 있다. (책에서 요청이라고 오타낸듯)
- 예를들어 오래된 버전의 브라우저에게 요청이 온다면 그에 적합한 페이지를 줄 수도 있다.
- User-Agent에는 q 값은 없다.
- Vary 헤더에 대한 부분은 이 장 뒷부분에서 다시 다룬다.

#### 17.3.4 아파치의 내용 협상(p.462)
- type-map과 MultiViews를 통해서 어떤 요청 헤더와 배리언트가 매핑되어야할지 정해줄 수 있다고한다.

#### 17.3.5 서버 측 확장(p.463)
- p.236의 8.3.2 서버 확장 API를 참고해서 CGI를 구현하라는 것 같다.

### 17.4 투명 협상(p.463)
- 투명 협상은 클라이언트 입장에서 협상하는 중개자 프록시를 둠으로써 클라이언트와의 메시지 교환을 최소화하는 동시에 서버 주도 협상으로 인한 부하를 서버에서 제거한다.
- HTTP/1.1 명세에서는 Vary 헤더를 통해 중개자에게 어떤 헤더가 내용 협상에 사용되고 있는지 알려줄 수 있다.
- 만약 서버가 캐시에 대한 의사결정 프로세스를 캐시(여기서는 중개자)에게 알려주었다면 캐시는 서버의 입장에서 클라이언트와 협상할 수 있다. 또한 캐시는 콘텐츠를 트랜스코딩하기 훌륭한 장소인데, 캐시 안에 설치되어 있는 범용 트랜스코더는 특정 서버에 국한되지 않고 어떤 서버의 콘텐츠든 트랜스코딩 할 수 있기 떄문이라고 한다.
- 이 내용도 자세히는 뒤에가서 다시 알려준다고 한다. -_- [그림 17-3]

#### 17.4.1 캐시와 얼터네이트(alternate)(p.464)
- 콘텐츠를 캐시하는 것은 그 콘텐츠가 나중에 재사용될 것이라고 예상하기 때문이다.
- **캐시는 클라이언트에게 올바로 캐시된 응답을 돌려주기 위해, 서버가 응답을 돌려줄 때 사용했던 의사결정 로직의 상당 부분을 그대로 사용해야 한다.**
- 위 문장이 핵심으로, [그림 17-1]에 위 과정을 도식화하여 과정을 보여주고 있다.

#### 17.4.2 Vary 헤더(p.465)
- p.465에 나온 요청/응답 헤더는 전형적인 요청과 응답 헤더를 보여준다.
- 만약 이 요청/응답이 Accept 헤더가 아닌 다른 헤더에 의해 일어난 결과라면 어떨까?
- 그런 경우 응답의 Vary 헤더에 어떤 요소가 내용 협상에 사용되었는지 vary에 포함되어야한다.
- 위 내용이 어려운데 **캐시의 입장에서 Accept들은 자동으로 캐시에 고려되는 요소가 되는 것이고, 그 외의 헤더가 응답의 내용협상에 사용되었다면 그 헤더들의 이름이 Vary 헤더에 포함되어 온다는 의미**이다. 
- [그림 17-2]에 그 과정이 잘 나와있다. 위쪽에서 Vary에 User-agent 값이 들어있었고, 아래쪽에서 다른 사용자는 위쪽 사용자와는 다른 User-agent로 접근하였다. 때문에 아래 응답은 위쪽에서 캐시된 응답이 보내지는 것이 아니다.

### 17.5 트랜스코딩(p.467)
- 서버가 클라이언트의 요구에 맞는 문서를 아예 가지고 있지 않다면 어떻게 되는가? -> 서버는 에러로 응답해야겠지만, 이론적으로 서버는 기존의 문서를 클라이언트가 사용할 수 있는 무언가로 변환할 수도 있다. 이 옵션을 트랜스코딩이라고 한다.
- [표 17-4]에 나와있는 예시들을 보는게 이해에 도움이 될듯.

#### 17.5.1 포맷 변환(p.468)
- 포맷 변환은 데이터를 클라이언트가 볼 수 있도록 한 포맷에서 다른 포맷으로 변환하는 것이다. (파일 포맷의 게이트웨이 같은 느낌?)
- 트랜스코딩은 콘텐츠 인코딩이나 전송 인코딩과는 다르다.
    - 트랜스코딩 -> 콘텐츠를 특정 접근 장치에서 볼 수 있도록 하기 위함.
    - 콘텐츠 인코딩 or 전송 인코딩 -> 더 효율적인 전송이나 안전한 전송을 위해.

#### 17.5.2 정보 합성(p.468)
- 문서에서 정보의 요점을 추춘하는 것을 정보 합성이라고 한다.
- 페이지에서 광고 및 로고 제거를 들 수 있다.
- 검색 엔진 같은 곳에서도 사용할 듯.

#### 17.5.3 콘텐츠 주입(p.469)
- 지금까지 서술한 두 종류의 트랜스 코딩은 일반적으로 웹 문서의 양을 줄이지만, 오히려 양을 늘리는 내용 주입 트랜스코딩(content-injection transcoding) 이라는 것도 있다.
- 지나가는 모든 HTML 페이지에 자동으로 광고를 삽입하거나 통계를 위해 동적으로 페이지에 컨텐츠를 추가할 수 있다.

#### 17.5.4 트랜스코딩 vs. 정적으로 미리 생성해놓기(p.469)
- 트랜스코딩의 대안은 웹 서버에서 웹 페이지의 여러 가지 사본을 만드는 것이다.
- 하지만 이것은 현실적으로 어렵다. 또한 몇몇 트랜스 코딩은 정적인 방법으로는 수행 될 수 없다.(어떤 광고가 삽입될 것인지 등)
- [그림 17-3]은 프록시 캐시에서의 트랜스 인코딩 과정을 보여주고 있다.

### 17.6 다음 단계(p.470)
- 내용 협상에 대한 이야기는 다음 2가지 이유로 Accept나 Content 관련 해더들에서 끝나지 않는다.
    - HTTP의 내용 협상은 성능 제약을 초래한다.
    - HTTP는 내용 협상이 필요한 유일한 프로토콜이 아니다.

## 18장 웹 호스팅(p.475)
- 리소스를 공용 웹 서버에 올려놓으면 인터넷을 통해 이용할 수 있음.
- 콘텐츠 리소스를 저장, 중개, 관리하는 일을 통틀어 웹 호스팅이라 한다.
- 필요한 하드웨어와 소프트웨어를 직접 관리하기 어렵다면, 호스팅 서비스나 호스팅 업체가 필요할 것이다.
- 호스팅 업체는 서버와 웹 사이트 관리 프로그램을 대여해주고 다양한 등급의 보안, 리포트, 사용 편의를 제공한다.

### 18.1 호스팅 서비스(p.476)
- 월드 와이드 웹 초기에는 각 회사가 온프레미스로 환경을 구축하여 관리했다.
- 하지만 이런 환경을 가지는건 어려웠고, 그래서 웹 호스팅 관련 업체들이 생겨났음.

#### 18.1.1 간단한 예: 전용 호스팅(p.476)
- 물리적 장비를 통째로 호스팅 해주는 것.

### 18.2 가상 호스팅(p.477)
- 많은 사람이 트래픽이 높은 사이트는 아니더라도 웹 공간을 가지고 싶어함.
- 이런 사람들에게 웹 공간은 대부분의 시간 동안에는 놀고 있을 것이기 때문에, 이들에게 전용 웹서버는 낭비다.
- 가상 호스팅은 서버위에 여러개의 가상 서버를 올려서 마치 여러 개의 서버가 있는 것처럼 호스팅 하는 것이다.

#### 18.2.1 호스트 정보가 없는 가상 서버 요청(p.478)
- HTTP/1.0에는 가상 호스팅 업자가 골머리를 앓을 만한 설계 결함이 있다. 가상 웹 사이트에 누가 접근하고 있는지 식별하는 기능을 제공하지 않는 것이다.
- Host 헤더가 없다는 것인데, 이것은 사용자가 /index.html 같은 페이지로 접근하는 것 같은 경우 문제가 된다. 이것이 어느 가상 호스트로 연결되어야 할지 알지 못하기 떄문이다.

#### 18.2.2 가상 호스팅 동작하게 하기(p.479)
- HTTP 명세에 호스팅 정보가 없었던 것은 각 웹 서버가 정확히 하나의 웹 사이트만 호스팅 할거라고 잘못 예측한 것이다.
- 이를 해결하기 위한 간단한 방법은 모든 링크에 완전한 URL을 넣도록 하는 것이었다.
- HTTP/1.1에선 Host 헤더가 필수가 되었지만, 그 와중에 가상 호스팅을 지원하기 위한 4가지 방법이 고안되었다.
    - URL 경로를 통한 가상 호스팅 -> 전체 URL을 넣는것
    - 포트번호를 통한 가상 호스팅
    - IP 주소를 통한 가상 호스팅 -> 지금도 많이 사용된다.
    - Host 헤더를 통한 가상 호스팅 -> HTTP/1.0+ 에서 처음 소개되었음.

#### 18.2.3 HTTP/1.1 Host 헤더(p.484)
- RFC 2068에 정의되어있는 HTTP/1.1 요청 헤더이다.
- Host 헤더에는 원본 URL에 있는 요청 리소스에 대한 인터넷 호스트와 포트 번호를 기술한다.
- 몇 가지 규칙들
    - Host 헤더에 포트가 기술되어 있지 않다면 해당 스킴의 기본 포트를 사용해야한다.
    - URL에 IP 주소가 있으면, Host 헤더는 같은 주소를 포함해야 한다. 그 반대의 경우도 마찬가지다.
    - 만약 URL에 호스트 명이 기술되어 있으면, Host 헤더는 IP 주소를 포함해서는 안된다. 그 이유는, 여러 개의 가상 사이트를 한개의 IP에 연결한 경우 어디로 호스팅 해야할지 찾을 수 없다.
    - 클라이언트가 특정 프록시 서버를 사용한다면, Host 헤더에는 프록시 서버가 아니라 원 서버의 호스트 명과 포트를 기술해야한다.
    - 웹 프록시는 요청을 전달하기 전에 요청 메시지에 Host 헤더를 추가해야 한다.
    - HTTP/1.1 웹 서버는 Host 헤더 필드가 없는 HTTP/1.1 요청 메시지를 받으면 400 상태 코드로 응답해야 한다.

### 18.3 안정적인 웹 사이트 만들기(p.486)
- 웹 사이트에 장애가 생기는 상황이 몇 가지 있다.
    - 서버 다운
    - 트래픽 폭증
    - 네트워크 장애나 손실

#### 18.3.1 미러링 된 서버 팜(p.486)
- 서버 팜은 서로 대신할 수 있고 식별할 수 있게 설정된 웹 서버들의 집합이다.
- 복제 원 서버와 마스터 원 서버는 계속 동기화 된다.
- HTTP 리다이렉션 : 마스터 서버로 오면 그 요청을 복제 서버로 리다이렉트 시킨다.
- DNS 리다이렉션 : 1개의 DNS URL이 4개의 IP에 대응된다. DNS 서버가 클라이언트에게 전송할 IP 주소를 선택한다.

#### 18.3.2 콘텐츠 분산 네트워크(p.487)
- 줄여서 CDN이라고 많이 부름.
- 특정 콘텐츠의 분산을 목적으로 하는 단순한 네트워크이다.
- CDN은 서버, 대리 서버, 혹은 프록시 서버 등이 될 수 있다.

#### 18.3.3 CDN의 대리 캐시(p.488)
- 대리 캐시는 [그림 18-6, 7]에 있는 복제 원 서버를 대신할 수 있다.
- 리버스 프록시 라고도 대리 서버는 미러링 된 웹 서버처럼 콘텐츠에 대한 요청을 받는다.
- 미러링된 서버와의 차이점은 대리 서버는 수요에 따라 동작하고, 원 서버의 전체 콘텐츠를 복사하지는 않는다. -> 말 그대로 캐시처럼 요청이 한번 들어온걸 가지고 있다.
- 물론 고도화되어 사용자가 요청하기도 전에 콘텐츠를 가져오는 '미리 가져오기' 기능을 가진 대리 서버도 있다.

#### 18.3.4 CDN의 프록시 캐시
- 프록시 캐시는 대리 서버와는 다르게, 어떤 웹 서버 요청이든 다 받을수 있다.
- 하지만 대리 서버를 사용하면 프록시 캐시의 콘텐츠는 요청이 있을 때만 저장될 것이고, 원본 서버의 콘텐츠를 정확히 복제한다는 보장이 없다.
- [그림 18-8] 처럼 원 서버로 가려는 트래픽을 스위치에서 가로체어 프록시 캐시가 처리하기도 한다.
- 가로채기 설정은 20장에서 다시 다룬다고 한다.

### 18.4 웹 사이트 빠르게 만들기(p.489)
- 앞서 나온 내용들을 사용하면 부하를 분산하고, 콘텐츠를 사용자에게 더 가깝게 만들어 주므로 서버 <-> 클라이언트 전송 시간이 단축된다.
- 리소스의 로딩 속도를 좌우하는 핵심 요소는 어떻게 요청과 응답이 클라이언트와 서버 사이에서 연결을 맺고 인터넷을 가로질러 데이터를 전송하는지다. (우리나라 내에선 별로 동의가 안된다.)
- 웹 사이트 속도를 높이는 또 다른 접근 방법은 콘텐츠를 인코딩하는 것이다.

