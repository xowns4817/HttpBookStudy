### 17장 내용 협상과 트랜스코딩
 - HTTP는 클라이언트와 서버가 하나의 URL로 여러가지 리소스 중 적합한 것이 대응 되도록 할 수 있게 내용 협상방법을 제공한다. (  ex. 같은 웹페이지의 프랑스어와 영어 버전 - 서로 다른 버전을 배리언트라고 부른다.)
#### 17.1 내용 협상 기법
 - 서버에 있는 페이지들 중 어떤 것이 클라이언트에게 맞는지 판단하는 세 가지 다른 방법이 있다.
 - 1. 클라이언트 주도 협상 ( 클라이언트에게 선택지를 준다.)
 - 2. 서버 주도 협상 ( 서버가 주도적으로 판단 )
 - 3. 투명 협상 ( 중개자에게 선택하도록 부탁 )

#### 17.2 클라이언트 주도 협상
 - 동작 방식 : 클라이언트가 요청을 보내면, 서버는 클라이언트에게 선택지를 주고, 클라이언트가 선택한다.
 - 장점 : 서버 입장에서는 가장 구현하기 쉽고, 클라이언트는 최선의 선택을 할 수 있다.
 - 단점 : 대기 시간이 증가한다. 최소 2번의 요청이 필요하다. 
#### 17.3 서버 주도 협상
  -  동작 방식 : 서버가 클라이언트의 요청 헤더를 검증해서 어떤 버전을 제공할지 결정한다.
  -  장점 : 클라이언트 주도 협상보다 빠르다.
  -  단점 : 만약, 헤더에 맞는 것이 없으면 서버는 추측을 해야한다.
  - HTTP 서버가 클라이언트에게 보내줄 적절한 응답을 계산하기 위해 사용하는 메커니즘은 두 가지이다.
    - 내용 협상 헤더들을 살펴본다. -> Accept 관련 헤더들을 확인해 그에 맞는 응답을 준다.
    - 내용 협상 헤더 외의 다른 헤더들을 살펴본다. -> User-Agent 헤더에 기반한 응답을 보내줄 수도 있다.
##### 17.3.1 내용 협상 헤더
 - 아래 나열된 HTTP 헤더들을 이용해 자신의 선호 정보를 보낼 수 있다.
  
|헤더|설명|
|------|---|
|Accept|서버가 어떤 미디어 타입을 보내도 되는지 알려준다.|
|Accept-Language|서버가 어떤 언어로 보내도 되는지 알려준다.|
|Accept-Charset|서버가 어떤 차셋으로 보내도 되는지 알려준다.|
|Accept-Encoding|서버가 어떤 인코딩을 보내도 되는지 알려준다.|

- 15장에서 학습했던 엔터티 헤더들과 비슷하지만, 목적이 다르다. 엔터티 헤더의 경우는 메시지 본문의 속성을 가리킨다면, 협상 헤더들은 클라이언트의 선호에 가장 잘 맞는 문서를 제공해주기 위한 목적이다.

- 클라이언트가 선호하는 ( = Accept 해더에 추가한 ) 타입을 서버가 지원하지 않는다면 ??
  - 1. 서버가 알아서 추측하던지..
  - 2. 클라이언트에게 다시 물어보던지.. ( 클라이언트 주도 방식)

- 위 2가지 방법도 있겠지만, HTTP는 클라이언트의 선호에 대한 풍부한 설명을 품질값(q값)을 이용해 전달 할 수 있는 메커니즘을 제공한다.

##### 17.3.2 내용 협상 헤더의 품질값
 - HTTP 프로토콜은 클라이언트가 각 선호의 카테고리마다 여러 선택 가능한 항목을 선호도와 함께 나열할 수 있도록 품질값을 정의하였다.
 - q 값은 0.0  1.0 까지의 값을 갖을 수 있다. ( 0.0이 가장 낮은 선호도, 1.0이 가장 높은 선호도)
  ```
    Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0
  ```
  - 위 헤더를 해석하면 네덜란드어(nl)로 된 문서를 받기를 원하고 있으나, 없을 경우 영어(en)로 된 문서라도 받아들일 것이다. 그러나, 어떠한 경우에도 프랑스어(fr)이나 터키어(tr) 버전은 원하지 않는다.
- 때때로, 서버는 클라이언트의 선호에 대응하는 문서를 하나도 갖고 있지 않을 수 있다. 이 경우, 서버는 클라이언트의 선호에 맞추기 위해 문서를 고치거나 트렌스 코딩 할 수 있다.

##### 17.3.3 그외의 헤더들에 의해 결정
 - 서버는 또한 User-Agent와 같은 클라이언트의 다른 요청 헤더들을 이용해 알맞은 요청을 만들어내려고 시도할 수 있다.

#### 17.4 투명 협상
 - 투명한 중간 장치(프락시)가 서버를 대신하여 협상을 한다.
 - HTTP/1.1 명세는 투명 협상에 대한 어떤 메커니즘도 정의하지 않았지만, 대신 Vary 헤더를 정의했다.
 - 서버는 응답에 Vary 헤더를 포함시켜 보냄으로써 중개자에게 내용 협상을 위해 어떤 헤더를 사용하고 있는지 알려줄 수 있다.
 - 캐시 프락시는 단일한 URL을 통해 접근할 수 있는 문서의 여러 다른 사본을 저장할 수 있다.

##### 17.4.1 캐시와 얼터네이트(alternate)
 - 캐시가 같은 URL에 대해 두개의 다른 문서를 갖게 될 경우, 이 다른 버전은 베리언트나 얼터네이트라고 부른다. ( 그림 17-1 참고 ) -> 내용 협상은 배리언트 중에서 클라이언트의 요청에 가장 잘 맞는 것을 선택하는 과정으로 이해 할 수 있다.

##### 17.4.2 Vary 헤더
 - HTTP Vary 응답 헤더는 서버가 문서를 선택하거나 커스텀 콘텐츠를 생성할 때 고려한 클라이언트 요청 헤더 모두를 나열한다. 
 - 그림 17-2 다시보기

### 17.5 트랜스코딩
 - 서버가 클라이언트의 요구에 맞는 문서를 아예 갖고 있지 않다면 어떻게 될까? -> 서버는 에러로 응답을 해야겠지만, 이론적으로 서버는 기존의 문서를 클라이언트가 사용할 수 잇는 무언가로 변환할 수 도 있다. -> 트랜스코딩
 - p.468 17-4 참조
 - 트랜스코딩의 세 종류 (포맷 변환, 정보 합성, 내용 주입)

##### 17.5.1 포맷 변환
 - 포맷 변환은 데이터를 클라이언트가 볼 수 있도록 한 포멧에서 다른 포맷으로 변환하는 것이다. ( HTML -> WML, 고해상도 -> 저해상도..등등)
##### 17.5.2 정보 합성
 - 문서에서 정보의 요점을 추출하는 것을 정보 합성이라고 한다. ( 트랜스코딩 과정에서 유용할 수 있다. )
##### 17.5.3 콘텐츠 주입
 - 포맷 변환 및 정보합성의 경우 웹 문서의 양을 줄이지만 콘텐츠 주입의 경우는 오히려 양을 늘린다.( ex. 자동 광고 생성, 사용자 추적 시스템 등) 
##### 17.5.4 트랜스코딩 vs 정적으로 미리 생성해놓기
 - 트랜스코딩의 대안은 웹 서버에서 웹 페이지의 여러 가지 사본을 만드는 것이다. -> 매우 번거롭고 불가능한 경우도 있다. 
- 다시보기

### 18장 웹 호스팅
 - 콘텐츠 리소스를 저장, 중개, 관리하는 일을 통틀어 웹 호스팅이라고 한다.
 - 호스팅에 대한 정리 ( iass, pass, sass)
#### 18.1 호스팅 서비스
 - 옛날에.. -> 물리적은 자체 컴퓨터를 구매해 자체 네트워크 망을 구축
 - 최근.. -> 웹 호스팅 서비스를 이용 ( cafe24, aws, azure..등등 )
#### 18.1.1 간단한 예 : 전용 호스팅
 - 호스팅 예시를 보여준거 같음

### 18.2 가상 호스팅
 - 가상 호스팅이란, ? 정의
 - 각 웹 사이트는 다른 서버에서 호스팅하는 것처럼 보이겠지만, 사실은 물리적으로 같은 서버에서 호스팅되는 것이다.
 - 가상 호스팅은 비용, 공간, 관리에 이점이 있으므로, 가상 호스팅 업체는 한 서버에 보다 많은 웹 사이트를 호스팅하려고 한다.

##### 18.2.1 호스트 정보가 없는 가상 서버 요청
  - HTTP/1.0 명세는 공용 웹 서버가 호스팅하고 있는 가상 웹사이트에 누가 접근하고 있는지 식별하는 기능을 제공하지 않는다. ( HTTP/1.0 요청은 요청 메시지에 URL의 경로 컴포넌트만 전송한다. )
- ex) HTTP/1.0 요청에서 http://example.com/index.html 이라고 요청을 하면 "GET /index.html"이라는 요청을 한다.
- 서버가 여러개의 사이트를 가상 호스팅하고 있으면, 사용자가 어떤 가상 웹 사이트로 접근하려고 하는 것인지 정보가 충분하지 않다. ( p.497 그림 18-3 참고 - 웹 사이트 호스트 정보가 요청에서 제거 된다..)

##### 18.2.2 가상 호스팅 동작하게 하기
 - HTTP 설계자들은 공유 서버인 가상 호스팅을 고려하지 않았기 때문에 이런 문제가 발생했다. ( 요청에서 HOST명을 빼고 경로 컴포넌트만 전송..)
 - 위 문제를 해결하기 위해 4가지 기술이 나타났다.

##### 1. URL 경로를 통한 가상 호스팅
 - URL에 특별한 경로 컴포넌트를 추가한다. 구분은 되지만, 접두어는 불필요하고 혼란스럽다. -> 거의 안쓴다.
 - ex.) /joe/index.html, /mary/index.html
##### 2. 포트번호를 통한 가상 호스팅
 - 각 사이트에 다른 포트번호를 할당한다. 사용자는 URL에 비표준 표트를 쓰지 않고서도 리소스를 찾기를 원한다. ( HTTP-80, HTTPS-443 )
 - ex.  joe -> 80, mary -> 81..
##### 3. IP 주소를 통한 가상 호스팅
 - 각 가상 웹 사이트에 유일 IP 주소를 한 개 이상 부여한다. 모든 가상 서버의 IP 주소는 같은 공용 서버에 연결되어 있다.
 - p.482 그림 18-4 참고 설명
 - 가상 IP 호스팅은 잘 동작하지만, 규모가 큰 호스팅 업자에게는 IP 갯수 제한 및 희소성으로 문제가 있지만, 널리 쓰이는 방식이다.

##### 4. HOST 해더를 통한 가상 호스팅
 - 웹 서버는 Host 헤더로 가상 사이트를 식별할 수 있다. ( 모든 요청에 호스트명을 HOST 확장 헤더에 기술해서 전달한다. ) - P.483 그림 18-5 참고
 - HTTP/1.1 명세를 따르려면 Host 헤더를 반드시 기술해야 한다.

##### 18.2.3 HTTP/1.1 Host 헤더
 - Host 헤더는 RFC 2068에 정의되어 있는 HTTP/1.1 요청 헤더이다. 
##### 문법과 사용 방법
 - HOST 헤더에는 요청 리소스에 대한 인터넷 호스트와 포트번호를 기술한다.
```
  Host = "Host" : 호스트[ ":" 포트]
```
 - [Host 헤더 규칙]
 - HOST 헤더에 포트가 기술되어 있지 않으면, 해당 스킴의 기본 포트를 사용한다.
 - URL에 IP 주소가 있으면, Host 헤더는 같은 주소를 포함해야 한다.
 - URL에 호스트 명이 기술되어 있으면, HOST 헤더는 같은 호스트 명을 포함해야 한다.
 - 클라리언트가 특정 프락시 서버를 사용한다면, Host 헤더에 프락시 서버가 아닌 원 서버의 호스트 명과 포트를 기술해야 한다.
 - 웹 클라이언트는 모든 요청 메시지에 Host 헤더를 기술해야 한다.
 - HTTP/1.1 웹 서버는 Host 헤더필드가 없는 HTTP/1.1 요청을 받으면 400 Bad Request를 응답해야 한다.

##### Host 헤더의 누락
 -  낡은 브라우저들은 HOST헤더를 보내지 않는 경우도 있다. -> 가상 호스팅 서버가 어떤 리소스를 제공할지 결정할 수 없게 된다.

##### Host 헤더 해석하기
 - 가상 호스팅을 지원하지 않는 서버는 HOST 헤더 값을 무시할 것이다. ( 도메인 1개에 서버 1개로 매핑 되있음 )
 - 가상 호스팅을 지원하는 서버의 경우 호스트를 기준으로 리소스를 구분하기 때문에 HTTP/1.1을 통해 오는 리소스를 결정하려면 다음 규칙을 사용해야 한다.
   - 1. HTTP 요청 메시지에 전체 URL이 기술되어 있으면, Host 해더에 있는 값을 무시하고 URL을 사용한다.
   - 2. HTTP 요청 메시지에 있는 URL에 호스트 명이 기술되어 있지 않고 요청에 HOST 헤더가 있으면, HOST 헤더에서 호스트명과 포트를 가져온다.
   - 3. 1, 2단계에서 호스트를 결정할 수 없다면 400 Bad Request를 반환한다.

### 18.3. 안정적인 웹 사이트 만들기
 - 웹 사이트 장애 종류
   - 서버 다운
   - 트래픽 폭증
   - 네트워크 장애나 손실
   - 기타..등등

- 장애를 예측하고 대응하는 방법들

##### 18.3.1 미러링 된 서버 팜
 - 서버 팜은 서로 대신할 수 있고 식별할 수 있게 설정된 웹 서버들의 집합이다. 서버 팜의 서버에 있는 콘텐츠들은 한 곳에 문제가 생기면 다른 한 곳에서 대신 전달 할 수 있게 미러링 할 수 있다. ( 이중화 )
 - Master/Slave 구조 -> Master는 원본 서버로서 원본 콘텐츠를 가지고 있고 Slave는 Master로 부터 복제된 콘텐츠를 받게 된다.
 - Master가 다운될 경우 Slave가 Master로 승격되어 서버 다운 및 데이터 유실 없이 서비스를 운영할 수 있다. ( ex. Redis 센티널 )

##### 18.3.2 콘텐츠 분산 네트워크
 - 콘텐츠 분산 네트워크(CDN)는 특정 콘텐츠의 분산을 목적으로 하는 단순한 네트워크이다. 

##### 18.3.3 CDN의 대리 캐시

##### 18.3.4 CDN의 프락시 캐시

### 18.4 웹 사이트 빠르게 만들기
 - 서버 팜, 분산 프락시 캐시, 대리 서버는 혼잡을 조절하고 네트워크 트래픽을 분산시킨다.
 - 콘텐츠를 인코딩한다. ( ex. 압축 )








