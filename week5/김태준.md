## 10장
### HTTP/2.0

##### 10.1 HTTP/2.0의 등장 배경
 - HTTP/1.1의 메시지 포멧은 구현의 단순성과 접근성에 주안점을 두고 최적화되었다.
 - 요청을 보낸 커넥션을 통해 응답 1개를 받는 구조. -> 단순하지만, 응답을 받아야지 다음요청을 보낼 수 있으므로 지연이 발생한다. -> 병렬 커넥션, 파이프라인 커넥션 도입.

#### 10.2 개요
 - HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다.
 - HTTP/2.0 요청과 응답은 길이가 정의된 (최대 16383바이트) 한 개 이상의 프레임에 담긴다. HTTP 헤더는 압축되어서 전송된다.
 - 프레임들에 담긴 요청과 응답은 스트림을 통해 보내진다. ( 한 개의 스트림이 한 쌍의 요청과 응답을 처리한다. )
 - 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어 질 수 있으므로, 여러 요청과 응답을 동시에 처리 가능하다.
 - HTTP/2.0은 스트림에 대한 흐름제어와 우선순위 부여기능도 제공한다.
 - HTTP/2.0은 서버 푸시 지원. ( 폴링, 웹소켓, GRPC...등등)

#### 10.3 HTTP/1.1과의 차이점
##### 10.3.1 프레임
 - HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송된다.
 - 모든 프레임은 8바이트 크기의 헤더로 시작하며, 최대 16383바이트의 페이로드를 가진다.
 - 프레임 헤더의 각 필드는 다음과 같다.
   - R: 예약된 2비트 필드. 값의 의미가 있지 않으며, 반드시 0 이어야 한다. 받는 쪽에서는 이 값을 무시해야한다.
   - 길이 : 페이로드의 길이를 나타내는 14비트 무부호 정수. 이 길이에 프레임 헤더는 포함되지 않는다.
   - 종류 : 프레임의 종류
   - 플래그 : 8비트 플래그. 플래그 값의 의미는 프레임의 종류에 따라 다르다.
   - R : 예약된 1비트 필드. 첫벗째 R과 같음.
   - 스트림 식별자 : 31비트 스트림 식별자. 특별히 0은 커넥션 전체와 연관된 프레임을 의미한다.
##### 10.3.2 스트림과 멀티 플랙싱
 - 스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스이다.
 - 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진다.
 - HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다. 즉, 하나의 HTTP/2.0 커넥션을 통해 여러 개의 요청이 동시에 보내질 수 있다. ( HTTP/1.0의 경우 여러개의 요청을 보내려면 커넥션을 여러개 맺어야함. )
 - 서버와 클라이언트는 스트림을 상대방과 협상 없이 일방적으로 만든다. 이는 TCP 커넥션의 연결시간을 낭비하지 않을 수 있다.
 - HTTP/2.0 커넥션에서 한번 사용한 스트림 식별자는 다시 사용할 수 없다.
##### 10.3.3 헤더 압축
 - HTTP/1.1에서 헤더는 아무런 압축 없이 그대로 전송된다. 그러나, HTTP/2.0에서는 HTTP 메시지의 헤더를 압축하여 전송한다.
 - 헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤 헤더 블록 조각들로 쪼개져서 전송된다. 받는 쪽에서는 이 조각들을 이은 뒤 압축을 풀어 원래의 헤더 집합으로 복원한다.
#### 10.3.4 서버 푸시
 - HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해준다. ( HTML을 요청 -> html, css, js파일을 클라이언트로 전송. 요청 1개에 대해 3개의 응답 가능.)
 - 리소스를 푸시하려는 서버는 먼저, 클라이언트에게 자원을 푸시할 것임을 PUSH_PROMISE 프레임을 보내어 미리 알려주어야 한다.
 - 클라이언트가 PUSH_PROMISE 프레임을 받게 되면 해당 프레임의 스트림은 클라이언트 입장에서는 "예약됨" 상태가 된다. ( 이 상태에서 클라이언트는 RST_STREAM 프레임을 보내어 푸시를 거절할 수 있다. RST_STREAM을 보내게 되면 그 스트림은 즉시, 닫히게 된다. )
 - 서버 푸시를 사용할때 다음에 주의해야 한다.
   - 1. 클라이언트-서버 사이에 프락시가 있을경우 서버 푸시가 정상적으로 동작하지 않을 수 있다. 
   - 2. 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않는 요청에 대해서만 푸시를 할 수 있다.
   - 3. 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 한다. 서버가 보내는 PUSH_PROMISE 프레임은 원 요청을 위해 만들어진 스트림을 통해 보내진다.
- https://ijbgo.tistory.com/26
- 파이프 라인 커넥션과 HTTP/2.0의 Multiplexed HTTP의 차이
  - 파이프 라인 커넥션의 경우 ( HTTP 응답은 요청 순서와 같게 와야한다. 는 제약이 있다. 만약, 이 제약이 지켜지지 않는다면 HTTP 요청의 순번이 없기 때문에 어떤 요청에 대한 응답인지 구분을 할 수 없다. 이런 제약 때문에 1개의 요청 처리가 딜레이가 생긴다면 병목이 생길 수 있다. (따라서, 병렬 커넥션과 같이 사용한다.) 파이프라인 커넥션은 기본적으로 커넥션 1개로 처리된다.  그러나, HTTP/2.0의 Multiplexed HTTP 경우 1개의 커넥션에 여러개의 Stream이 존재할 수 있다. 각 Stream의 요청이 구분되기 때문에 파이프라인 커넥션의 단점을 해결할 수 있다.

- https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP