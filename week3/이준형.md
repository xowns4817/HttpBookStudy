## 5장 웹 서버 (p.125)

### 5.1 다채로운 웹 서버(p.125)
 - 웹 서버 : 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아서 컨텐츠를 클라이언트에게 돌려준다.

#### 5.1.1 웹 서버 구현(p.126)
 - 웹 서버는 HTTP 프로토콜을 구현하고, 웹 리소스를 관리하고, 웹 서버 관리 기능을 제공한다.

#### 5.1.2 다목적 소프트웨어 웹 서버(p.126)
 - 넷 크래프트의 조사 (https://news.netcraft.com/archives/2020/08/26/august-2020-web-server-survey.html)
    - 현재 1위부터 나열하면 다음과 같다. (괄호는 점유율)
        - nginx(36%)
        - Apache(26%)
        - Microsoft(10%)
        - Google(4%)
        - Other(24%)

#### 5.1.3 임베디드 웹 서버(p.127)
 - 범용 웹 서버가 아닌, 전자 제품에 내장될 목적으로 사용되는 웹 서버임.

### 5.2 간단한 펄 웹 서버(p.127)
 - perl 언어로 작성된 간단한 웹 서버를 보여주고 있다. (사람이 응답 메시지를 적어줘야한다 -_-)

### 5.3 진짜 웹 서버가 하는 일(p.130)
 - 4장까지 배웠던 내용들을 다시 적고있다. 1~7까지의 순서와 그림을 보며 확인해보자.
 - 어차피 뒤에서 해당 내용들이 하나씩 나온다.

### 5.4 단계 1: 클라이언트 커넥션 수락(p.131)
 - 해당 클라이언트와 서버 사이에 기존에 열려있던 지속 커넥션이 있다면 해당 커넥션을 사용하면 되지만 없다면 커넥션을 만들어줘야한다.

#### 5.4.1 새 커넥션 다루기(p.131)
 - 커넥션은 항상 클라이언트가 서버에 요청한다.
 - 커넥션이 만들어지면 서버는 커넥션을 다른 커넥션과 함께 목록으로 만들어 관리한다.
 - 웹 서버는 어떤 커넥션이든 마음대로 거절하거나 즉시 닫을 수 있다. (인가되지 않거나 악의적인 경우 커넥션을 닫는다.)

#### 5.4.2 클라이언트 호스트 명 식별(p.132)
 - 특정 웹 서버의 경우 reverse DNS를 통해 클라이언트의 IP 주소를 호스트 명으로 변환하도록 설정되어있다.
 - 이 경우 호스트명을 찾는데 시간이 걸려 응답 시간이 늦어질 수 있다.
 - 때문에 해당 설정을 비활성화하는게 좋다. (클라이언트의 호스트명을 꼭 알아야하는게 아니라면)
 - nginx의 rDNS(reverse DNS) 설정 : https://www.nginx.com/resources/wiki/modules/rdns/

#### 5.4.3 ident를 통해 클라이언트 사용자 알아내기(p.132)
 - 클라이언트측 113번 포트를 통해 ident 프로토콜을 listen한다.
 - 다음과 같은 과정을 거친다.
    - 클라이언트가 새로운 HTTP 커넥션을 맺는다.
    - 서버가 클라이언트와 ident 커넥션을 맺는다.
    - 서버가 클라이언트에게 정보를 클라이언트의 정보를 묻는다.
    - 클라이언트가 본인 정보를 답한다.
 - 잘 사용 안함

### 5.5 단계 2: 요청 메시지 수신(p.133)
 - 커넥션을 통해 요청 메시지가 오면 웹 서버를 해당 데이터를 파싱해서 요청 메시지를 구성함.
 - 요청 메시지 형태는 기존에 학습했던 대로임.
 - 웹 서버는 데이터를 네트워크로부터 불규칙적으로 받는다. 네트워크 커넥션은 언제라도 무효화될 수 있고, 웹 서버는 파싱해서 이해할 수 있을 때까지 데이터를 메모리에 임시로 저장할 수도 있음.

#### 5.5.1 메시지의 내부 표현(p.134)
 - 몇몇 웹서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장함.
 - 또한 룩업 테이블을 이용해 각 헤더 값에 빠르게 접근 가능하다.(key-value로 해시테이블 처럼 동작하는듯.)

#### 5.5.2 커넥션 입력/출력 처리 아키텍처(p.135)
 - 고성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원
 - 어떤 커넥션은 요청이 빠르게, 어떤 커넥션은 느리고 천천히 그리고 드물게 들어올 수도 있다.
 - 이 때문에 웹 서버는 항상 새 요청을 주시하고 있고, 웹 서버 아키텍처의 차이에 따라 요청을 처리하는 방식도 달라진다.
 - 다음은 아키텍처별 설명이다.
    - 단일 스레드 웹 서버
        - 한번에 하나의 요청만 처리한다. 앞서 type-o-serve 처럼 테스트용 서버에만 적합함.
    - 멀티프로세스와 멀티스레드 웹 서버
        - 여러 요청을 처리하기 위해 여러개의 프로세스 or 스레드를 할당한다.
        - 프로세스/스레드는 요청에 의해 만들수도 있고, 스레드풀 형태로 미리 만들어질 수도 있음.
        - 모든 커넥션마다 프로세스/스레드를 하나씩 만드는 수도 있으나, 시스템의 오버헤드가 커지기 때문에 최대 커넥션 수를 제한한다.
    - 다중 I/O 서버
        - 이벤트 드리븐 방식으로 처리하는 것 같다.
        - 프로세스와 스레드가 요청을 기다리는게 아니라, 커넥션에 처리할게 생기면 프로세스와 스레드가 할당 받아서 처리하는 방식이다.
    - 다중 멀티스레드 웹 서버
        - 멀티스레드 + 다중 I/O를 합친 방식임.

### 5.6 단계 3: 요청 처리(p.137)
 - 웹 서버가 요청을 받아서 처리하는 과정이다.

### 5.7 단계 4: 리소스의 매핑과 접근(p.137)
 - 요청 메시지의 URI에 대응하는 알맞은 콘텐츠나 콘텐츠 생성기를 웹 서버에서 찾아서 그 콘텐츠에 매핑하는 과정이다.

#### 5.7.1 Docroot(p.137)
 - 단순히 파일 형태로 리소스를 매핑하는 것을 말한다. 리눅스 파일 시스템에서 루트 디렉토리부터 경로에 접근하는 것처럼 동작함(웹 서버의 루트가 여기서의 루트가 된다.)
 - 여기서 루트가 되는 디렉토리를 변경하는 것도 가능하다.
 - 접속 도메인에 따라서 서로 다른 루트디렉토리를 반환하는 것도 가능하다.

#### 5.7.2 디렉토리 목록(p.140)
 - 사용자가 요청한 디렉토리 내에 index.xxx 파일이 없는 경우 디렉토리의 목록을 보여준다.
 - 이 설정은 보안 취약점으로 반드시 꺼야한다.

#### 5.7.3 동적 콘텐츠 리소스 매핑(p.141)
 - 앞서 단순히 정적 리소스를 매핑해줬다면 이번엔 DB 등 서버 내 존재하는 백엔드 애플리케이션을 이용해 콘텐츠를 동적으로 만들어주는 것이다.
 - 책에는 자바 서블릿 등등 나오고 있는데 우리 머리속에 생각난 것처럼 정적인 형태로 제공되는 파일 말고 다른 모든걸 생각해보면 될듯.

#### 5.7.4 서버사이트 인클루드(Server-Side Includes, SSI)(p.142)
 - 콘텐츠에 필요한 내용을 서버사이드에서 추가하는 것도 가능하다.(예를들면 HTML 페이지의 헤더, 푸터 처럼 공통을 들어갈만한 내용들)

#### 5.7.5 접근 제어(p.142)
 - 웹 서버는 각 리소스별로 접근 제어를 할당할 수 있다.
 - IP를 통한 접근제어도 가능하고, ID/PW를 묻는 방식도 가능하다.

### 5.8 단계 5: 응답 만들기(p.143)
 - 리소스는 매핑 시켰고 이제 응답을 만들어야한다.
 - 헤더와 본문이 필요한데 리소스가 보통 본문에 들어가고 리소스의 타입과 길이에 따라 헤더가 변경된다.

#### 5.8.1 응답 엔터티(p.143)
 - 응답 메시지는 다음과 같은 내용을 포함
    - 본문의 MIME 타입에 따라 Content-Type 헤더 결정
    - 본문의 길이에 따라 Content-Length 헤더 결정
    - 실제 응답 본문 내용

#### 5.8.2 MIME 타입 결정하기(p.143)
 - 다음과 같은 방법들로 MIME 타입을 결정할 수 있다.
    - 확장자
    - 매직 타이핑 -> 보통 매직 넘버라고 함. (참고 : https://gist.github.com/leommoore/f9e57ba2aa4bf197ebc5)
    - 유형 명시 -> 서버가 지정해준대로 결정
    - 유형 협상 -> 특정 리소스를 여러 종류에 속하도록 설정하고 사용자가 원하는 타입으로 보내준다.

#### 5.8.3 리다이렉션(p.144)
 - 여러 이유로 리다이렉션이 생길 수 있으나, 만약 클라이언트가 웹 브라우저일 경우 이는 자동으로 리다이렉션이 된다.
 - 자동으로 리다이렉션이 일어날 경우 **HTTP 트랜잭션이 2번 발생한다.**
 - 만약 서버라면 자동으로 리다이렉션을 시켜주지 않기 때문에, 에러도 아니고 본문도 없는 상황을 경험할 수도 있다. curl로 헤더까지 한번 찍어보는 습관을 들여보자.

### 5.9 단계 6: 응답 보내기(p.145)
 - 앞선 과정까지로 완성된 응답 메시지를 보낸다.

### 5.10 단계 7: 로깅(p.146)
 - 트랜잭션이 완료되었을 때 웹 서버는 해당 트랜잭션이 수행된 결과를 로그파일에 기록한다.
 - 대부분의 웹 서버는 로깅에 대한 여러가지 설정 양식 or 포맷을 제공한다.
