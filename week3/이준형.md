## 5장 웹 서버 (p.125)

### 5.1 다채로운 웹 서버(p.125)
 - 웹 서버 : 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아서 컨텐츠를 클라이언트에게 돌려준다.

#### 5.1.1 웹 서버 구현(p.126)
 - 웹 서버는 HTTP 프로토콜을 구현하고, 웹 리소스를 관리하고, 웹 서버 관리 기능을 제공한다.

#### 5.1.2 다목적 소프트웨어 웹 서버(p.126)
 - 넷 크래프트의 조사 (https://news.netcraft.com/archives/2020/08/26/august-2020-web-server-survey.html)
    - 현재 1위부터 나열하면 다음과 같다. (괄호는 점유율)
        - nginx(36%)
        - Apache(26%)
        - Microsoft(10%)
        - Google(4%)
        - Other(24%)

#### 5.1.3 임베디드 웹 서버(p.127)
 - 범용 웹 서버가 아닌, 전자 제품에 내장될 목적으로 사용되는 웹 서버임.

### 5.2 간단한 펄 웹 서버(p.127)
 - perl 언어로 작성된 간단한 웹 서버를 보여주고 있다. (사람이 응답 메시지를 적어줘야한다 -_-)

### 5.3 진짜 웹 서버가 하는 일(p.130)
 - 4장까지 배웠던 내용들을 다시 적고있다. 1~7까지의 순서와 그림을 보며 확인해보자.
 - 어차피 뒤에서 해당 내용들이 하나씩 나온다.

### 5.4 단계 1: 클라이언트 커넥션 수락(p.131)
 - 해당 클라이언트와 서버 사이에 기존에 열려있던 지속 커넥션이 있다면 해당 커넥션을 사용하면 되지만 없다면 커넥션을 만들어줘야한다.

#### 5.4.1 새 커넥션 다루기(p.131)
 - 커넥션은 항상 클라이언트가 서버에 요청한다.
 - 커넥션이 만들어지면 서버는 커넥션을 다른 커넥션과 함께 목록으로 만들어 관리한다.
 - 웹 서버는 어떤 커넥션이든 마음대로 거절하거나 즉시 닫을 수 있다. (인가되지 않거나 악의적인 경우 커넥션을 닫는다.)

#### 5.4.2 클라이언트 호스트 명 식별(p.132)
 - 특정 웹 서버의 경우 reverse DNS를 통해 클라이언트의 IP 주소를 호스트 명으로 변환하도록 설정되어있다.
 - 이 경우 호스트명을 찾는데 시간이 걸려 응답 시간이 늦어질 수 있다.
 - 때문에 해당 설정을 비활성화하는게 좋다. (클라이언트의 호스트명을 꼭 알아야하는게 아니라면)
 - nginx의 rDNS(reverse DNS) 설정 : https://www.nginx.com/resources/wiki/modules/rdns/

#### 5.4.3 ident를 통해 클라이언트 사용자 알아내기(p.132)
 - 클라이언트측 113번 포트를 통해 ident 프로토콜을 listen한다.
 - 다음과 같은 과정을 거친다.
    - 클라이언트가 새로운 HTTP 커넥션을 맺는다.
    - 서버가 클라이언트와 ident 커넥션을 맺는다.
    - 서버가 클라이언트에게 정보를 클라이언트의 정보를 묻는다.
    - 클라이언트가 본인 정보를 답한다.
 - 잘 사용 안함

### 5.5 단계 2: 요청 메시지 수신(p.133)
 - 커넥션을 통해 요청 메시지가 오면 웹 서버를 해당 데이터를 파싱해서 요청 메시지를 구성함.
 - 요청 메시지 형태는 기존에 학습했던 대로임.
 - 웹 서버는 데이터를 네트워크로부터 불규칙적으로 받는다. 네트워크 커넥션은 언제라도 무효화될 수 있고, 웹 서버는 파싱해서 이해할 수 있을 때까지 데이터를 메모리에 임시로 저장할 수도 있음.

#### 5.5.1 메시지의 내부 표현(p.134)
 - 몇몇 웹서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장함.
 - 또한 룩업 테이블을 이용해 각 헤더 값에 빠르게 접근 가능하다.(key-value로 해시테이블 처럼 동작하는듯.)

#### 5.5.2 커넥션 입력/출력 처리 아키텍처(p.135)
 - 고성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원
 - 어떤 커넥션은 요청이 빠르게, 어떤 커넥션은 느리고 천천히 그리고 드물게 들어올 수도 있다.
 - 이 때문에 웹 서버는 항상 새 요청을 주시하고 있고, 웹 서버 아키텍처의 차이에 따라 요청을 처리하는 방식도 달라진다.
 - 다음은 아키텍처별 설명이다.
    - 단일 스레드 웹 서버
        - 한번에 하나의 요청만 처리한다. 앞서 type-o-serve 처럼 테스트용 서버에만 적합함.
    - 멀티프로세스와 멀티스레드 웹 서버
        - 여러 요청을 처리하기 위해 여러개의 프로세스 or 스레드를 할당한다.
        - 프로세스/스레드는 요청에 의해 만들수도 있고, 스레드풀 형태로 미리 만들어질 수도 있음.
        - 모든 커넥션마다 프로세스/스레드를 하나씩 만드는 수도 있으나, 시스템의 오버헤드가 커지기 때문에 최대 커넥션 수를 제한한다.
    - 다중 I/O 서버
        - 이벤트 드리븐 방식으로 처리하는 것 같다.
        - 프로세스와 스레드가 요청을 기다리는게 아니라, 커넥션에 처리할게 생기면 프로세스와 스레드가 할당 받아서 처리하는 방식이다.
    - 다중 멀티스레드 웹 서버
        - 멀티스레드 + 다중 I/O를 합친 방식임.

### 5.6 단계 3: 요청 처리(p.137)
 - 웹 서버가 요청을 받아서 처리하는 과정이다.

### 5.7 단계 4: 리소스의 매핑과 접근(p.137)
 - 요청 메시지의 URI에 대응하는 알맞은 콘텐츠나 콘텐츠 생성기를 웹 서버에서 찾아서 그 콘텐츠에 매핑하는 과정이다.

#### 5.7.1 Docroot(p.137)
 - 단순히 파일 형태로 리소스를 매핑하는 것을 말한다. 리눅스 파일 시스템에서 루트 디렉토리부터 경로에 접근하는 것처럼 동작함(웹 서버의 루트가 여기서의 루트가 된다.)
 - 여기서 루트가 되는 디렉토리를 변경하는 것도 가능하다.
 - 접속 도메인에 따라서 서로 다른 루트디렉토리를 반환하는 것도 가능하다.

#### 5.7.2 디렉토리 목록(p.140)
 - 사용자가 요청한 디렉토리 내에 index.xxx 파일이 없는 경우 디렉토리의 목록을 보여준다.
 - 이 설정은 보안 취약점으로 반드시 꺼야한다.

#### 5.7.3 동적 콘텐츠 리소스 매핑(p.141)
 - 앞서 단순히 정적 리소스를 매핑해줬다면 이번엔 DB 등 서버 내 존재하는 백엔드 애플리케이션을 이용해 콘텐츠를 동적으로 만들어주는 것이다.
 - 책에는 자바 서블릿 등등 나오고 있는데 우리 머리속에 생각난 것처럼 정적인 형태로 제공되는 파일 말고 다른 모든걸 생각해보면 될듯.

#### 5.7.4 서버사이트 인클루드(Server-Side Includes, SSI)(p.142)
 - 콘텐츠에 필요한 내용을 서버사이드에서 추가하는 것도 가능하다.(예를들면 HTML 페이지의 헤더, 푸터 처럼 공통을 들어갈만한 내용들)

#### 5.7.5 접근 제어(p.142)
 - 웹 서버는 각 리소스별로 접근 제어를 할당할 수 있다.
 - IP를 통한 접근제어도 가능하고, ID/PW를 묻는 방식도 가능하다.

### 5.8 단계 5: 응답 만들기(p.143)
 - 리소스는 매핑 시켰고 이제 응답을 만들어야한다.
 - 헤더와 본문이 필요한데 리소스가 보통 본문에 들어가고 리소스의 타입과 길이에 따라 헤더가 변경된다.

#### 5.8.1 응답 엔터티(p.143)
 - 응답 메시지는 다음과 같은 내용을 포함
    - 본문의 MIME 타입에 따라 Content-Type 헤더 결정
    - 본문의 길이에 따라 Content-Length 헤더 결정
    - 실제 응답 본문 내용

#### 5.8.2 MIME 타입 결정하기(p.143)
 - 다음과 같은 방법들로 MIME 타입을 결정할 수 있다.
    - 확장자
    - 매직 타이핑 -> 보통 매직 넘버라고 함. (참고 : https://gist.github.com/leommoore/f9e57ba2aa4bf197ebc5)
    - 유형 명시 -> 서버가 지정해준대로 결정
    - 유형 협상 -> 특정 리소스를 여러 종류에 속하도록 설정하고 사용자가 원하는 타입으로 보내준다.

#### 5.8.3 리다이렉션(p.144)
 - 여러 이유로 리다이렉션이 생길 수 있으나, 만약 클라이언트가 웹 브라우저일 경우 이는 자동으로 리다이렉션이 된다.
 - 자동으로 리다이렉션이 일어날 경우 **HTTP 트랜잭션이 2번 발생한다.**
 - 만약 서버라면 자동으로 리다이렉션을 시켜주지 않기 때문에, 에러도 아니고 본문도 없는 상황을 경험할 수도 있다. curl로 헤더까지 한번 찍어보는 습관을 들여보자.

### 5.9 단계 6: 응답 보내기(p.145)
 - 앞선 과정까지로 완성된 응답 메시지를 보낸다.

### 5.10 단계 7: 로깅(p.146)
 - 트랜잭션이 완료되었을 때 웹 서버는 해당 트랜잭션이 수행된 결과를 로그파일에 기록한다.
 - 대부분의 웹 서버는 로깅에 대한 여러가지 설정 양식 or 포맷을 제공한다.


## 6장 프록시(p.147)
 - 웹 프록시 서버는 중개자로, 클라이언트와 서버 사이에 위치하여 HTTP 메시지를 중개한다.

### 6.1 웹 중개자(p.148)

#### 6.1.1 개인 프록시와 공유 프록시(p.148)

#### 6.1.2 프록시 대 게이트웨이(p.149)
 - 프록시는 **같은 프로토콜**을 사용하는 둘 이상의 애플리케이션을 연결
 - 게이트웨이는 **다른 프로토콜**을 사용하는 둘 이상을 연결
 - 하지만 실질적으로 프록시와 게이트웨이의 차이점은 모호함. 게이트웨이에 대한 자세한 설명은 8장에 나옴.

### 6.2 왜 프록시를 사용하는가?(p.150)
 - 보안, 성능, 비용에 이점이 있고, 프록시는 모든 HTTP 트래픽들 들여다보고 건드릴 수 있다.
 - 부가적인 가치를 주는 여러 유용한 웹 서비스를 구현하기 위해 트래픽을 감시하고 수정할 수 있다.
 - 사내망이나 교내망 같은 곳에서 외부 IP로 접속하려면 대개 프록시를 통해 접속해야한다.
 - 필터, 접근제어, 방화벽, 웹 캐시, 대리자, 콘텐츠 라우터, 트랜스코더, 익명화 등의 기능을 수행한다.

### 6.3 프록시는 어디에 있는가?(p.155)

#### 6.3.1 프록시 서버 배치(p.156)
 - 출구 프록시 : 사내망이나 교내망에 설치된 것 처럼 특정망에서 외부망으로 요청할 때 존재하는 프록시
 - 접근(입구) 프록시 : 주로 캐시로 사용되는 프록시 (클라이언트에 더 가깝다.) -> VOD, CDN 같은 곳에 활용
 - 대리 프록시 : 리버스 프록시로 로드벨런서 같은 개념을 생각하면 될듯.
 - 네트워크 교환 프록시 : 우리가 보통 생각하는 네트워크와 네트워크 사이에 존재하는 프록시

#### 6.3.2 프록시 계층(p.157)
 - 프록시도 계층 관계를 맺을 수 있다. (그림 6-12, 6-13 참고)
 - 계층은 정적일 수도 있고, 동적으로 변경될 수도 있다.

#### 6.3.3 어떻게 프록시가 트래픽을 처리하는가(p.159)
 - 클라이언트는 보통 웹 서버와 직접 대화하기 때문에 우리는 어떻게 HTTP 트래픽이 프록시로 향하는 길을 찾아내는지 알아야한다.
 - 다음 4가지 방법이 있다.
    - 클라이언트를 수정 : 브라우저 등에서 수동 or 자동으로 프록시로 접속하도록 설정을 변경(인터넷 설정에서 설정할 수 있다.)
    - 네트워크를 수정 : 네트워크상에서 클라이언트는 모르게, 스위칭 장비와 라우팅 장비르 통해 인터셉트하여 프록시를 탄다.
    - DNS 네임 스페이스를 수정 : 웹 서버의 도메인 네임을 프록시가 사용하면 프록시로 트래픽이 흐른다.
    - 웹 서버를 수정 : HTTP 리다이렉션을 통해 클라이언트가 프록시로 요청하도록 변경할 수 있다.

### 6.4 클라이언트 프록시 설정(p.161)
 - 클라이언트가 프록시를 사용하도록 하는 방법에는 수동으로 설정하거나 자동 설정 등 여러 방법이 있다.

#### 6.4.1 클라이언트 프록시 설정: 수동(p.162)

#### 6.4.2 클라이언트 프록시 설정: PAC 파일(p.162)

#### 6.4.3 클라이언트 프록시 설정: WPAD(p.163)

### 6.5 프록시 요청의 미묘한 특징들(p.164)
 - 프록시를 통한 요청들은 클라이언트가 직접 요청한 것과는 다른 미묘한 특징이 있다.

#### 6.5.1 프록시 URI는 서버 URI와 다르다(p.164)
 - 클라이언트가 웹 서버로 요청을 보낼때의 URL : **/index.html**
 - 웹 프록시로 보내는 URL : **http://www.marys-antiques.com/index.html**
 - 왜 이런가? 프록시가 요청을 어디로 포워딩할지 알게하려면 부분 URL이 아닌 전체 URL을 알려줘야함.

#### 6.5.2 가상 호스팅에서 일어나는 같은 문제(p.165)
 - 가상으로 호스팅 되는 웹 서버는 여러 웹 사이트가 같은 물리적 웹 서버를 공유
 - 해당 웹 서버들 중 적절한 웹 서버를 찾으려면 마찬가지로 전체 URL이 필요하다. (또는 Host 헤더가 필요함)

#### 6.5.3 인터셉트 프록시는 부분 URI를 받는다.(p.166)
 - 인터셉트 프록시의 존재를 클라이언트는 모르기 때문에 부분 URI를 받는다.
 - 그럼 목적지를 어떻게 아는가?
    - 대리 프록시인 경우 목적지 서버가 정해져 있기 때문에 문제 없음.
    - 인터셉트 프록시인 경우 캐시된 응답을 보내주기 때문에 기존과 같은 URI라면 같은 응답을 해줄 수 있다. (요건 설명이 좀 부족한 것 같은데.. 20장에 있다고 한다.)

#### 6.5.4 프록시는 프록시 요청과 서버 요청을 모두 다룰 수 있다.(p.167)
 - 다목적 프록시는 완전한 URI와 부분 URI 모두 지원해야한다.
 - 완전한 URI -> 그대로 사용
 - 부분 URI && Host 헤더 **있음** -> Host 헤더 사용
 - 부분 URI && Host 헤더 **없음** -> 대리 프록시라면 이미 지정되어있음. 인터셉터 프록시라면 기존에 알고있던 원 IP 주소와 포트번호 사용,
    여기까지 실패하면 에러메시지 발송 (보통은 Host 헤더가 있다.)

#### 6.5.5 전송 중 URI 변경(p.168)
 - 프록시 서버는 요청 URI 변경에 매우 신경써야 한다.
 - 또한 최대한 관대하게 HTTP 프로토콜을 받아들여야한다.
 - 특히 인터셉트 프록시가 URI를 전달할 때 절대 경로를 고쳐 쓰는 것은 금지되나, 유일하게 빈 경로를 '/'로 교체하는 것은 가능하다.

#### 6.5.6 URI 클라이언트 자동확장과 호스트 명 분석(Hostname Resolution)(p.168)

#### 6.5.7 프록시 없는 URI 분석(URI Resolution)(p.169)
 - DNS 서버와 상호작용하며 적절한 호스트 명을 추천해준다.

#### 6.5.8 명시적인 프록시를 사용할 때의 URI 분석(p.170)
 - DNS는 프록시 서버의 IP만 알려줄 것이기 때문에 실제 호스트 명을 자동완성할 수 없다.

#### 6.5.9 인터셉트 프록시를 이용한 URI 분석(p.170)
 - 그림이 조금 어려운데.. DNS 입장에서는 특정 IP가 죽은지 산지 알지 못한다.
 - 때문에 클라이언트가 서버로 요청을 날리면 인터셉터 프록시가 해당 요청을 받고 서버로 전달하는 과정에서야 해당 서버가 죽어있다는 사실을 알 수 있다.
 - 이를 막으려면 프록시가 Host 헤더에 있는 호스트 명을 다시 분석하던가, IP 주소에 대한 Reverse DNS Lookup을 하여 다른 IP 주소를 찾아야한다.

### 6.6 메시지 추적(p.172)
 - ISP들과 많은 회사들이 보안과 비용 절감, 성능 개선과 기능 구현을 위해 인터넷 접속 캐시 프락시 서버를 사용한다.
 - 프록시가 점점 더 흔해지면서 각종 네트워크 장비와 프록시를 넘나드는 메시지의 흐름을 추적하고 문제점을 찾아내는 것도 필요한 일이 되었다.

#### 6.6.1 Via 헤더(p.172)
 - 메시지가 지나는 각 중간 노드의 정보를 나열한다.
 - 중간 노드는 Via 목록의 끝에 반드시 추가되어야 한다.
 - Via: 1.1 proxy-62.xxx, 1.0 cache.joes-.xxx
 - 프록시는 네트워크의 라우팅 루프를 탐지하기 위해서도 Via 헤더를 사용할 수 있다.
 - 요청과 응답은 서로 프록시를 역순으로 탈 것이기 때문에 요청의 Via와 응답의 Via는 역순으로 동일하다.
 - 게이트웨이를 지나는 메시지에도 Via 헤더가 추가된다. 게이트웨이는 비 HTTP 프로토콜도 사용할 수 있기 때문에 HTTP 애플리케이션은 프로토콜의 변환이 있었는지 알 수 있다.
 - 프록시는 Server 헤더를 수정해서는 안된다.
 - Via 헤더는 네트워크 구조를 알아챌 수 있기 때문에 악용될 수 있다. 보안을 위해 압축할 수도 있다.(경유지들이 같은 조직에 의해 통제되고 있는 한)

#### 6.6.2 TRACE 메서드(p.177)
 - TRACE는 프록시 흐름을 디버깅하는데 매우 유용하다.
 - 기본적으로 TRACE는 프록시를 무한히 거칠 수 있으나, 메시지나 무한 루프에 빠지지 않는지 프록시 체이닝을 테스트하기 위해 Max-Forwards를 사용할 수 있다. (OPTIONS 메서드도 가능)
 - Max-Forward가 0인 경우 수신자는 더이상 전달하지 않고 메시지를 클라이언트에게 돌려준다.
 - Max-Forward가 0보다 크다면 -1 씩 하면서 계속 전달된다.

### 6.7 프록시 인증(p.178)
 - 프록시는 접근 제어도 가능하다.
 - 제한된 컨텐츠에 접근할 때 407 Proxy Authorization Required를 이용해 자격을 어떻게 증명할 수 있는지 설명해주는 Proxy-Authenticate 헤더 필드를 함께 반환할 수 있다.
 - 클라이언트는 로컬에 저장된 인증 정보나 사용자에게 물어봐서든 요구되는 자격을 수집하고, 다음 요청에 보낸다.
 - 자격이 유효하면 Forwarding하고, 그렇지 않으면 다시 407을 반환한다.
 - 경유지상에 프록시 인증이 여러개 존재하면 일반적으로 정상동작하지 않는다.

### 6.8 프록시 상호운용성(p.180)
 - 프록시 서버는 서로 다른 프로토콜로 구현했을 수도 있고 골치 아프게 이상한 동작을 할 수도 있는 클라이언트와 서버 사이를 중개해야 한다. (프록시는 관대해야 한다.)

#### 6.8.1 지원하지 않는 헤더와 메서드 다루기(p.180)
 - 프록시는 이해할 수 없는 헤더는 반드시 그대로 전달하고, 같은 이름의 헤더 필드가 여러개 있으면 상대적인 순서도 반드시 유지해야 한다.
 - HTTP/1.1은 메소드를 확장하는 것을 허용하고 있기 때문에 모르는 메소드가 들어와서 포워딩 해야한다.

#### 6.8.2 OPTIONS: 어떤 기능을 지원하는지 알아보기(p.181)
 - 원래의 OPTIONS와 동일하게 동작함.
 - 어떤 메서드가 지원되는지 서술하는 헤더는 Allow 하나 뿐임. OPTIONS는 응답 본문을 허용하기도 하지만, 표준으로 어떤 내용을 포함해야한다라고 정해진건 없다.

#### 6.8.3 Allow 헤더(p.182)
 - 서버가 지원하는 메서드들을 포함하고 있고, 프록시는 이 헤더의 필드를 수정할 수 없다.
