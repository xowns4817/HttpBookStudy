
## 5장 웹 서버

### 5.1 다채로운 웹 서버
 - 웹 서버는 HTTP 요청을 처리하고 응답을 제공한다.
 - 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아서 콘텐츠를 클라이언트에게 돌려준다.

#### 5.1.1 웹 서버 구현
 - 웹 서버는 HTTP 및  그와 관련된 TCP 처리를 구현한다. 
 - 웹 서버는 TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 갖는다.

### 5.3 진짜 웹 서버가 하는 일 ( 그림 5-3 참조 )
 - 1. 커넥션을 맺는다 : 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다.
 - 2. 요청을 받는다. : HTTP 요청 메시지를 네트워크로 부터 읽어 들인다.
 - 3. 요청을 처리한다 : 요청 메시지를 해석하고 행동을 취한다.
 - 4. 리소스에 접근한다 : 메시지에서 저장한 리소스에 접근한다.
 - 5. 응답을 만든다. : 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다.
 - 6. 응답을 보낸다. : 응답을 클라이언트에게 돌려준다.
 - 7. 트랜잭션 로그로 남긴다. : 로그파일에 트랜잭션 완료에 대한 기록을 남긴다.

### 5.4 단계 1: 클라이언트 커넥션 수락 ( 클라이언트와 서버의 커넥션 OPEN )
 - 클라이언트와 서버가 이미 지속 커넥션을 맺고 있다면 재사용, 아니라면 새 커넥션을 연다.
#### 5.5 2: 요청 메시지 수신
 - 커넥션에 데이터가 도착하면, 웹 서버는 네트워크 커넥션에서 그 데이터를 읽어 들어고 파싱하여 요청 메시지를 구성한다.
 - 요청 메시지를 파싱할 때, 웹 서버는 다음과 같은 일을 한다.
   - 요청줄을 파싱하여 요청 메서드, 리소스의 식별자(URI), 버전 번호를 찾는다. 각 값은 스페이스 한 개로 분리되어 있으며, 요청줄은 키리지 리턴 줄바꿈(CRLF) 문자열로 끝난다.
   - 메세지 헤더들을 읽는다. 각 메시지 헤더는 CRLF로 끝난다.
   - 해더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아낸다. 
   - 요청 본문이 있다면, 읽어 들인다. ( 길이는 Content-Length 해더로 정의된다. )

##### 5.5.1 메시지의 내부 표현
  - 몇몇 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료구조에 저장한다. ( 그림 5-6 참조)
##### 5.5.2 커넥션 입력
  - 웹 서버 아키텍처의 차이에 따라 요청을 처리하는 방식이 달라진다.
    - 단일 스레드 웹 서버  ( cpu core 1개 밖에 못씀 )
      - 단일 스레드 웹 서버는 한번에 하나씩 요청을 처리한다. ( 트랜잭션이 완료되면, 다음 커넥션이 처리된다.)
      - 구현은 쉬우나 처리 도중 다른 커넥션은 무시된다.
    - 멀티 프로세스와 멀티스레드 웹 서버 ( APACHE, tomcat - 쓰레드 풀 방식 )
      - 여러 요청을 동시에 처리하기 위해 여러 개의 프로세스 혹은 고효율 스레드를 활용한다.
      - 쓰레드/프로세스는 필요할때마다 만들어 질 수 있고 미리 만들어 질 수 있다.
      - 커넥션은 메모리/시스템 리소스를 소비한다. -> 대부분의 멀티스레드 웹 서비스가 스레드/프로세스의 최대 갯수 제한을 한다. ( 보통은 cpu core갯수보다 조금 많이 설정 )
    - 다중 I/O 서버 ( NGINX, nodejs ) -> 스레드 자체는 1개고 non blocking i/o?
      - 다중 아키텍처에서는, 모든 커넥션은 동시에 그 활동을 감시당한다.
      - 커넥션의 상태가 바뀌면, 그 커넥션을 일부 사용할 수 있다.?
    - 다중 멀티스레드 웹 서버 -> 스레드 자체도 여러개고 각 스레드는 non blokcking i/o ( b + c ? )
      - cpu core의 사용량을 늘리기 위해 멀티스레딩과 다중화를 결합한다.

#### 5.6 단계 3: 요청 처리
  - 웹 서버가 요청을 받으면 서버는 요청으로 부터 메서드, 리소스, 헤더, 본문(없는 경우도 있음)을 얻어내어 처리한다.
#### 5.7 단계 4: 리소스의 매핑과 접근
  - 웹서버는 정적, 동적인 리소스를 제공하는 리소스 서버이다.

##### 5.7.1 Docroot
  - 웹 서버 파일 시스템의 특별한 폴더를 웹 콘텐츠를 위해 예약해 둔다. 이 폴더는 문서 루트 혹은 docroot로 불린다. 웹 서버는 요청 메시지에서 URI를 가져와서 문서 루트 뒤에 붙인다.  ( ex. http://ip:port/index.html -> /var/www/html/index.html ) -> 해당 서버로 요청이 들어오면 index.html앞에 DocumentRoot 경로를 붙여서 해당 리소스를 찾는다. ( apache2 default DocumentRoot : /var/www/html )
  - 아파치 DocumentRoot 설정파일 : /etc/apache2/sites-available/000-default.conf 에 DocumentRoot 수정후 재시작 ( sudo /etc/init.d/apache2 restart )

##### 가상 호스팅된 docroot ( p. 139 d예 5-3 참조)
  - 가상 호스팅 웹 서버는, 각 사이트에 그들만의 분리된 문서 루트를 주는 방법으로 한 웹 서버에서 여러 개의 웹 사이트를 호스팅 한다. ( 서버는 1대인데 도메인/IP주소 별 DocumentRoot를 여러개 설정??)
  - 이를 통해, 하나의 웹 서버 위에서 두 개의 사이트가 완전히 분리된 콘텐츠를 갖고 호스팅 되도록 할 수 있다.
  - host 파일 수정 ( aaa.com, bbb.com -> 127.0.0.1 ) -> localhost, aaa.com, bbb.com이 127.0.0.1을 가리킴
  - 000-default.conf
```
<VirtualHost aaa.com:8001>
	DocumentRoot /var/www/aaa
	ServerName aaa.com
</VirtualHost>

<VirtualHost bbb.com:8001>
	DocumentRoot /var/www/bbb
	ServerName bbb.com
</VirtualHost>
```

  ```
/var/www -> html -> index.html ( hello apache )
	          aaa -> index.html ( hello apache2 aaa )
            bbb -> index.html ( hello apache2 bbb ) 
```
- -> 위와같이 설정을 하면 apache 서버 1대로 3개의 독립적인 서비스가 가능하다. localhost로 접근하면 /var/www/html에 있는 리소스, aaa.com으로 접근하면 /var/www/aaa에 있는 리소스, bbb.com으로 접근하면 /var/www/bbb에 있는 리소스에 접근할 수 있다.


    
#### 5.8 단계 5: 응답 만들기
  - 응답 메시지는 응답 상태 코드, 응답 헤더, 응답 본문(있다면)을 포함한다.
##### 5.8.1 응답 엔터티
  - 응답 본문이 있다면, 그 내용을 응답 메시지와 함께 클라이언트로 돌려보낸다.
  - 만약, 본문이 있다면, 응답 메시지는 주로 다음을 포함한다.
    - 응답 본문의 MIME 타입을 서술하는 Content-Type 헤더
    - 응답 본문의 길이를 서술하는 Content-Length 헤더
    - 실제 응답 본문의 내용

##### 5.8.2 MIME 타입 결정하기 
  - MIME 타입과 리소스를 연결하는 여러가지 방법
    - 1. mine.types
      - 파일 이름의 확장자를 사용 ( 리소스의 MIME 타입을 계산하기 위해 확장자별 MIME 타입이 담겨 있는 파일을 탐색 ) - 가장 흔한 방법 ( p.144 그림 5-12 참조)
    - 2. 매직 타이핑
      - MIME 타입을 알아내기 위해 파일의 내용을 검사해서 알려진 패턴에 대한 테이블( 매직 파일)에 해당하는 패턴이 있는지 찾음.
      - 느리긴 하지만 파일이 표준 확장자 없이 이름 지어진 경우 편리하다.

##### 5.8.3 리다이렉션
  - 웹 서버는 요청을 수행하기 위해 브라우저가 다른 곳으로 가도록 리다이렉트 할 수 있다.
  - 응답은 300 대 상태로 지칭된다.


### 6장 프락시
 - 프락시는 클라이언트와 서버 사이에 위치하여 그들 사이의 HTTP 메시지를 정리하는 중개인 처럼 동작한다.
 - 6장에서 다룰 내용
   - HTTP 프락시와 웹 게이트웨이의 비교
   - 프락시가 실제 네트워크에 어떻게 배치되어 있는지? 그리고 트래픽이 어떻게 프락시 서버로 가게 되는지?
   - 프락시 서버들을 통화하는 메시지의 경로를, Via 헤더와 TRACE 메서드를 이용해 기록하는 방법
   - 프락시 기반 HTTP 접근 제어
   - 어떻게 프락시가 클라이언트와 서버 사이에 각각의 다른 기능과 버전들을 지원하는지 ?

#### 6.1 웹 중개자
 - HTTP 프락시 서버는 웹 서버이기도 하고 웹 클라이언트 이기도 하다.

##### 6.1.2 프락시 대 게이트웨이
 - 프락시는 같은 프로토콜을 사용하는 둘 이상의 에플리케이션을 연결하는 것이고, 게이트웨이는 서로 다른 프로토콜을 사용하는 둘 이상을 연결한다.

#### 6.2 왜 프락시를 사용하는가?
 - 필터링 ( 특정 사이트 필터링 기능 )
 - 보안 ( 방화벽 및 특정 ip 차단..등등)
 - 웹 캐시
 - 트렌스코더 : 트랜스 코딩이란 데이터의 표현방식을 자연스럽게 변환하는 것을 말한다. 트랜스코딩 프락시는 데이터 표현방식을 변환 한다. ( 용량을 줄이기 위해 GIF -> JPG, 이미지 해상도 조절, 압축, 외국어 문서로 변환..등등 )
 - 익명화 프락시 : HTTP 메시지에서 신원을 식별할 수 있는 특성들 ( ex. 클라이언트 IP주소, FROM 해더, Referer 해더, 쿠기,..등등)을 제거함으로써 익명성 보장 ( p. 155 그림 6-10 참조 )

#### 6.3.1 프락시 서버 배치 ( 질문.. )

#### 6.6 메시지 추적
 - ##### 6.6.1 Via 해더
   - Via 해더 필드는 메시지가 지나는 각 중간 노드(프락시나 게이트웨이)의 정보를 나열한다. ( p.173 그림 6-20 참조 )
   - 메시지가 또 다른 노드를 지날 때마다, 중간 노드는 Via 목록의 끝에 반드시 추가 되어야 한다.
   - 프락시는 네트워크의 라우팅 루프를 탐지하기 위해 Via 헤더를 사용할 수 있다. ( p.173 중간부분.. 무슨말인지 모르겟음 )
 - ##### Via 요청과 응답 경로
   - 요청 메시지와 응답 메시지 모두 프락시를 지나므로 둘 모두 Via 헤더를 가진다.
   - 요청과 응답은 보통 같은 TCP 커넥션을 오가므로, 응답 메시지는 요청과 같은 경로로 되돌아 간다. ( 요청 메시지가 프락시 A->B->C를 지나간다면, 응답 메시지는 프락시 C->B->A를 지나간다. )
 - ##### Via와 게이트워이
   - 몇몇 프락시는 서버에게 비 HTTP 프로토콜을 사용할 수 있는 게이트웨이 기능을 제공한다. ( p.175 그림 6-22 참조 )
   - Via 헤더는 이러한 프로토콜 변환을 기록하므로 HTTP 애플리케이션은 프락시 연쇄에서 프로토콜 능력과 변환이 있었는지 알아 챌 수 있다.

##### Server 해더와 Via 헤더
 - Server 응답 헤더 필드는 원 서버의 정보를 알려준다. ( 이름, 버전..등등 )
 - 응답 메시지가 프락시를 통과할 때, 프락시는 Server 헤더를 수정해서는 안된다.   Server 헤더는 원 서버를 위해 존재한다. 대신 프락시는 Via 항목을 추가해야 한다.

##### 6.6.2 TRACE 메서드 
 - 프락시 서버는 메시지가 전달될 때 메시지를 바꿀 수 있다. ( 헤더 추가, 변경, 삭제 혹은 본문이 다른형식으로 변환. )
 - HTTP/1.1의 TRACE 메서드는 요청 메시지를 프락시의 연쇄를 따라 가면서 어떤 프락시를 지나가고 어떻게 각 프락시가 요청 메시지를 수정하는지 추척할 수 있도록 해준다.
 - TRACE 요청이 목적지 서버에 도착했을 때, 서버는 전체 요청 메시지를 HTTP 응답 메시지의 본문에 포함시켜 송신자에게 그대로 돌려 보낸다. ( P.178 그림 6-23 참조 )
 - TRACE 응답의 Content-Type은 message/http 이다.
 - ##### Max-Forwards
   - TRACE 요청의 프락시 홉(hop)의 갯수를 제한하기 위해 Max-Forwards 헤더를 사용할 수 있다. ( 무한루프 같은 프락시 연쇄를 테스트 하거나, 연쇄 중간에 특정 프락시 서버들의 효과를 체크할때 유용하다. )
   - Max-Forwards 요청 헤더 필드는 이 요청 메시지가 몇 번 더 다음 홉으로 전달될 수 있는지 말해주는 정수 하나를 담고 있다. ( p.179 그림 6-24 ) -> 만약, Max-Forwards 값이 0이라면 TRACE 메시지를 더 이상 전달하지 말고 반드시 클라이언트에게 돌려줘야 한다.

#### 6.7 프락시 인증
  - 프락시는 접근 제어 장치로서 제공될 수 있다.
  - HTTP는 사용자가 유효한 접근 권한 자격을 프락시에 제출하지 않는 한 콘텐츠에 대한 요청을 차단하는 프락시 인증이라는 메커니즘을 정의하고 있다.

#### 6.8 프락시 상호운용성
  - ##### 6.8.1 지원하지 않는 헤더와 메서드 다루기
    - 프락시 서버는 넘어오는 헤더 필드들을 모두 이해하지 못할 수 있다.
    - 프락시는 이해할 수 없는 헤더 필드는 반드시 그대로 전달해야 하며, 같은 이름의 헤더 필드가 여러 개 있는 경우에는 그들의 상대적인 순서도 반드시 유지해야 한다.
  - ##### 6.8.2 OPTIONS: 어떤 기능을 지원하는지 알아보기
    - HTTP OPTIONS 메서드는 서버나 웹 서버의 특정 리소스가 어떤 기능을 지원하는지( 지원하는 메서드 ) 클라이언트가 알아 볼 수 있게 해준다.
