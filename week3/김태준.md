
## 5장 웹 서버

### 5.1 다채로운 웹 서버
 - 웹 서버는 HTTP 요청을 처리하고 응답을 제공한다.
 - 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아서 콘텐츠를 클라이언트에게 돌려준다.

#### 5.1.1 웹 서버 구현
 - 웹 서버는 HTTP 및  그와 관련된 TCP 처리를 구현한다. 
 - 웹 서버는 TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 갖는다.

### 5.3 진짜 웹 서버가 하는 일 ( 그림 5-3 참조 )
 - 1. 커넥션을 맺는다 : 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다.
 - 2. 요청을 받는다. : HTTP 요청 메시지를 네트워크로 부터 읽어 들인다.
 - 3. 요청을 처리한다 : 요청 메시지를 해석하고 행동을 취한다.
 - 4. 리소스에 접근한다 : 메시지에서 저장한 리소스에 접근한다.
 - 5. 응답을 만든다. : 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다.
 - 6. 응답을 보낸다. : 응답을 클라이언트에게 돌려준다.
 - 7. 트랜잭션 로그로 남긴다. : 로그파일에 트랜잭션 완료에 대한 기록을 남긴다.

### 5.4 단계 1: 클라이언트 커넥션 수락 ( 클라이언트와 서버의 커넥션 OPEN )
 - 클라이언트와 서버가 이미 지속 커넥션을 맺고 있다면 재사용, 아니라면 새 커넥션을 연다.
#### 5.5 2: 요청 메시지 수신
 - 커넥션에 데이터가 도착하면, 웹 서버는 네트워크 커넥션에서 그 데이터를 읽어 들어고 파싱하여 요청 메시지를 구성한다.
 - 요청 메시지를 파싱할 때, 웹 서버는 다음과 같은 일을 한다.
   - 요청줄을 파싱하여 요청 메서드, 리소스의 식별자(URI), 버전 번호를 찾는다. 각 값은 스페이스 한 개로 분리되어 있으며, 요청줄은 키리지 리턴 줄바꿈(CRLF) 문자열로 끝난다.
   - 메세지 헤더들을 읽는다. 각 메시지 헤더는 CRLF로 끝난다.
   - 해더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아낸다. 
   - 요청 본문이 있다면, 읽어 들인다. ( 길이는 Content-Length 해더로 정의된다. )

##### 5.5.1 메시지의 내부 표현
  - 몇몇 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료구조에 저장한다. ( 그림 5-6 참조)
##### 5.5.2 커넥션 입력
  - 웹 서버 아키텍처의 차이에 따라 요청을 처리하는 방식이 달라진다.
    - 단일 스레드 웹 서버  ( cpu core 1개 밖에 못씀 )
      - 단일 스레드 웹 서버는 한번에 하나씩 요청을 처리한다. ( 트랜잭션이 완료되면, 다음 커넥션이 처리된다.)
      - 구현은 쉬우나 처리 도중 다른 커넥션은 무시된다.
    - 멀티 프로세스와 멀티스레드 웹 서버 ( APACHE, tomcat - 쓰레드 풀 방식 )
      - 여러 요청을 동시에 처리하기 위해 여러 개의 프로세스 혹은 고효율 스레드를 활용한다.
      - 쓰레드/프로세스는 필요할때마다 만들어 질 수 있고 미리 만들어 질 수 있다.
      - 커넥션은 메모리/시스템 리소스를 소비한다. -> 대부분의 멀티스레드 웹 서비스가 스레드/프로세스의 최대 갯수 제한을 한다. ( 보통은 cpu core갯수보다 조금 많이 설정 )
    - 다중 I/O 서버 ( NGINX, nodejs ) -> 스레드 자체는 1개고 non blocking i/o?
      - 다중 아키텍처에서는, 모든 커넥션은 동시에 그 활동을 감시당한다.
      - 커넥션의 상태가 바뀌면, 그 커넥션을 일부 사용할 수 있다.?
    - 다중 멀티스레드 웹 서버 -> 스레드 자체도 여러개고 각 스레드는 non blokcking i/o ( b + c ? )
      - cpu core의 사용량을 늘리기 위해 멀티스레딩과 다중화를 결합한다.

#### 5.6 단계 3: 요청 처리
  - 웹 서버가 요청을 받으면 서버는 요청으로 부터 메서드, 리소스, 헤더, 본문(없는 경우도 있음)을 얻어내어 처리한다.
#### 5.7 단계 4: 리소스의 매핑과 접근
  - 웹서버는 정적, 동적인 리소스를 제공하는 리소스 서버이다.

##### 5.7.1 Docroot
  - 웹 서버 파일 시스템의 특별한 폴더를 웹 콘텐츠를 위해 예약해 둔다. 이 폴더는 문서 루트 혹은 docroot로 불린다. 웹 서버는 요청 메시지에서 URI를 가져와서 문서 루트 뒤에 붙인다.  ( ex. http://ip:port/index.html -> /var/www/html/index.html ) -> 해당 서버로 요청이 들어오면 index.html앞에 DocumentRoot 경로를 붙여서 해당 리소스를 찾는다. ( apache2 default DocumentRoot : /var/www/html )
  - 아파치 DocumentRoot 설정파일 : /etc/apache2/sites-available/000-default.conf 에 DocumentRoot 수정후 재시작 ( sudo /etc/init.d/apache2 restart )

##### 가상 호스팅된 docroot
  - 가상 호스팅 웹 서버는, 각 사이트에 그들만의 분리된 문서 루트를 주는 방법으로 한 웹 서버에서 여러 개의 웹 사이트를 호스팅 한다. ( 서버는 1대인데 도메인/IP주소 별 DocumentRoot를 여러개 설정??)
  - 이를 통해, 하나의 웹 서버 위에서 두 개의 사이트가 완전히 분리된 콘텐츠를 갖고 호스팅 되도록 할 수 있다.

#### 5.8 단계 5: 응답 만들기
  - 응답 메시지는 응답 상태 코드, 응답 헤더, 응답 본문(있다면)을 포함한다.
##### 5.8.1 응답 엔터티
  - 응답 본문이 있다면, 그 내용을 응답 메시지와 함께 클라이언트로 돌려보낸다.
  - 만약, 본문이 있다면, 응답 메시지는 주로 다음을 포함한다.
    - 응답 본문의 MIME 타입을 서술하는 Content-Type 헤더
    - 응답 본문의 길이를 서술하는 Content-Length 헤더
    - 실제 응답 본문의 내용

##### 5.8.2 MIME 타입 결정하기 
  - MIME 타입과 리소스를 연결하는 여러가지 방법
    - 1. mine.types
      - 파일 이름의 확장자를 사용 ( 리소스의 MIME 타입을 계산하기 위해 확장자별 MIME 타입이 담겨 있는 파일을 탐색 ) - 가장 흔한 방법 ( p.144 그림 5-12 참조)
    - 2. 매직 타이핑
      - MIME 타입을 알아내기 위해 파일의 내용을 검사해서 알려진 패턴에 대한 테이블( 매직 파일)에 해당하는 패턴이 있는지 찾음.
      - 느리긴 하지만 파일이 표준 확장자 없이 이름 지어진 경우 편리하다.

##### 5.8.3 리다이렉션
  - 웹 서버는 요청을 수행하기 위해 브라우저가 다른 곳으로 가도록 리다이렉트 할 수 있다.
  - 응답은 300 대 상태로 지칭된다.