5장. 웹 서버

1. 다채로운 웹 서버

- 웹 서버라는 용어는 웹 서버 소프트웨어와 웹페이지 제공에 특화된 장비 양쪽 모두를 가르킨다.
- 모든 웹서버는 리소스에 대한 HTTP 요청을 받아서 콘텐츠를 클라이언트에게 돌려준다.

1. 웹서버 구현

- 웹서버는 HTTP 프로토콜을 구현, 리소스 관리, 웹서버 관리 기능을 제공한다.
- 웹서버는 TCP 커넥션 관리에 대한 책음을 운영체제와 나눠 갖는다.
- 형태는 다목적 소프트웨어 웹서버와 임베디드 웹 서버

2. 다목적 소프트웨어 웹서버

- 네트워크에 연결된 표준 컴퓨터 시스템에서 동작
- 오픈소스를 소프트웨어를 사용할 수 도 있고, 상용 소프트 웨어를 사용할 수도 있다
- 마이크로소프트 웹, 아파치 웹, nginx 서버

3. 임베디드 웹 서버

- 내장될 목적으로 만들어진 작은 웹서버
- 아이픽 성냥 머리 크기 웹 서버
- 넷미디어 사이트플레이어 SP1 이더넷 웹 서버



2. 간단한 펄 웹 서버

- 완전한 기능을 갖춘 HTTP 서버를 만들고자 하면 할일이 많다. 
- 그러나 최소한으로 기능하는 HTTP 서버라면 30줄 이퍼의 펄(Perl) 코드로 만들수있다



3. 진짜 웹 서버가 하는 일

1. 커넥션을 맺는다
2. 요청을 받는다
3. 요청을 처리한다
4. 리소스에 접근한다
5. 응답을 만든다
6. 응답을 보낸다
7. 트랙잭션을 로그로 남긴다.



4. 단계 1 : 클라이언트 커넥션 수락

- 클라이언트가 이미 서버에 대해 열려있는 지속적 커넥션을 갖고 있다면 재사용이 가능
- 아니면 새 커넥션을 열어야 함



1. 새 커넥션 다루기

- 클라이언트가 웹서버에 TCP 커넥션을 요청하면
  웹서버는 그 커넥션을 맺고 IP주소를 추출하여 어떤 클라이언트가 있는지 확인한다
  새 커넥션이 맺어지고 받아들여지면
  서버는 새 커넥션을 커넥션 목록에 추가하고, 오가는 데이터를 지켜볼 준비를 한다.

2. 클라이언트 호스트 명 식별

- 대부분 웹서버는 역방향 DNS를 사용해서 클라이언트의 IP 주소를 호스트명으로 변환하도록 되어 있다
- 호스트명 룩업은 웹 트랜잭션을 느려지가 할 수 있다.
- 많은 대요량 웹서버는 호스트명 분석을 꺼두거나 특정 콘텐츠에서만 켜놓는다.

3. ident를 통해 클라이언트 사용자 알아내기

- ident 프로토콜은 서버에서 어떤 사용자가 HTTP 커넥션을 초기화 했는지 찾아낼 수 있게 해준다.
- 웹 서버 로깅에서 유용하고, 일반 로그 포맷의 두번째 필드는 ident 사용자 이름을 담고 있다. 



5. 단계 2: 요청 메시지 수신

- 데이터가 도착하면 웹서버는 데이터를 파싱하여 요청 메시지를 구성한다
- 요청줄을 파싱하여 요청메서드, 식별자, 버전번호를 찾는다. 
- 메시지 헤더들을 읽는다.
- CRLF로 끝나는 빈줄을 찾아낸다
- 요청본문이 있으면 읽는다.

1. 메시지의 내부 표현

- 몇몇 웹서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료구조에 저장

2. 커넥션 입력/ 출력 처리 아키텍처

- 고성능 웹서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원
- 웹 서버가 전 세계의 클라이언트들과 각각 한개 이상의 커넥션을 통해 통신할 수 있게 해준다.
  



6.단계 3 : 요청 처리

- 요청으로부터 메서드,리소스,헤더,본문을 얻어내어 처리

7. 단계 4 :  리소스의 매핑과 접근

1. Docroot

- 요청 URI를 웹 서버의 파일 시스템 안에 있는 파일 이름으로 사용하는 것

- 가상 호스팅된 docroot
  - 가상 호스팅 웹 서버는 IP주소나 호스트명을 이용해 올바른 문서 루트를 식별
  - 사용자 홈 디렉터리 docroots
  - 한대의 웹서버에서 각자의 개인 웹사이트를 만들수 있도록 하는것



2. 디렉터리 목록

- 디렉터리 URL 에 대한 요청을 받을 수 있다.  
- 발견할 수 없는 파일도 드러나게 된다는 단점으로, 색일 파일 자동생성을 끌 수 있다

3. 동적 콘텐츠 리소스 매핑

- 애플리케이션 서버는 웹서버를 백앤드 애플리케이션과 연결하는 일을 한다.
- 애플리케이션 서버는 동적 콘텐츠 생성 프로그램이 어디에 있는지, 어떻게 실행하는지 알려줄 수 있어야 한다. 

4. 서버사이드 인클루드(Server-Side Includes, SSI)

- 많은 웹서버가 지원
- 서버는 컨텐츠에 어떤 특별한 패턴이 있는지 검사를 받고, 그 패턴은 실행 가능한 스크립트의 출력값으로 치환된다.



5. 접근 제어

- 각각의 리소스에 접근제어를 할당할 수 있다.



8. 단계 5:응답 만들기

- 서버가 리소스를 식별하면, 동작을 수행한 뒤 응답 메시지를 반환한다. 

1. 응답 엔터티

- Content-Type 헤더
- Content-Length 헤더
- 본문의 내용

2. MIME 타입 결정하기

- MIME 리소스를 연결하는 여러가지 방법
  1. mime.types
  2. 매직 타이핑
  3. 유형 명시(explicit typing)
  4. 유형 협상(Type negotiation)

3. 리다이렉션

- 유용한 경우
  1. 영구히 리소스가 옮겨진 경우
  2. 임시로 리소스가 옮겨진 경우
  3. URL 증강
     - 종종 문맥 정보를 포함시키기 위해 재작성된 URL로 리다이렉트
  4. 부하균형
     - 과부하된 서버가 요청받으면 다른 서버로 리다이렉트
  5. 친밀한 다른 서버가 있을때
     - 어떤 사용자의 대한 정보가 있는 다른 서버로 리다이렉트
  6. 디렉터리 이름 정규화
     - 끝에 (/) 빠뜨리면 붙여서 리다이렉트



9. 단계6:응답 보내기

- 서버는 여러 클라이언트에 대한 많은 커넥션을 가질 수 있고 일부는 아무것도 안하고 있고, 일부는 서버로 데이터를 보내고 있을 것
- 비지속적인 커넥션이라면 서버는 모든 메시지를 전송하고 커넥션을 닫을 것
- 지속적인 커넥션이라면 열린상태를 유지할 것 

10. 단계7: 로깅

- 트랜잭션이 완료 되었을 때 로그를 로그 파일에 기록









---



6장. 프락시

- 클라이언트와 서버 사이에 위치하는 중개자



1. 웹 중개자

- 웹 프락시 서버는 트랜잭션을 수행하는 중개인
- 프락시가 없으면 클라이언트와 HTTP 서버와 직접 이야기하고 있으면 프락시와 대화
- 반드시 요청과 커넥션을 적절히 다루고 응답을 돌려줘야 한다. 

1. 개인 프락시와 공유 프락시

- 공용 프락시
  - 대부분의 프락시는 공용이며, 공유된 프락시이다.
  - 사용자가 많을 수록 유리한데, 여러 사용자들의 공통된 요청에서 이득을 취할 수 있기 때문
- 개인 프락시 
  - 그다시 흔하지는 않지만 꾸준히 사용되고 있다. 



2. 프락시 대 게이트웨이

- 프락시는 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결
- 게이트웨이는 다른 프로토콜을 사용하는 둘 이상을 연결
- 게이트웨이는 서로 다른 프로토콜로 말해도 서로간의 트랜잭션을 완료할 수 있도록 해주는 변환기처럼 동작
  



2. 왜 프락시를 사용하는가?

- 어린이 필터
  - 성인 컨텐츠를 차단
- 문서 접근 제어자
  - 접근 제어전략을 구현하고, 감사추적을 하기 위해 사용
- 보안 방화벽
  - 보안을 가오하하기 위해 사용
- 웹 캐시
- 대리 프락시
  - 느린 웹서버의 성능을 개선하기 위해 사용될 수 있다
- 콘텐츠 라우터
  - 요청을 특정 웹서버로 유도하는 콘텐츠 라우터로 동작할 수 있다
- 트랜스코더
  - 본문 포맷을 수정할 수 있다. 
- 익명화 프락시
  - 개인 정보와 익명성 보장에 기여



3. 프락시는 어디에 있는가?

1. 프락시 서버 배치

- 출구(Egress) 프락시
  - 로컬 네트워크 출구
  - 로컬 네트워크와 더큰 인터넷 사이를 오가는 트래픽을 제어하기 위해
- 전근(입구) 프락시
  - ISP 접근지점
  - 모든 요청을 종합적으로 처리하기 위해
- 대리 프락시
  - 네트워크의 가장 끝에 있는 웹서버들의 바로 앞
- 네트워크 교환 프락시
  - 네트워크 사이의 인터넷 피어링 교환 지점



2. 프락시 계층

- 프락시 계층이라고 불리는 연쇄를 구성할 수 있다

- 프락시 계층 콘텐츠 라우팅
  - 동적으로 매 요청에 따라 바뀔수있다 
  - 캐시 서버에 보내 캐시된 객체를 반환하거나 서버에서 가져오거나 할 수 있다
  - 특정 종류의 이미지인 경우 압축프락시에 보내서 압축해서 빠르게 다운도 가능
  - <동적 부모 선택의 예>
    - 부하를 분산하기 위해 부모 프락시를 고른다.
    - 원서버의 지역을 담당하는 부모를 선택할 수 있다
    - URI에 근거하여 라우팅도 가능
    - 추가금을 냈다면 캐시나 성능개선을 위한 압축 엔진으로 라우팅 될 수 있다



3. 어떻게 프락시가 트래픽을 처리하는가

- 프락시로 가도록 만드는 방법 4가지
  - 클라이언트를 수정
    - 많은 웹 클라이언트들은 수동 혹은 자동 프락시를 지원한다.
    - 클라이언트가 프락시를 사용하도록 설정되어 있으면 의도적으로 프락시로 보낸다. 
  - 네트워크를 수정
    - HTTP 트래픽을 지켜보고 가로채어 트래픽을 프락시로 보낸다.  (인터셉트 프락시)
  - DNS 이름 공간을 수정
    - 웹서버의 이름과 IP주소를 자신이 직접 사용
  - 웹 서버를 수정
    - 클라이언트의 요청을 프락시로 리다이렉트 하도록 설정



4. 클라이언트 프락시 설정

- 수동 설정
- 브라우저 기본 설정
  - 프락시를 미리 설정해 놓을 수 있다
- 프락시 자동 설정 (Proxy auto-configuration, PAC)
  - 자바스크립트 프락시 자동 설정 파일에 대한  URI를 제공할 수있다.
  - 클라이언트는 그 자바스크립트 파일을 가져와서 실행해야 한다.
- WPAD 프락시 발견 (Web Proxy Autodiscovery Protocol)
  - 대부분의 브라우저는 설정 서버를 자동으로 찾아주는 웹 프락시 자동발견 프로토콜 (WPAD)을 제공



1. 클라이언트 프락시 설정 : 수동

- 크롬 : 설정 > 고급설정 표시 > 프록시 설정 변경

2. 클라이언트 프락시 설정 : PAC 파일

- 수동프락시 설정은 유연하지 못하다
- 장애시에 대체 작동에 대한 지원도 없고 큰 조직에서는 관리 문제가 있다
- 그래서 프락시 자동 설정파일은 동적인 해결책

3. 클라이언트 프락시 설정 : WPAD

- WPAD는 여러 발견 메커니즘들의 상승 전략을 이용해 알맞은 PAC 파일을 자동으로 찾아주는 알고리즘



5. 프락시 요청의 미묘한 특징들

1. 프락시 URI와 서버의 URI는 다르다

- 클라이언트가 웹서버로 요청을 보낼 때 부분URI를 가지고, 
- 프락시로 보낼때는 완전한 URI을 가진다. 

2 .가상 호스팅에서 일어나는 같은 문제

- 프락시의 "스킴 / 호스트/ 포트번호" 누락 문제는 가상 호스팅 웹서버와 같은 문제
- 프락시는 완전한 URI을 갖도록 함으로써 문제 해결
- 가상호스팅 웹서버는 호스트와 포트가 담겨있는 HOST헤더를 요구한다 

3. 인터셉트 프락시는 부분 URI를 받는다

- 대리프락시, 인터셉트 프락시는 부분 URI를 받는다.
- 대리프락시는 원서버의 호스트명과 아이피 주소를 사용해 원서버를 대신
- 인터셉트 프락시는 트래픽을 가로채기 때문에 웹서버로 보내는 부분 URI를 없는다. 

4. 프락시는 프락시 요청과 서버 요청을 모두 다를 수 있다

- 프락시는 완전한 URI가 있으면 그것을 사용하고, 없으면 부분 URI를 사용해야 한다.
- 부분URI + HOST 헤더가 있으면 host 헤더로 서버의 이름과 포트번호를 알아야 하고
- 부분URI 만 있고 host 헤더가 없다면
  - 대리프락시는 프락시에 실제 서버의 주소와 포트번호가 있을것이고
  - 인터셉트 프락시는 원IP 주소와 포트번호를 사용할 수 있다면 사용하고
- 모두 실패하면 에러메시지를 반환해야 한다. 

5. 전송 중 URI 변경

- 요청 URI의 변경에 신경을 써야한다. 
- 일반적으로 프락시 서버는 관대하도록 애써야 한다. 

6. URI 클라이언트 자동확장과 호스트 명 분석(Hostname Resolution)

- 브라우저는 프락시가 없으면 URI를 가지고 IP 주소를 찾고
- 호스트가 없으면 자동화된 호스트명의 확장을 제공한다.
  - yahoo만 입력되도록 허용
  - 오타 교정을 시도
  - DNS는 사용자의 호스트명의 앞부분만 입력하면 자동으로 도메인을 검색하도록 설정

7. 프락시 없는 URI 분석(URI Resolution)

- oreilly 입력시 자동으로 확정한 후  연결 성공

8. 명시적인 프락시를 사용할 때의 URI 분석

- 명시적인 프락시가 있는 경우 부분 호스트명을 자동확장하지 않는다. 

9. 인터셉트 프락시를 이용한 URI 분석



6. 메시지 추적

프락시가 점점 더 흔해지면서 프락시를 지나는 메시지를 추적하고 문제점을 찾는것도 필요한 일

1. Via 헤더

- 메시지가 지나는 각 중간 노드의 정보를 나열

- Via문법
  - 쉼표로 구분된 경우지의 목록
  - 구성요소
    - 프로토콜 이름
    - 프로토콜 버전 (필수)
    - 노드 이름(필수)
    - 코멘트
- 프로토콜 이름
  - http라면 이름은 없어도 된다
- 프로토콜 버전
  - 수신한 메시지의 버전
- 노드이름
  - 중개자의 호스트와 포트번호
- 노드 코멘트
  - 중개자 노드를 서술하는 선택적인 코멘트
- Via 요청과 응답 경로
  - 요청,응답 둘다 모두 via 헤더를 가진다. 
- Via와 게이트 웨이
- Server 헤더와 Via 헤더
- Via가 개인정보 보호와 보안에 미치는 영향



2. TRACE 메서드

- 프락시 서버는 메시지가 전달될 때 메시지를 바꿀 수 있다
- 프락시의 연쇄를 따라가면서 프락시를 지나가고 어떻게 각 프락시가 요청 메시지를 수정하는지 관찰/추적 할 수 있게 해준다

- Max-Forwards
  - Trace와 options 요청의 프락시 홉 개수를 제한하기 위해 사용



7. 프락시 인증

- 접근제어장치로 제공될 수 있다
- HTTP는 사용자가 유효한 접근권한 자격을 프락시에 제출하지 않는 한, 
  콘텐츠에 대한 요청을 차단하는 프락시 인증이라는 메커니즘을 정의하고 있다

8. 프락시 상호 운용성

1. 지원하지 않는 헤더와 메서드 다루기

- 이해 할 수 없는 헤더 필드는 반드시 그대로 전달해야 하고
  같은 이름의 헤더 필드가 여러개 있는 경우에는 순서도 반드시 유지해야 한다. 

2. OPTIONS: 어떤 기능을 지원하는지 알아보기

-  웹 서버의 특정 리소스가 어떤 기능을 지원하는지 알려청 줌

3. Allow헤더

- 요청 URI에 의해 식별된ㄴ 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드를 열거


