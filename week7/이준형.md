## 13장 다이제스트 인증(p.331)
- 기본 인증은 편리하고 유연하지만 안전하지 않음.
- 기본 인증을 안전하게 이용하는 유일한 방법은 SSL과 결합해서 사용하는 것이다.
- 다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체제로서 개발되었음.
- **다이제스트 인증은 널리 쓰이지는 않지만, 그 개념은 보안 트랜잭션을 구현하고자 하는 이들에게 여전히 유용함.**

### 13.1 다이제스트 인증의 개선점(p.331)
- 기본 인증에 비해 다음과 같은 특징이 있다.
    - 비밀번호 평문 전송 X
    - 재현 공격 차단
    - (구현에 따라) 메시지 위변조 방지
    - 그 외 몇몇 잘 알려진 형태의 공격을 막는다.
- 다이제스트 인증이 좋은건 아니다. 오히려 HTTPS를 적용하는게 더 쉽고 강력하다. 다만 기본 인증보다는 낫다.

#### 13.1.1 비밀번호를 안전하게 지키기 위해 요약 사용하기(p.332)
- 다이제스트 인증은 클라이언트의 비밀번호를 비가역적(반대로 계산할 수 없는)으로 뒤섞은 요약(digest)를 전송한다.
- [그림 13-1]과 같은 동작을 거쳐서 문서를 요청 / 응답한다.

#### 13.1.2 단방향 요약(p.334)
- 요약은 단방향 함수로 동작하고, 일반적으로 입력 가능한 무한 가지의 모든 입력값들을 유한한 범위의 압축으로 변환한다.(**충돌**이 발생한다. - 비둘기집의 원리)
- 요약이라고 자꾸 얘기했는데, 사실 해시(Hash)를 이야기한다.
- 책에서는 MD5를 이야기하지만, MD5는 안전하지 않다. (너무 짧아서 충돌쌍을 찾기 쉽다.)

#### 13.1.3 재전송 방지를 위한 난스(nonce) 사용(p.335)
- 단순한 해시는 입력이 같다면 출력도 동일하다.
- 때문에 매번 같은 해시가 전송된다면 이 패킷을 재전송하여 클라이언트의 원래 비밀번호를 안 것과 같은 효과를 낼 수 있다.
- 이를 방지하기 위해 계속 바뀌는 값인 nonce를 서버에서 클라이언트로 주고, 클라이언트는 이 값을 포함하여 해시를 만들어야한다.
- 서버는 클라이언트의 비밀번호와 nonce를 알고 있기 떄문에 클라이언트가 보낸 해시와 nonce를 동일하게 계산하여 맞는 digest인지 확인한다.

#### 13.1.4 다이제스트 인증 핸드셰이크(p.335)
- [그림 13-2], [그림 13-3]을 참고하자.
- 특히 [그림 13-3]이 진짜 주고 받는 요청/응답이다. 뒤에 그 과정을 상세히 적어놓았다.

### 13.2 요약 계산(p.338) ~ 13.3.2 다이제스트 인증 헤더(p.347)
- 이러한 세부 사항보다는 맥락을 이해하는게 더 중요할 것 같다.

### 13.4 실제 상황에 대한 고려(p.347)
#### 13.4.1 다중 인증요구(p.348)
- 서버는 클라이언트의 능력을 모르기 때문에 하나의 리소스에 여러개의 인증 방식을 제공할 수 있다.
- 클라이언트를 개발하는 사람은 그중 가장 강력한 인증 방식을 사용해야한다.
- 서버 개발자는 기본 인증을 제한적으로만 사용하도록 해야한다.

#### 13.4.2 오류 처리(p.348)
- 다이제스트 인증에서 지시자나 그 값이 적절하지 않거나 요구된 지시자가 빠져 있으면 400 Bad Request를 응답해야한다.
- 로그인이 실패한 경우 이를 기록해야한다. 이는 공격자가 비밀번호를 추측하는 공격을 시도중일 수도 있다.

#### 13.4.3 보호 공간(Protection Space) (p.349)
- 보호공간 하위의 디렉토리는 모두 보호공간으로 인식한다.

#### 13.4.4 URI 다시 쓰기(p.349)
- 프록시는 가리키는 리소스의 변경없이 구문만 고쳐서 URI를 다시 쓰기도 한다.
- 예를들면 호스트명 정규화, IP 주소로 대체, %로 이스케이프 등등
- 다이제스트 인증은 URI 값의 무결성을 검사하므로 이러한 변경에 의해 실패할 수도 있다.

#### 13.4.5 캐시(p.350)
- 공유 캐시는 Authorization 헤더를 포함한 요청과 그 응답을 받은 경우, 다음 2가지 경우가 아니라면 캐시된 응답을 반환해선 안된다.
    - 원 서버 응답이 Cache-Control: must-revalidate인 경우 -> 잘 이해가 안가긴 함..
    - 원 서버의 응답이 Cache-Control: public인 경우 

### 13.5 보안에 대한 고려사항(p.350)
- RFC-2617 - https://tools.ietf.org/html/rfc2617

#### 13.5.1 헤더 부당 변경(p.350)
- 해더 부당 변경을 방지하려면 종단간 암호화나 헤더에 대한 디지털 서명이 필요하다.
- 다이제스트 인증이 데이터를 보호하는 것은 아니다!

#### 13.5.2 재전송 공격(p.350)
- 재전송 공격을 막는 유일한 방법은 매번 유일한 난스를 계속 변경하는 것이다.
- 이 계산은 서버 부하를 가중시킬 수도 있다.

#### 13.5.3 다중 인증 매커니즘(p.351)
- 클라이언트가 가장 강한 인증방식을 사용하도록 강제할 순 없으니 차선책은 가장 강력한 인증 방식을 사용하는 프록시 서버를 사용하는 것이다.
- 다만 이런 방식도 만만치 않다. 모든 클라이언트가 우리가 선택한 강력한 인증 제도를 지원할 수 있다고 알려져 있어야 함.

#### 13.5.4 사전(dictionary) 공격(p.351)
- 사전 공격은 전형적인 비밀번호 추측 공격이다.
- 단순한 비밀번호, 단순한 난스를 쓴다면 모든 가능성을 시도해보면 된다.
- 이를 피하기 위해선 복잡한 비밀번호 사용이나 비밀번호 만료 정책 외에는 실질적으로 없음.

#### 13.5.5 악의적인 프록시와 중간자 공격(Man-in-the-Middle Attack)(p.352)
- 만약 프록시 중 하나가 악의적이거나 보안이 허술하다면 클라이언트는 중간자 공격에 취약한 상태가 될 가능성이 있다.
- 이러한 공격은 엿듣기일 수도 있고, 가장 약한 인증 제도를 사용하도록 하는 것일 수도 있다.
- 여기서도 SSL을 사용하라고 하고 있다.

#### 13.5.6 선택 평문 공격(p.352)
- 자주 쓰이는 비밀번호 집합을 만들고, 난스와 함께 클라이언트에게 보내어 연산을 시킨다.
- 결과로 온 digest 중 기존 패킷에서 저장해둔 digest와 동일한 값이 있다면 이는 사용자의 비밀번호를 알아낸 것이다.
- 자동화된 무차별 대입 공격은 미리 계산된 digest와 맞춰보는 대신, 많은 컴퓨터를 동원해 가능한 모든 비밀번호를 시도해 보는 것이다.
- 이러한 공격들을 막으려면 복잡한 비밀번호를 사용하거나 적절한 비밀번호 만료 메커니즘을 사용해야한다.

#### 13.5.7 비밀번호 저장(p.353)
- 다이제스트 인증은 사용자 응답을 서버 내부에 저장된 것과 비교한다.
- 서버 내부에 저장된 다이제스트 인증 비밀번호 파일이 노출되면 해당 영역의 모든 문서는 공격자에게 노출된다.
- 이를 막기 위한 여러 방법들이다.
    - 다이제스트 비밀번호 파일은 평문 비밀번호 파일로 생각하고 안전하게 보호한다.
    - 보호 영역을 잘 나눠 비밀번호 파일이 누출되어도 피해를 최소화한다.
- 다이제스트 인증은 기본 인증에 비해 좋지만, 여전히 컨텐츠는 보호하지 못한다.
- 진정한 보안 트랜잭션은 다음장의 SSL을 통해서 달성 가능하다.


## 14장 보안 HTTP (p.355)
