## 13장 다이제스트 인증(p.331)
- 기본 인증은 편리하고 유연하지만 안전하지 않음.
- 기본 인증을 안전하게 이용하는 유일한 방법은 SSL과 결합해서 사용하는 것이다.
- 다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체제로서 개발되었음.
- **다이제스트 인증은 널리 쓰이지는 않지만, 그 개념은 보안 트랜잭션을 구현하고자 하는 이들에게 여전히 유용함.**

### 13.1 다이제스트 인증의 개선점(p.331)
- 기본 인증에 비해 다음과 같은 특징이 있다.
    - 비밀번호 평문 전송 X
    - 재현 공격 차단
    - (구현에 따라) 메시지 위변조 방지
    - 그 외 몇몇 잘 알려진 형태의 공격을 막는다.
- 다이제스트 인증이 좋은건 아니다. 오히려 HTTPS를 적용하는게 더 쉽고 강력하다. 다만 기본 인증보다는 낫다.

#### 13.1.1 비밀번호를 안전하게 지키기 위해 요약 사용하기(p.332)
- 다이제스트 인증은 클라이언트의 비밀번호를 비가역적(반대로 계산할 수 없는)으로 뒤섞은 요약(digest)를 전송한다.
- [그림 13-1]과 같은 동작을 거쳐서 문서를 요청 / 응답한다.

#### 13.1.2 단방향 요약(p.334)
- 요약은 단방향 함수로 동작하고, 일반적으로 입력 가능한 무한 가지의 모든 입력값들을 유한한 범위의 압축으로 변환한다.(**충돌**이 발생한다. - 비둘기집의 원리)
- 요약이라고 자꾸 얘기했는데, 사실 해시(Hash)를 이야기한다.
- 책에서는 MD5를 이야기하지만, MD5는 안전하지 않다. (너무 짧아서 충돌쌍을 찾기 쉽다.)

#### 13.1.3 재전송 방지를 위한 난스(nonce) 사용(p.335)
- 단순한 해시는 입력이 같다면 출력도 동일하다.
- 때문에 매번 같은 해시가 전송된다면 이 패킷을 재전송하여 클라이언트의 원래 비밀번호를 안 것과 같은 효과를 낼 수 있다.
- 이를 방지하기 위해 계속 바뀌는 값인 nonce를 서버에서 클라이언트로 주고, 클라이언트는 이 값을 포함하여 해시를 만들어야한다.
- 서버는 클라이언트의 비밀번호와 nonce를 알고 있기 떄문에 클라이언트가 보낸 해시와 nonce를 동일하게 계산하여 맞는 digest인지 확인한다.

#### 13.1.4 다이제스트 인증 핸드셰이크(p.335)
- [그림 13-2], [그림 13-3]을 참고하자.
- 특히 [그림 13-3]이 진짜 주고 받는 요청/응답이다. 뒤에 그 과정을 상세히 적어놓았다.

### 13.2 요약 계산(p.338) ~ 13.3.2 다이제스트 인증 헤더(p.347)
- 이러한 세부 사항보다는 맥락을 이해하는게 더 중요할 것 같다.

### 13.4 실제 상황에 대한 고려(p.347)
#### 13.4.1 다중 인증요구(p.348)
- 서버는 클라이언트의 능력을 모르기 때문에 하나의 리소스에 여러개의 인증 방식을 제공할 수 있다.
- 클라이언트를 개발하는 사람은 그중 가장 강력한 인증 방식을 사용해야한다.
- 서버 개발자는 기본 인증을 제한적으로만 사용하도록 해야한다.

#### 13.4.2 오류 처리(p.348)
- 다이제스트 인증에서 지시자나 그 값이 적절하지 않거나 요구된 지시자가 빠져 있으면 400 Bad Request를 응답해야한다.
- 로그인이 실패한 경우 이를 기록해야한다. 이는 공격자가 비밀번호를 추측하는 공격을 시도중일 수도 있다.

#### 13.4.3 보호 공간(Protection Space) (p.349)
- 보호공간 하위의 디렉토리는 모두 보호공간으로 인식한다.

#### 13.4.4 URI 다시 쓰기(p.349)
- 프록시는 가리키는 리소스의 변경없이 구문만 고쳐서 URI를 다시 쓰기도 한다.
- 예를들면 호스트명 정규화, IP 주소로 대체, %로 이스케이프 등등
- 다이제스트 인증은 URI 값의 무결성을 검사하므로 이러한 변경에 의해 실패할 수도 있다.

#### 13.4.5 캐시(p.350)
- 공유 캐시는 Authorization 헤더를 포함한 요청과 그 응답을 받은 경우, 다음 2가지 경우가 아니라면 캐시된 응답을 반환해선 안된다.
    - 원 서버 응답이 Cache-Control: must-revalidate인 경우 -> 잘 이해가 안가긴 함..
    - 원 서버의 응답이 Cache-Control: public인 경우 

### 13.5 보안에 대한 고려사항(p.350)
- RFC-2617 - https://tools.ietf.org/html/rfc2617

#### 13.5.1 헤더 부당 변경(p.350)
- 해더 부당 변경을 방지하려면 종단간 암호화나 헤더에 대한 디지털 서명이 필요하다.
- 다이제스트 인증이 데이터를 보호하는 것은 아니다!

#### 13.5.2 재전송 공격(p.350)
- 재전송 공격을 막는 유일한 방법은 매번 유일한 난스를 계속 변경하는 것이다.
- 이 계산은 서버 부하를 가중시킬 수도 있다.

#### 13.5.3 다중 인증 매커니즘(p.351)
- 클라이언트가 가장 강한 인증방식을 사용하도록 강제할 순 없으니 차선책은 가장 강력한 인증 방식을 사용하는 프록시 서버를 사용하는 것이다.
- 다만 이런 방식도 만만치 않다. 모든 클라이언트가 우리가 선택한 강력한 인증 제도를 지원할 수 있다고 알려져 있어야 함.

#### 13.5.4 사전(dictionary) 공격(p.351)
- 사전 공격은 전형적인 비밀번호 추측 공격이다.
- 단순한 비밀번호, 단순한 난스를 쓴다면 모든 가능성을 시도해보면 된다.
- 이를 피하기 위해선 복잡한 비밀번호 사용이나 비밀번호 만료 정책 외에는 실질적으로 없음.

#### 13.5.5 악의적인 프록시와 중간자 공격(Man-in-the-Middle Attack)(p.352)
- 만약 프록시 중 하나가 악의적이거나 보안이 허술하다면 클라이언트는 중간자 공격에 취약한 상태가 될 가능성이 있다.
- 이러한 공격은 엿듣기일 수도 있고, 가장 약한 인증 제도를 사용하도록 하는 것일 수도 있다.
- 여기서도 SSL을 사용하라고 하고 있다.

#### 13.5.6 선택 평문 공격(p.352)
- 자주 쓰이는 비밀번호 집합을 만들고, 난스와 함께 클라이언트에게 보내어 연산을 시킨다.
- 결과로 온 digest 중 기존 패킷에서 저장해둔 digest와 동일한 값이 있다면 이는 사용자의 비밀번호를 알아낸 것이다.
- 자동화된 무차별 대입 공격은 미리 계산된 digest와 맞춰보는 대신, 많은 컴퓨터를 동원해 가능한 모든 비밀번호를 시도해 보는 것이다.
- 이러한 공격들을 막으려면 복잡한 비밀번호를 사용하거나 적절한 비밀번호 만료 메커니즘을 사용해야한다.

#### 13.5.7 비밀번호 저장(p.353)
- 다이제스트 인증은 사용자 응답을 서버 내부에 저장된 것과 비교한다.
- 서버 내부에 저장된 다이제스트 인증 비밀번호 파일이 노출되면 해당 영역의 모든 문서는 공격자에게 노출된다.
- 이를 막기 위한 여러 방법들이다.
    - 다이제스트 비밀번호 파일은 평문 비밀번호 파일로 생각하고 안전하게 보호한다.
    - 보호 영역을 잘 나눠 비밀번호 파일이 누출되어도 피해를 최소화한다.
- 다이제스트 인증은 기본 인증에 비해 좋지만, 여전히 컨텐츠는 보호하지 못한다.
- 진정한 보안 트랜잭션은 다음장의 SSL을 통해서 달성 가능하다.


## 14장 보안 HTTP (p.355)
### 14.1 HTTP를 안전하게 만들기(p.355)
- 기본 인증과 다이제스트 인증은 충분히 강력하지 않음. 보다 중요한 트랜잭션을 위해서는 HTTP와 디지털 암호화 기술이 결합되어야 한다.
- HTTP 보안 기술은 다음과 같은 것들을 우리에게 제공해줄 수 있어야한다.
    - 서버 인증 : 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야 한다.
    - 클라이언트 인증 : 서버가 클라이언트가 진짜인지 알 수 있어야 한다.
    - 무결성
    - 암호화
    - 효율
    - 편재성 : 거의 모든 클라이언트와 서버에서 지원되어야 한다.
    - 관리상 확장성
    - 적응성
    - 사회적 생존성

#### 14.1.1 HTTPS(p.356)
- HTTPS는 HTTP를 안전하게 만드는 방식 중에서 가장 인기 있는 것이다.
- URL 스킴이 http:// 대신 http**s**://로 시작하는 것을 보고 알 수 있다.
- SSL -> TLS 를 합쳐 SSL이라고 책에서는 표현한다고 한다.
- [그림 14-2]를 보면 HTTP와 HTTPS의 레이어 차이를 보여준다.
- **어려운 인코딩 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에 웹 클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요가 없다.**

### 14.2 디지털 암호학(p.357)
- 여기선 암호, 키, 대칭키 암호체계, 비대칭키 암호체계, 공개키 암호법, 디지털 서명, 디지털 인증서 등에 대해 설명함.
- 이미 해당 내용에 익숙하여 14.7로 건너 뜀. 발표 걸리면 책 보고 설명드리겠습니다.

### 14.7 HTTPS의 세부사항(p.372)
- HTTPS는 HTTPS의 가장 유명한 보안 버전이다. 주류 상용 브라우저와 서버에 구현되어 있다.

#### 14.7.1 HTTPS 개요(p.373)
- HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP이다.
- [그림 14-13]에 [그림 14-2]가 또 나옴.

#### 14.7.2 HTTPS 스킴(p.373)
- http -> 80 port
- https -> 443 port

#### 14.7.3 보안 전송 셋업(p.374)
- HTTP와 HTTPS의 트랜잭션 차이를 보여주는 그림이 [그림 14-15]이다.
- HTTPS의 2, 5 번째 과정이 추가된 거라고 보면 된다.

#### 14.7.4 SSL 핸드셰이크(p.376)
- [그림 14-15]의 HTTPS 2번 과정에서 SSL 핸드셰이크를 한다.
- 이 과정은 다음과 같은 정보를 교환한다.
    - 프로토콜 버전 번호 교환
    - 양쪽이 알고 있는 암호 선택
    - 양쪽의 신원 인증
    - 채널을 암호화하기 위한 임시 세션 키 생성
- 이 과정은 [그림 14-16]에 나와있다.

#### 14.7.5 서버 인증서(p.377)
- HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.
- 서버 인증서에는 인증서 일련번호, 유효기간, 서버의 조직명, 서버 host명, 공개키, 인증서 발급자 이름, 인증서 발급자 서명 등이 포함된다. (X.509 v3에서 파생된 인증서 형태)

#### 14.7.6 사이트 인증서 검사(p.378)
- SSL 자체는 사용자에게 웹 서버 인증서를 검증할 것 을 요구하지는 않지만, 웹 브라우저들은 인증서에 대한 검사를 실시한다.
- 다음 과같은 절차를 거쳐서 인증서를 검사한다.
    - 날짜 검사 : 인증서의 유효 기간을 검사한다.
    - 서명자 신뢰도 검사 : 인증서를 발급한 기관(CA)가 적절한지 확인한다.
    - 서명 검사 : 서명 기관의 공개키를 서명에 적용하여 그 인증서의 무결성을 검사한다.
    - 사이트 신원 검사 : 서버의 호스트명과 인증서의 호스트명이 동일한지 확인한다.

#### 14.7.7 가상 호스팅과 인증서(p.379)
- 가상 호스팅 환경에 있는 사이트의 보안 트래픽ㅇ르 다루는 것이 까다로운 경우도 많다.
- 인기 있는 웹 서버 프로그램에서 오직 하나의 인증서만을 지원하는 경우 사용자 입장에서는 호스트 명이 다를 것이다.
- 이러한 문제를 피하기 위해 책에서는 보안 트랜잭션을 시작하는 경우 인증서에 명시된 host명에 맞도록 리다이렉트를 하는 방법을 제안하고 있다.
- [그림 14-18] 참고

### 14.8 진짜 HTTPS 클라이언트(p.379)
- SSL은 복잡한 바이너리 프로토콜이다. SSL 트래픽을 보내고 싶다면 SSL 클라이언트와 서버를 구현해놓은 라이브러리를 이용하라.

#### 14.8.1 OpenSSL(p.379)
- OpenSSL은 SSL과 TLS의 가장 인기 있는 오픈 소스 구현임.

#### 14.8.2 간단한 HTTPS 클라이언트(p.381)
- C언어로 작성된 SSL 클라이언트를 간단히 보여주고 있다.
- 각종 예외 처리가 없기 떄문에 이해를 위한 용도로만 보면 될듯.

#### 14.8.3 우리의 단순한 OpenSSL 클라이언트 실행하기(p.384)
- 14.8.2에서 작성한 HTTPS 클라이언트로 요청을 보내보고 있다.

### 14.9 프록시를 통한 보안 트래픽 터널링(p.386)
- 클라이언트는 종종 그들을 대신하여 웹 서버에 접근해주는 웹 프록시 서버를 이용한다.
- 클라이언트가 서버로 보내는 데이터를 암호화 했다면, 프록시는 더 이상 HTTP 헤더를 읽을 수 없다. 이러면 프록시는 어디로 요청을 포워딩 해야하는지 알 수 없어진다.
- HTTPS에서도 프록시가 잘 동작하게 할 수 있으려면 클라이언트가 어디에 접속하려는지 프록시에게 알려주기 위한 방법을 약간 수정해야한다.
- 인기 있는 기법 중에 하나는 HTTPS SSL 터널링임. 암호화가 시작되기 전에 어디로 연결하고 싶은지 호스트 정보를 알려주는 것이다.
- 주로 CONNECT 메소드를 이용하여 전송한다고함.
```
CONNECT home.netscape.com:443 HTTP/1.0
User-agent: Mozilla/1.1N

<SSL로 암호화한 데이터>
```
