
## 13장 다이제스트 인증
 - 다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체재로서 개발됨. ( 주로 쓰이지는 않음 )
  
### 13.1 다이제스트 인증의 개선점
 - 다이제스트 인증은 기본 인증의 가장 심각한 결함을 수정한 또 다른 HTTP 인증 프로토콜이다.
 - 다이제스트 인증의 특징은 다음과 같다.
   - 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.
   - 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다.
   - 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다.
   - 그 외 몇몇 잘 알려진 형태의 공격을 막는다.
- 기본인증보다는 안전하지만 실 서비스에는 TLS와 HTTPS가 더 적합하다.

#### 13.1.1 비밀번호를 안전하게 지키기 위해 요약 사용하기
 - "절대로 비밀번호를 네트워크를 통해 보내지 않는다." -> 비밀번호 대신 클라이언트는 지문(fingerprint) 혹은 요약(digest)를 보낸다. -> 클라이언트와 서버는 둘 다 비밀번호를 알 고 있으므로, 서버는 클라이언트가 보낸 요약이 비밀번호에 알맞게 대응하는지 쉽게 검사 할 수 있다.  ( p333. 그림 13-1 참고 )

#### 13.1.2. 단방향 요약
 - 요약은 단방향 함수로 동작한다. 
 - ex ) MD5, SHA256, SHA512.. 등등
 - MD5는 임의의 바이트 배열을 원래 길이와 상관 없이 128요약으로 변환한다. (32글자의 16진수로 표현된다. )
 - MD5 암호화 사이트 : https://www.convertstring.com/ko/Hash/MD5


#### 13.1.3 재전송 방지를 위한 난스(nonce) 사용 - salt ?
 - md5(비밀번호 + 난스 ) = 12345  -> 복호화를 해도 난스가 뭔지 모르므로 비밀번호를 유츄하기 쉽지 않다. -> 브루트 포스로 공격할 수 도 있으므로 난스를 자주 바꿔준다. 
  - 회원 비밀번호 관리 프로세스
    - 1. 입력받은 비밀번호에 random salt를 추가해 암호화 한다.
    - 2. 1에서 암호화된 값과 random salt를 디비에 저장한다.
    - 3. 비밀번호 인증할때는 유저가 입력한 비밀번호와 salt를 더해서 암호화 한 값이 디비에 저장된 암호화된 암호와 같은지 비교한다.
- 난스는 WWW-Authenticate 인증요구에 담겨서 서버에서 클라이언트로 넘겨진다. 서버와 클라이언트가 같은 난스로 암호화를 진행한다.

#### 13.1.4 다이제스트 인증 핸드셰이크
 - HTTP 다이제스트 인증 프로토콜은 기본 인증에서 사용하는 것과 비슷한 헤더를 사용하는, 강화된 버전의 인증이다. ( 비밀번호를 보내지 않는다. -> 난스를 추가해 digest된 결과를 보낸다. )
 - 기존 헤더에 몇몇 새 옵션이 추가되었고, 선택적인 헤더인 Authorization-Info가 새로 추가되었다. ( p.336 그림 13-2, 13-3 참조 )


### 13.2 요약 계산
 - 다이제스트 인증의 핵심은 공개된 정보, 비밀 정보, 시한부 난스 값을 조합한 단방향 요약이다. ( 공개된 nonce와 개인 비밀번호 그리고 자주 바뀌는 nonce값. nonce가 바귈때 마다 인증을 다시해줘야 되는건지 ? )
 - 부록 F에 샘플 소스 확인.

#### 13.2.6 다이제스트 인증 세션
 - 어떤 보호 공간을 위한 WWW-Authenticate 인증요구에 대한 클라이언트 응답은, 그 보호 공간에 대한 인증 세션을 시작하게 한다.
 - 인증 세션은 클라이언트가 보호 공간의 다른 서버로부터 또 다른 WWW-Authenticate 인증요구를 받을 때 까지 지속된다.
 - 난스가 만료되면, 서버는 포함된 난스 값이 낡은 것일 수 있음을 감수하고 오래된 Authorization 헤더 정보를 받아들이는 것을 택할 수 있다.
 - 아니면, 서버는 클라이언트가 다시 요청을 보내도록 새난스 값과 함께 401 응답을 반환할 수 도 있다.
 - 이때, 이 응답에 "stale=true"로 정의함으로써 서버는 클라이언트에게 사용자 이름과 비밀번호를 새로 입력하도록 창을 띄울 필요 없이 새 난스 값으로 요청을 다시 보내라고 말해줄 수 있다.

#### 13.2.7 사전(preemptive) 인가
 - 일반적은 인증에서는, 각 요청은 트랜잭션이 완료되기 전에 요청/인증요구 사이클을 필요로 한다.  ( p342 그림 13-4 참고 )
 - 만약, 클라이언트가 요청을 받기 전에 Authorization 헤더를 계산 할 수 있다면 클라이언트는 요청/인증요구 단계를 거치지 않고 미리 Authorization 헤더를 서버에 제공한다. ( 성능 개선 효과 - p342. 13-4b )
 - 다이제스트 인증에서의 사전 인가는 좀 더 복잡한 로직을 갖는다. 왜냐하면, 서버는 임의의 난스를 짧은 주기간격으로 생성하는데, 이는 인증요구를 받기 전에는 클라이언트가 무엇이 올바른 Authorization 헤더인지 알 방법이 없다.
 - 다이제스트 인증은 사전 인가를 할 수 있는 몇 가지 방법을 제안한다.
   - 서버가 다음 난스를 Authentication-Info 성공 헤더에 담아서 미리 보낸다.
   - 서버가 짧은 시간 동안 같은 난스를 재사용하는 것을 허용한다.
   - 클라이언트와 서버가 동기화 되어있고 예층 가능한 난스 생성 알고리즘을 사용한다.

##### 다음 난스 미리 생성하기
 - 서버는 Authentication-Info 성공 헤더를 통해 다음 난스 값을 미리 제공할 수 있다.
 - 서버는 인증이 성공했을 때 200 OK 응답과 함께 이 헤더를 미리 보낸다.
```
    Authentication-Info: nextnonce=<"난스 값>"
```
 - 주어진 다음 난스로 클라이언트는 Authorization 헤더를 미리 만들어 둘 수 있다.

##### 제한된 난스 재사용
 - 난스의 유효시간을 늘린다. ( 난스를 재사용하면 공격자의 재전송 공격이 성공하기 쉬워지므로 보안성이 감소된다. )

##### 동기화된 난스 생성
 - 클라이언트와 서버가 공유된 비밀키에 기반하면서 클라이언트와 서버가 순차적으로 같은 난스를 생성할 수 있도록 시간적으로 동기화된 난스 생성 알고리즘을 사용한다.
  
#### 13.2.8 난스 선택
 - 타임스탬프, ETag, 개인키의 조합으로 생성한다.
 - 타임스탬프 : 서버에서 생성된 시간
   - 타임스탬프가 오래 되었다면 서버가 거절할 수 있다.
 - ETag : 요청된 엔터티에 대한 ETag의 헤더값
   - ETag를 포함하면 갱신된 리소스에 대한 재요청을 방지한다. ? 먼소리지?
 - 개인키 : 서버만이 알고 있는 값 

#### 13.2.9 상호 인증
 - 서버가 클라이언트를 인증하는것 뿐 아니라 반대로 클라이언트도 서버를 인증한다.
 - RFC 2617은 클라이언트가 서버를 인증할 수 있도록 다이제스트 인증을 확장했다. 이는 서버가 공유된 비밀 정보에 근거한 올바른 응답 요약을 생성할 수 있도록, 클라이언트 난스 값을 제공함으로써 가능해진다. 이후 서버는 이 요약을 Authentication-Info 헤더를 통해 클라이언트에게 전달한다.

### 13.4 실제 상황에 대한 고려

#### 13.4.1 다중 인증요구
 - 다중 인증요구에 직면했을 때, 클라이언트는 반드시 자신이 지원할 수 있는 가장 강력한 인증 메커니즘을 선택해야 한다.
 - 서버는 기본 인증을 제한적으로만 사용해야 한다. ( 보안에 취약함 )

#### 13.4.2 오류 처리
 - 다이제스트 인증에서, 지시자나 그 값이 적절하지 않거나 요구된 지시가 빠졌거나, 요청의 요약이 맞지 않다면 400 Bad Request를 날려야 한다. ( 클라 에러 )
- 또한, 요청의 요약이 맞지 않는 경우 로그인 실패 기록해 두는것이 좋다. 반복된 공격일 가능성이 있음. ( ex. 로그인 5회 실패시 30분뒤 로그인 가능하게 하기..등)

### 13.5 보안에 대한 고려사항
#### 13.5.1 헤더 부당 변경
 - 헤더 부당 변경에 대해 항상 안전한 시스템을 제공하기 위해서, 양 종단 암호화나 헤더에 대한 디지털 서명이 필요하다.
#### 13.5.2. 재전송 공격
 - 서버가 재전송된 자격을 승인했다는 것은, 요청들이 난스 값을 재사용한 것이다. 이 문제에 대한 해결책 중 한가지는 클라이언트의 IP주소, 타임스탬프, 리소스의 ETag, 개인 키를 포함하는 난스를 서버가 생성하도록 하는 것이다. ( 프락시를 타거나, IP를 우회해서 IP 변경을 할 수도 있음. )
 - 재전송 공격을 완전히 피할 수 있는 방법은 매 트랜잭션마다 유일한 난스 값을 사용하는 것이다. 
#### 13.5.3. 다중 인증 메커니즘
 - 서버가 다중 인증 제도를 지원할 때, 클라이언트는 언제나 가능한 가장 강력한 인증 제도를 선택해야 한다.
#### 13.5.4 사전 공격
 - 사전 공격은 전형적인 비밀번호 추측 공격이다. ( 가능한 조합을 모두 해보는 거? )
 - 비밀번호를 길게, 특수문자를 포함시켜서 복잡하게 만든다. 또한, 비밀번호를 주기적으로 변경해준다.
#### 13.5.5 악의적인 프락시와 중간자 공격
 - 만약, 클라이언트 -> 프락시 A -> 프락시 B -> 서버로 데이터가 전달될때 이들 프락시 중 하나가 악의적이거나 보인이 허술하다면 클라이언트는 중간자 공격에 취약한 상태가 될 가능성이 있다.
 - 이러한 공격은 엿듣기 공격일 수도 있고, 혹은 인증 제도 선택지를 모두 제거하고 기본 인증과 같이 가장 약한 인증 제도로 대체하는 것일 수도 있다.
 - 해당 공격을 방어할 수 있는 유일한 방법은 ssl을 사용하는 것이다.
#### 13.5.6 선택 평문 공격
 - 트래픽 중간에 끼어들어 난스를 탈취한다. 난스를 알고있으니 암호 해독을 쉽게 할 수 있다 ?
 - 미리 계산된 사전 공격
   - 사전 공격과 선택 평문 공격의 조합이다.
   - 
 - 자동화된 무차별 대입 공격
 - 
#### 13.5.7 비밀번호 저장
 - 다이제스트 인증 비밀번호 파일이 유출되면 영역의 모든 문서는 공격자에게 노출된다. 암호 해독 과정은 필요없다. ( 다이제스트 인증은 암호 자체를 네트워크로 보내지 않기 때문에 암호를 암호화해서 저장하지 않는건가 ? )
 - 이 문제를 완화하는 몇가지 방법이 있다.
   - 비밀번호가 평문으로 저정되어있으니 안전하게 보호한다.
   - 영역 이름이 유일함을 보장하며, 비밀번호 파일이 유출되더라도 피해를 특정 영역으로 국소화한다.

## 14장. 보안 HTTP
### 14.1 HTTP를 안정하게 만들기
 - 인증 ( 기본, 다이제스트 인증 ), 메시지 무결성은 대체로 쓸만하지만 보안적으로 충분히 강력하지 않다. -> HTTPS를 사용하자.
#### 14.1.1 HTTPS
 - HTTPS 란 ?  
 - HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화 된다. ( SSL 계층에서 암호화됨 - P.357 그림 14-2) 

### 14.2 디지털 암호학
#### 14.2.4 키가 있는 암호
 - 디코딩 과정을 바르게 동작시키려면 올바른 키를 암호 기계에 입력해야 한다. ( 기기만 있다고 기기를 동작시킬 수 없고, 키가 있어야 한다. )
#### 14.2.5 디지털 암호
 - 기계 장치의 물리적인 금속 키나 다이얼 설정과는 달리, 디지털 키는 그냥 숫자에 불과하다. 이들 디지털 키는 인코딩과 디코딩 알고리즘에 대한 입력값이다.

#### 14.3 대칭키 암호법
 - 인코딩할때 키와 디코딩 할때 키가 같다. ( 대칭적이다. )
 - 키를 공개하면 안된다. ( 통신을 하는 클라이언트, 서버만 가지고 있어야한다. )
 - ex) DES, Triple-DES, RC2, RC4..등

#### 14.3.2 공유키 발급
 - 대칭키 암호는 발송자와 수신자가 서로 같은 공유키를 가져야 한다.
 - 대칭키의 경우 N명과 통신하려면 N개의 키가 필요하다. 따라서, 서버 입장에서는 키 관리가 힘들 수 있다.

### 14.4 공개키 암호법 ( = 비대칭키 )
 - 공개키 암호 방식은 두 개의 비대칭 키( 암호화키, 복호화키)를 사용한다. ( 암호화키를 공개하고 복호화 키를 서버만 가지고 있는다. 해당 키의 복호화 키를 가지고 있는 서버만이 복호화가 가능하다. ) -> 공개키 암호화 방식은 N명과 통신을 위해서 키를 1개만 발급하면 된다. ( p. 365 그림 14-9 참고 )
 - 키의 분리는, 메시지의 인코딩은 누구나 할 수 있도록 해주는 동시에, 메시지를 디코딩하는 능력은 소유자에게만 부여한다. ( A 서버에게 데이터를 보내고 싶으면 데이터를 A서버의 공개키로 암호화해 보내면 A서버는 자신의 개인키로 해당 암호를 푼다.)

#### 14.4.1 RSA
 - 공개키
 - 가로채서 얻은 암호문의 일부
 - 메시지와 그것을 암호화한 암호문

#### 14.4.2 혼성 암호 체계와 세션 키
 - 비대칭 키 공개키 암호 방식은 공개키만 알면 그 키에 대응되는 공개 서버에 안전하게 메시지를 보낼 수 있다. 이는 두 노드가 안전하게 연결하려고 할 때 개인 키에 대한 협상을 먼저할 필요가 없다.
 - 그러나, 공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있다. 실제로는 대칭과 비대칭 방식을 섞어서 사용한다. ( 처음 채널을 수립할때는 공개키, 채널 수립이 되고 실제 데이터를 보낼때는 대칭키 )
   - 노드들 사이의 안전한 채널을 수립할 때는 공개 키를 사용한다.
   - 안전한 채널을 통해 임시의 무작위 대칭 키를 생성하고 교환하여 이후 나머지 데이터를 암호화 할 때는 빠른 대칭 키를 사용한다.

### 14.5 디지털 서명
 - 암호 체계는 메시지를 암호화하고 해독하는 것뿐 아니라, 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지를 서명한다. ( 디지털 서명 )

#### 14.5.1 서명은 암호 체크섬이다.
 - 디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬이다.
 - 이는 두 가지 이점을 가진다.
   - 서명은 메시지를 작성한 저자가 누군지 알려준다.
   - 서명은 메시지 위조를 방지한다.

- 디지털 서명은 보통 비대칭 공개키에 의해 생성된다. 개인 키는 오직 소유자만이 알고 있기 때문에, 저자의 개인 키는 일종의 '지문'처럼 사용된다.
- 서명하는 과정 ( P. 367 그럼 14-10 참고 )

### 14.6 디지털 인증서
 - 디지털 인증서는 신뢰할 수 있는 기관으로부터 보증 받는 사용자나 회사에 대한 정보를 담고 있다. ( P.370 그림 14-11 참고 )
- 인증서 내부에는 
  - 대상의 이름 (사람, 서버, 조직 등)
  - 유효 기관
  - 인증서 발급자
  - 인증서 발급자의 디지털 서명
  - 대상의 공개키

#### 14.6.3 서버 인증을 위해 인증서 사용하기
 - 사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다. 만약, 서버가 인증서를 가지고 있지 않으면 커넥션은 실패한다.
 - 서버 인증서는 다음을 포함한 만은 필드를 갖고 있다.
   - 웹 사이트의 이름과 호스트 명
   - 웹 사이트 공개키
   - 서명 기관의 이름 ( 해당 키가 유효하다고 인증해주는 주체)
   - 서명 기관의 서명

- 브라우저가 인증서를 받으면, 서명 기관을 검사한다. 만약, 그 기관이 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를 이미 알고있을 것이며 ( 브라우저들은 여러 서명 기관의 인증서가 미리 설치된 채로 출하된다.), 브라우저는 그 서명을 검증할 수 있다. ( 공개키를 알고있는데 서명을 어떻게 검증함 ?  - P.372 그림 14-12 -> 질문)

### 14.7 HTTPS의 세부사항
#### 14.7.1 HTTPS 개요
 - HTTPS는 보안 전송 계층(SSL)을 통해 전송되는 HTTP이다. 
 - HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보낸다. ( P.373 그림 14-13)
#### 14.7.2 HTTPS 스킴
 - HTTPS 프로토콜에서 URL의 스킴 접두사는 https 이다.
 - 만약, URL이 https 스킴을 갖고 있다면, 클라이언트는 서버에 443 포트로 연결하고 서버와 바이너리 포멧으로 된 몇몇 SSL 보안 매개변수를 교환하며 "핸드셰이크"를 한다.

##### 14.7.3 보안 전송 셋업
 - P.375 그림 14-15 참고

#### 14.7.4. SSL 핸드셰이크
 - 암호화된 HTTP 메시지를 보낼 수 있게 되기 전에, 클라이언트와 서버는 SSL 핸드 셰이크를 할 필요가 있다.
   - 프로토콜 버전 교환
   - 양쪽이 알고 있는 암호 선택
   - 양쪽의 신원을 인증
   - 채널을 암호화하기 위한 임시 세션 키 생성

- 암호화된 HTTP 데이터가 네트워크를 오가기도 전에, SSL은 통신을 시작하기 위해 상당한 양의 핸드셰이크 데이터를 주고 받는다. ( P.376 그림 14-16 참고 )

##### 14.7.5 서버 인증서
 - SSL은 서버 인증서를 클라이언트로 전달하고 다시 클라이언트 인증서를 서버로 전달해주는 상호 인증을 지원한다. ( 클라이언트 인증은 쓰이지 않음. -> 대부분의 사용자는 개인 클라이언트 인증서를 가지고 있지 않을 뿐더러, 서버가 클라이언트 인증서를 요구할 수도 있지만, 실제로는 거의 그렇게 하지 않는다. )
 - 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.
 - 서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름, 그리고 그 외의 정보를 보여주는, X.509 V3에서 파생된 인증서이다. ( p. 377. 그림 14-17 참고 )

#### 14.7.6 사이트 인증서 검사
 - 최신 웹 브라우저들 대부분은 인증서에 대해 간단하게 기본적인 검사를 하고 그 결과를 더 철저한 검사를 할 수 있는 방법과 함께 사용자에게 알려준다. 

##### 날짜 검사
  - 브라우저는 인증서가 여전히 유효함을 확인하기 위해 인증서의 시작 및 종료일을 검사한다. 만약, 인증서가 만료되었거나 아직 활성화 되지 않았다면, 인증서 검사는 실패하고 브라우저는 에러를 보여준다.
##### 서명도 신뢰도 검사
 - 모든 인증서는 서버를 보증하는 어떤 인증 기관(CA)에 의해 서명되어 있다. 이러한 이유로, 브라우저는 신뢰할 만한 서명 기관의 목록을 포함한 채로 배포된다.
 - 만약, 브라우저가 알려져 있지 않은 인증기관으로 부터 서명된 인증서를 받았다면, 브라우저는 보통 경로르 준다. ( 안전하지 않은 페이지 입니다.)
 - 브라우저는 또한 신뢰할 만한 CA가 간접적으로 서명한 인증서를 받아들이는 것을 선택할 수 있다. ( CA가 A사이트의 인증서를 서명하고 A사이트가 B사이트의 인증서를 서명한다면 B사이트의 인증서는 CA로부터 파생된 것으로 받아 들어진다. )
##### 서명 검사
 - 한번 서명 기관이 믿을 만하다고 판단하면, 브라우저는 서명기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄을써 인증서의 무결성을 검증한다.
##### 사이트 신원 검사
 - 대부분의 브라우저는 인증서의 도메인 이름이 대화 중인 서버의 도메인 이름과 비교하여 맞는지 검사한다. 

#### 14.7.7 가상 호스팅과 인증서
 - 가상 호스트(하나의 서버에 여러 호스트 명)로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우가 많다. ( 사이트 신원 검사에 걸릴 수 있음. ) -> 허용된 인증서 도메인으로 리다이렉트 한다.

### 14.8 진짜 HTTPS 클라이언트
#### 14.8.1 OpenSSL
 - OpenSSL은 SSL과 TLS의 가장 인기 있는 오픈소스이다.
 - OpenSSL를 통해 나만의 인증서를 만들 수 있다. ( 그러나, ca인증이 안되어 있으므로 안전하지 않음이라고 표시 될것이다. - 브라우저에 명시적으로 ca를 등록해줄 수는 있지만 수동으로 등록해준 브라우저 에서만 효력이 있음.)
 - 인증서를 만드는 과정
   - 1. 개인키 생성 : openssl genrsa -out private.key 2048
   - 2. 공개키 생성 : openssl rsa -in private.key -pubout -out public.key
   - 3. CSR 생성 ( 인증서 서명 요청 ) - 개인키를 통해 인증서 서명 요청 파일을 생성
     - openssl req -new -key private.key -out private.csr 
   - 4. CRT 인증서 만들기 : openssl req -x509 -days 365 -key private.key -in private.csr -out test.crt -days 365

- 서버 설정
  - ca, 개인키, 인증서를 설정해 둬야 되지만 ca가 없다.. 그렇기 때문에 SSC(Self Signed Certicate를 해준다.)
  -  SSC란 : 모든 인증서는 발급기관 (CA)가 있어야 하나 최상위에 있는 인증기관 (ROOT CA)는 서명해줄 상위 인증기관이 없으므로 root ca의 개인키 스스로의 인증서에 서명하여 최상위 인증기관 인증서를 만든다. 즉, 이렇게 되면 인증서를 발급하는 주체와 인증서를 인증하는 주체가 같아진다. 
  -> Openssl로 만든 ROOT CA와 SSL 인증서는 브라우저가 모르는 기관이 발급한 인증서 이므로 보안 경고를 발생시킨다. 수동으로 추가해줄 수는 있다.
  - 따라서, openssl은 테스트 용도로만 쓰자.. 실제 서비스라면 물론 인증서를 구매해서 써야되지만 poc정도라면 무료 ssl 라이브러리인 let's encrypt를 사용해도 괜찮을 거 같음. 단, let's encrypt는 도메인이 필요하다.

### 14.9 프락시를 통한 보안 트래픽 터널링
 - 클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화하기 시작 했다면, 프락시는 더 이상 HTTP 헤더를 읽을 수 없다. ( 복화하는 개인키를 가지고 있는 서버만 가능하다..)
 - 그리고, 만약 프락시가 HTTP 헤더를 읽을 수 없다면, 프락시는 요청을 어디로 보내야 하는지 알 수 없게 된다. ( p. 387 그림 14-20 )
 - HTTPS 가 프락시와도 잘 동작할 수 있게 하기 위해, 클라이언트가 프락시에게 어디에 적속하려고 하는지 말해주는 방법을 수정해야 한다. ( HTTPS SSL 터널링 )