
# 7장 캐시

## 1. 불필요한 데이터 전송

- 캐시를 이용하면 첫번째 서버 응답은 캐시에 보관된다. 
- 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용될 수 있기 때문에 트래픽을 주고받는 낭비가 줄어든다.

## 2. 대역폭 병목

- 네트워크 병목을 줄여준다. 
- 캐싱은 성능을 대폭 개선할 수 있다. 

## 3. 갑작스런 요청 쇄도 (Flash Crowds)

- 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다.
- 많은 사람이 거의 동시에 웹 문서에 접근할 때 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 일으킴

## 4. 거리로 인한 지연

- 거리가 문제가 될 수 있다. 
- 근처에 캐시를 설치해서 문서가 전송되는 거리를 수천킬로미터에서 수십미터로 줄일 수 있다

## 5. 적중과 부적중

- 위와같이 캐시는 유용하지만 캐시가 세상 모든 문서의 사본을 저장하지는 않는다. 
- 캐시에 요청이 도착했을 때, 
  만약 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리 되는 것을 캐시 적중(cache hit) 이라 하고 
  만약 대응하는 사본이 없다면 그냥 원 서버로 전달되기만 할 뿐 이것을 캐시 부적중(cache miss)이라 한다. 
  

#### 1. 재검사(Revalidation)

- 콘텐츠는 변경 될 수 있기 때문에, 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 한다. = 신선도 검사 = HTTP 재검사
- 캐시는 스스로 원한다면 언제든지 사본을 재검사 할 수 있고
  대부분의 캐시는 클라이언트가 사본을 요청하였으며, 그 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사를 한다. 
- If-Modified-Since헤더
  - HTTP가 캐시된 객체를 재확인하기 위해 제공하는 도구 중 가장 많이 쓰이는 것
  - 서버에게 보내는 GET 요청에 해당 헤더를 추가하면 
    캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미
- GET If-Modified-Since 요청이 서버에 도착했을 때 일어날 수 있는 세가지 경우
  1. 서버 객체가 변경되지 않은 경우
     - 재검사 적중
     - HTTP 304 Not Modified 응답
  2. 서버 객체가 캐시된 사본과 다른경우
     - 재검사 부적중
     - HTTP 200 OK
  3. 객체 삭제
     - 404 Not Found 
  

#### 2. 적중률

- 캐시가 요청을 처리하는 비율
- 캐시 적중률 or 캐시 적중비 or 문서 적중률 or 문서 적중비 라고 함
- 0%는 모든 요청이 캐시 부적중 , 100%는 모든 요청이 캐시 적중을 의미
- 오늘날에는 적중률 40%면 괜찮은 편



#### 3. 바이트 적중률

- 문서 적중률은 몇몇 큰 객체는 덜 접근되지만 그 크기 때문에 전체 트래픽에는 더 크게 기여한다. 이런 이유로 바이트 단위 적중률 측정값을 더 선호 한다.
  - 이 측정값은 트래픽이 절감된 정도를 포착
- 바이트 단위 적중률 100%
  - 모든 바이트가 캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미
- 문서 적중률은 얼마나 많은 웹 트랜잭션으로 외부로 내보내지 않았는지를 보여주고
  바이트 단위 적중률은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여준다.
  

#### 4.적중과 부적중의 구별

- 클라이언트가 응답이 캐시에서 왔는지 알아내는 한가지 방법은 
  응답의 Date 헤더 값을 현재 시간과 비교하여, 응답의 생성일이 더 오래되었다면
  클라이언트는 응답이 캐시된 것임을 알 수 있다
  

## 6. 캐시 토폴로지

토폴로지(topology) - 컴퓨터 네트워크의 요소들(링크, 노드 등)을 물리적으로 연결해 놓은 것, 또는 그 연결 방식.
	출처: 위키백과

#### 1. 개인 전용 캐시

- 한명에게만 할당된 캐시
- 많은 에너지가 저장공간을 필요로 하지 않으므로 작고, 저렴할 수 있다. 
- 웹 브라우저는 개인 전용 캐시를 내장하고 있다 (인터넷 옵션> 검색기록> 설정 같은데서 캐시 확인가능)

#### 2. 공용 프락시 캐시

- 공유된 캐시
- 캐시 프락시 서버 or 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버다  
- 자주 찾는 객체를 단 한 번만 가져와 , 모든 요청에 대해 공유된 사본을 제공함으로써 네트워크 트래픽을 줄임
  

#### 3. 프락시 캐시 계층들

- 작은 캐시에서 캐시 부적중이 발생했을 때
  더 큰 부모 캐시가 그 '걸러 남겨진' 트래픽을 처리하도록 하는 계층을 만드는 방식이 더 합리적인 경우가 많다
- 클라이언트 주위에는 작고 저렴한 캐시를 사용하고
  계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용하는 것
- 가까운 1단계 캐시에서 적중을 얻고 , 그렇지 못했다면 더 큰 부모 캐시가 사용자의 요청을 처리 할 수 있을 것
  (p196 그림 7-9)



#### 4. 캐시망, 콘텐츠 라우팅, 피어링

- 몇몇 네트워크 아키텍처는 복잡한 캐시망을 만든다.
- 캐시망의 프락시 캐시는 캐시 커뮤니케이션 결정을 동적으로 내린다. 
  - 어떤 부모 캐시와 대화 할 것인지
  - 요청이 캐시를 완전히 우회해서 원서버로 바로 가도록 할 것인지 
  - 특정 부모 캐시를 동적으로 선택
    등등
  
  

## 7. 캐시 처리 단계

캐시 처리 플로차트에 요약되서 설명 되어 있다 

p201 그림 7-12

#### 1. 단계 1:요청 받기

- 네트워크 커넥션에서의 활동을 감지하고 들어오는 데이터를 읽어들인다. 
- 고성능 캐시는 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작한다.

#### 2. 단계 2 : 파싱

- 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 담는다. 

#### 3. 단계 3 : 검색

- URL 을 알아내고 로컬 사본이 있는 검사
- 전문적인 수준의 캐시는 객체를 로컬 캐시에서 가져올 수 있는지 판단하기 위해 빠른 알고리즘을 사용
- 문서를 로컬에서 가져올 수 없다면 원서버나, 부모 프락시에서 가져오거나 실패를 반환

#### 4. 단계 4 : 신선도 검사

- HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해주고, 
  이 기간동안 문서는 신선한 것으로 간주되고 캐시는 서버와의 접촉 없이 이 문서를 제공할 수 있다

#### 5. 단계 5 : 응답 생성

- 예를 들어, 클라이언트가 HTTP/1.1 응답을 기대하는 상황에서 서버가 다른버전의 HTTP를 반환했다면, 
  캐시는 반드시 헤더를 적절하게 번역해야 한다.

#### 6. 단계 6 : 전송

- 모든 프락시 서버들과 마찬가지로, 프락시 캐시는 클라이언트와 커넥션을 유지할 필요가 있다

#### 7. 단계 7 : 로깅

- 캐시는 통계 캐시 적중과 부적중 회수에 대한 통계를 갱신하고, 로그파일에 요청 종류, URL 그리고 무엇이 일어났는지를 알려주는 항목을 추가

#### 8. 캐시 처리 플로차트

- p201 그림 7-12 에 캐시 GET 요청 플로차트 설명



## 8. 사본을 신선하게 유지하기

- 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야 한다. 
- HTTP는 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 매커니짐을 갖고 있고
  HTTP는 이 단순한 매커니즘을 문서 만료와 서버 재검사라고 부른다
  

#### 1. 문서 만료

- HTTP는 Cache-Control과 Expires 라는 특별한 헤더들을 이용해서 유효기간을 붙일 수 있게 해준다.
- 캐시된 문서가 만료되면 반드시 서버와 문서에 변경된 것이 있는지 검사하고, 
  변경된 것이 있다면 새 유효기간과 함께 신선한 사본을 얻어와야 한다. 

#### 2. 유효기간과 나이

- HTTP/1.0+ Expires ,  HTTP/1.1 Cache-Control:max-age 응답 헤더를 이용해 유효기간을 명시한다. 
- 현재 2002년 6월 29일 09시 30분
- 만료 2002년 7월 05일 00시 
  - Expires: Fri, 05 Jul 2002, 05:00:00 GMT
  - Cache-Control : max-age=484200
    - 만료까지 남은 초 (484200)



#### 3. 서버 재검사

- 캐시가 서버에게 문서가 변경되었는지의 여부를 물어볼 필요가 있음을 의미하는 검사
- 재검사 결과
  - 변경되었다면, 문서의 새로운 사본을 가져와 저장한 뒤 클라이언트에게 보내준다.
  - 변경되지 않았다면, 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신
- 이것은 괜찮은 시스템. 캐시는 매 요청마다 검증할 필요가 없다. 
  만료되었을 때 한번만 서버와 재검사하면 된다. 
  이는 서버 트래픽을 절약하고 사용자 응답 시간을 개선한다. 
  

#### 4. 조건부 메서드와의 재검사

- 캐시가 서버에게 '조건부 GET' 이라는 요청을 보낼 수 있도록 해준다 
- 이 요청은 서버가 갖고 있는 문서가 캐시가 갖고있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것이다.
- 조건부 GET은 GET 요청 메시지에 특별한 조건부 헤더를 추가함으로 시작되고 웹 서버는 조건이 참인 경우에만 객체를 반환한다.
- 캐시 재검사를 할 때 가장 유용한 if-Modified-Since 와 If-None-Match 



#### 5. if-Modified-Sine : 날짜 재검사

- 가장 흔히 쓰이는 캐시 재검사
- 'IMS' 요청으로 불리며, 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라 한다
- 주어진 날짜 이후에 변경되었다면
  - 조건은 참, GET 요청은 성공. 
  - 새로운 만료 날짜와 그 외 다른 정보들이 담긴 헤더들과 함께 캐시에게 반환된다. 
- 주어진 날짜 이후에 변경되지 않았다면
  - 조건은 거짓, 서버는 304 Nodified 응답 메시지를 클라이언트에게 돌려주고, 본문은 보내지 않는다.

#### 6. if-None-Match : 엔터티 태그 재검사

- 엔터티 태그가 변경되었다면 캐시는 새 문서의 사본을 얻기(GET) 위해 사용할 수 있다.
- 캐시는 v2.6 인 문서를 갖고 있고, 캐시는 태그가 더이상 v2.6이 아닌 경우에만 새 객체를 달라고 요청하는 방법으로 유효한지 여부를 재검사한다. 
- 변경되었다면 (ex) v3.0)
  - 200 OK, 새 콘텐츠를 새 ETag와 함께 반환
- 변경되지 않았다면
  - 304 Not Modified 응답



#### 7. 약한 검사기와 강한 검사기

- 서버는 때때로 모든 캐시된 사본을 무효화시키지 않고 문서를 살짝 고칠 수 있도록 허용하고 싶은 경우가 있다
- HTTP/1.1은 콘텐츠가 조금 변경되었더라고 그정도면 같은 것이라고 주장할 수 있도록 약한 검사기(weak validator)를 지원
- 강한 검사기(strong validator)는 콘텐츠가 바뀔 때마다 바뀐다 
- 강한 엔터티 태그는 대응하는 엔터티 값이 어떻게 바뀌든 매번 반드시 같이 바뀌어야 한다. 



#### 8. 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

- 만약 서버가 엔터티 태그를 반환했다면, 반드시 엔터티 태그 검사기를 사용해야 한다. 
- Last-Modified 값만 반환했다면 클라이언트는 If-Modified-Since 검사를 사용할 수 있다 
- 만약 엔터티 태그와 최근변경 일시가 모두 사용 가능하다면, 
  클라이언트는 각각을 위해 두가지의 재검사 정책을 모두 사용해야 한다. 
- 만약 HTTP/1.1 캐시나 서버가 If-Modified-Since와 엔터티 태그 조건부 헤더를 모두 받았다면
  요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 한 304 Not Modified 응답을 반환해서는 안된다. 



## 9. 캐시 제어

- 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러가지 방법

#### 1. no-cache 와 no-store 응답 헤더

- 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다. 
- no-store가 표시된 응답은
  - 캐시가 그 응답의 사본을 만드는 것을 금지
- no-cache로 표시된 응답은
  - 사실 로컬 캐시 저장소에 저장될 수 있다
    다만 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을 뿐이다

#### 2. Max-Age 응답 헤더

- Cache-Control:max-age 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른시간
  

#### 3. Expires 응답 헤더

- 더이상 사용하지 않기를 권하는 헤더
- 실제 만료 날짜를 명시
- 많은 서버가 부정확한 시계를 갖고 있기 때문에 경과된 시간으로 표시하는것이 낫자고 판단했다. 



#### 4. Must-Ravalidate 응답 헤더

- Cache-Control : must-revalidate
- 캐시가 이 객체의 신선하지 않은 사본을 원서버와의 최초의 재검사 없이는 제공해서는 안됨을 의미

#### 5. 휴리스틱 만료

- 만약 응답이 max-age나 expires 헤더 중 어느 것도 포함하지 않고 있다면
  경험적인 방법(heuristic) 최대 나이를 계산 할 것이다. 
- p211 한번 다시 읽어라 

#### 6. 클라이언트 신선도 제약

- 웹브라우저는 신선하지 않은 콘텐츠를 강제로 갱신시켜 주는 리프레시나 리로드 버튼을 가지고 있음

#### 7. 주의할 점

- 퍼블리셔가 유효기간을 길게 잡아버리면
  - 만료 되기 전까지 그 문서에 대한 어떤 변경도 캐시에 반영되지 않음
- 유효기간을 사용조차 하지 않으면
  - 문서가 얼마나 오랫동안 신선할 것인지 캐시가 알기 어렵다. 



## 10. 캐시 제어 설정

- 아파치 웹 서버가 캐시제어를 어떻게 지원하는지 설명

#### 1. 아파치로 HTTP 헤더 제어하기

- 아파치 웹서버는 HTTP 캐시 제어 헤더를 설정할 수 있는 여러가지 매커니즘을 제공한다.
- mod_headers
  - 개별 헤더들을 설정할 수 있게 해줌
- mod_expires
  - 자동으로 생성하는 프로그램 로직을 제공
- mod_cern_mete
  - HTTP 헤더들의 파일을 특정 객체와 연결시켜줌

#### 2. HTTP-EQUIV를 통한 HTML 캐시 제어

- HTML 문서를 캐시하지 않도록 설정
- 이 기능을 지원하는 웹서버나 프락시는 거의 없다. 
  - 서버의 부하를 가중시키고, 설정값이 정적, HTML을 제외한 다른 타입의 파일을 지원하지 않음
  - 해당 태그는 문제를 일으키기 때문에 대부분의 소프트웨어가 무시한다. 
- 문서의 캐시 제어 요청과 커뮤니케이션하는 유일하게 확실한 방법은
  올바르게 설정된 서버가 보내온 HTTP 헤더를 이용하는 것



## 11. 자세한 알고리즘

- 캐시 내부에 대한 하는 독자들에게 가장 유용하고 건너뛰어도 좋다. 



## 12. 캐시와 광고 (이건 이해가 안간다 )

#### 1. 광고 회사의 딜레마

- 광고를 통해 돈을 버는 광고 회사
- 캐시는 원 서버가 실제 접근 횟수를 알 수 없게 숨길 수 있다. 
- 만약 캐싱이 완벽하게 동작한다면, 원 서버는 HTTP 접근을 전혀 수신하지 않게 된다. 
- 인터넷 캐시가 그 접근들을 모두 흡수하기 때문에 접근 횟수에 따라 돈을 번다면 달갑지 않은 일 

#### 2. 퍼블리셔의 응답

- 그래서 캐시가 광수 시청수를 가로채지 못하도록 모든 종류의 캐시 무력화 기법을 사용
- 이상적으로는 캐시가 그들의 트래픽을 흡수하도록 내버려 두고
  캐시는 그들에게 적중이 얼마나 많이 일어났는지 알려줘야 한다. 
- 모든 접근에 대해 원서버와 재검사하도록 캐시를 설정한다면, 매 접근마다 원 서버에 캐시 적중이 있었음을 알리지만 모통 본문 데이터는 전송하지 않고 이는 트랜잭션을 느리게 만든다. 

#### 3. 로그 마이그레이션

- 이상적인 해결책 하나는 서버로 요청이 가지 않도록 하는 것.








# 8장 통합점 : 게이트웨이,터널,릴레이

> 여기서는 여러 종류의 리소스에 접근하는데 HTTP가 어떻게 쓰이는지 알아보고
다른 프로토콜이나 애플리케이션 간 통신에 HTTP를 어떻게 사용하는지 알아 보는게 목표

- 게이트웨이 : 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스
- 애플리케이션 엔터페이스 : 서로 다른 형식의 웹 애플리케이션이 통신하는데 사용
- 터널 : HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송하는데 사용
- 릴레이 : 일종의 단순한 HTTP 프락시로, 한번에 한 개의 홉에 데이터를 전달하는데 사용

## 1. 게이트웨이

- 웹에 더 복잡한 리소스를 올려야 할 필요가 생기면서, 모든 리소스를 한 개의 애플리케이션으로만 처리할 수 없다는 것은 분명해짐
- 이 문제에 대한 해결책이 게이트웨이
  - 리소스와 애플리케이션을 연결하는 역할
  - 요청을 받고 응답을 보내는 포털같이 동작하는데, 동적인 콘텐츠를 생성하거나 데이터베이스에 질의를 보낼 수 있음
  - HTTP 트래픽을 다른 프로토콜로 자동으로 변환하며, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속 할 수 있게 해줌
  - 229p 그림 8-2 > 3가지 예
    - HTTP 클라이언트 - 게이트웨이 - FTP 서버
    - HTTPS / HTTP
    - HTTP/ CGI 서버

#### 1. 클라이언트 측 게이트웨이와 서버측 게이트웨이

- 웹 게이트웨이는 한쪽에서는 HTTP로 통신하고 다른 한쪽에서는 HTTP가 아닌 다른 프로토콜로 통신한다. 
  - <클라이언트 프로토콜>/<서버 프로토콜>
- 서버 측 게이트 웨이
  - 클라이언트와 HTTP로 통신 
  - 서버와는 외래 프로토콜로 통신
- 클라이언트 측 게이트웨이
  - 클라이언트와 외래 프로토콜로 통신
  - 서버와는 HTTP로 통신





## 2. 프로토콜 게이트 웨이

- 게이트 웨이도 HTTP 트래픽을 바로 보낼 수 있다.
  보통 브라우저에 명시적으로 게이트웨이를 설정하여 자연스럽게 트래픽이 게이트웨이를 거쳐가게 하거나, 대리서버(리버스 프락시)로 설정할 수 있도 있다. 
- 게이트웨이를 설정하면 일반적인 HTTP 트래픽에는 영향을 끼치지는 않지만 FTP URL을 포함한 요청은 게이트웨이로 HTTP요청을 보낸다 .
  - HTTP 끼리 통신에는 게이트웨이를 거치지 않고 서버로 바로 통신한다고 이해함
  

#### 1. HTTP/*: 서버 측 웹 게이트웨이

- 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 HTTP 요청을 외래 프로토콜로 전환
- 게이트 웨이가 하는일. (이해 전혀 안감)
  - USER와 PASS 명령을 보내서 서버에 로그인
  - 서버에서 적절한 디렉터리로 변경하기 위해 CWD 명령을 내림
  - 등등등등 (p231)
- 게이트웨이는 객체를 받는 대로 HTTP 응답에 실어서 클라이언트에 전송할 것이다. 
  

#### 2. HTTP/HTTPS: 서버 측 보안 게이트웨이

- 기업 내부의 모든 웹 요청을 암호화함으로써 개인 정보 보호와 보안을 제공하는데 게이트웨이를 사용할 수 있음
- 클라이언트는 일반 HTTP를 사용하여 웹을 탐색할 수 있지만, 게이트웨이는 자동으로 사용자의 모든 세션을 암호화 할 것



#### 3. HTTPS/HTTP: 클라이언트 측 보안 가속 게이트 웨이

- HTTPS/HTTP는 보안 가속기로 유명 (처음 들어봄)
- 웹 서버의 앞단에 위치하고 보안 HTTPS 트래픽을 받아서 복호화하고, 웹서버로 보낼 일반 HTTP 요청을 만든다. 
- 더욱 효율적으로 보안 트래픽을 복호화하는 암호화 하드웨어를 내장해서 원서버의 부하를 줄여주기도 함
  하지만 이는 게이트웨이와 원 서버 간의 암호화하지 않는 트래픽을 전송하기 때문에, 
  네트워크가 안전한지 확실히 하고 사용해야 한다. 



## 3. 리소스 게이트웨이

- 게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 목적지 서버와 게이트웨이 한개의 서버로 결합한다. 
- 애플리케이션 서버는 서버 측 게이트 웨이다. 

#### 1. 공용 게이트웨이 인터페이스

- Common Gateway Interface, CGI
- 최초의 서버확장이자 지금까지도 가장 널리 쓰이는 서버 확장
- 웹에서 동적인 HTML, 신용카드 처리, 데이트베이스 질의등을 제공하는데 사용
- 거의 모든 HTTP 서버가 지원
- 문제가 많은 확장으로 부터 서버를 보호한다는 점에서 훌륭하지만
  성능 관련한 비용히 발생하고, 모든 CGI 요청마다 새로운 프로세스를 만드는데 부하가 꽤 크고
  서버 장비에 부담을 줌
- 이 문제를 피하고자 Fast CGI가 개발
  - CGI와 유사하지만, 데몬으로 동작함으로써 요청마다 새로운 프로세스를 만들고 제거하면서 생기는 성능  저하 문제를 해결함





#### 2. 서버 확장 API

- 서버 자체의 동작을 바꾸고 싶거나 서버의 처리능력을 최고치로 끌어올리고자 할때
  서버개발자는 웹 개발자가 자신의 모듈을 HTTP와 직접 연결할 수 있는 강력한 인터페이스인 서버 확장 API를 제공
- 프로그래머가 자신의 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교체해버릴 수 있게 함
- 예는 마이크로소프트의 프론트페이지 서버확장(FrontPage Server Extension, FPSE)



## 4. 애플리케이션 인터페이스와 웹 서비스

- 애플리케이션을 연결하면서 생기는 까다로운 이슈 중 하나는 , 데이터를 교환하려는 두 애플리케이션 사이에서 프로토콜 인터페이스를 맞추는 일이다. 
- 웹서비는 SOAP을 통해 XML을 사용하여 정보를 교혼한다. 
  - XML (eXtensible Markup Language) 은 데이터 객체를 담는 데이터를 생성하고 해석하는 방식
  - SOAP(Simple Object Access Protocol) 은 HTTP 메시지에 XML 데이터를 담는 방식에 관한 표준

## 5. 터널

- 웹 터널은 HTTP프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법
- HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP위에 올릴 수 있다.
- 사용하는 가장 일반적인 이유는 HTTP 커넥션 안에 HTTP가 아닌 트래픽을 얹기 위해서 이다. 
- 따라서 웹터널을 사용하면 웹 트래픽만을 허락하는 방화벽이 있더라고 HTTP가 아닌 트래픽을 전송할 수 있다. 

#### 1. CONNECT로 HTTP 터널 커넥션 맺기

- 웹터널은 HTTP의 CONNECT 메서드를 사용하여 커넥션을 맺는다. 
- CONNET 메서드가 어떻게 게이트웨이 터널을 연결하는지 예 (p239 그림 8-10 )
  - 클라이언트는 CONNECT 요청을 보내고 CONNECT 메서드는 TCP커넥션을 위해 케이트웨이에 터널 연결을 요청한다. 
  - 커넥션이 생성되고 맺어지면
  - 게이트웨이는 클라이언트에게 HTTP200 Connection Established 응답을 전송하여 연결되었음을 알림
  - 이 시점에 터널이 연결되고 커넥션이 끊길 때가지 모든 데이터가 양방향으로 전달된다.
- CONNECT 요청
  - 시작줄을 제외하고는 다른 HTTP 메서드와 같다. 
    	CONNECT home.netscape.com:443 HTTP/1.0
    	User-agent: Mozilla/4.0
- CONNECT 응답
  - 응답에 있는 사유구절은 편의상 Connection Established  으로 기술
    	HTTP/1.0 200 Connect Established
    	Proxy-agent: Netscape-Proxy/1.1
  - 메시지를 전달하는대신 바이트를 그대로 전달하기 때문에 HTTP 응답과 달리 Content-Type 헤더를 포함할 필요가 없다



#### 2. 데이터 터널링, 시간, 커넥션 관리

- 터널이 연결되면, 데이터는 언제 어디로든 흘러가버릴 수 있다.
- 클라이언트는 성능을 높이기 위해 connect요청을 보낸다음, 응답을 받기 전 터널 데이터를 전송할 수 있다
  이는 게이트웨이가 요청에 이어서 데이터를 적절히 처리할 수 있어야 함을 전제로 한다. 
- 게이트웨이는 커넥션이 맺어지는 대로 헤더를 포함해 읽어들인 모든 데이터를 서버로 전송해야 한다
- 요청 후에 클라이언트는 인증요구나 200외의 응답이 왔을 때 
  요청 데이터를 다시 보낼 준비가 되어 있어야 한다. 
- 터널의 끝단 어디든 커넥션이 끊어지면, 그 끊어진 곳부터 온 데이터는 반대편으로 전달된다. 
  그다음 커넥션이 끊어졌던 터널의 반대편의 커넥션도 프락시에 의해서 끊어질 것이다. 
  커넥션이 끊긴 한쪽에 전송되지 않은 데이터는 버려진다. 

#### 3. SSL 터널링

- 웹 터널은 원래 방화벽을 통해 암호화된 SSL 트래픽을 전달하려고 개발됨
- 터널은 HTTP가 아닌 트래픽이 포트를 제한하는 방화벽을 통과할 수 있게 해준다. 
  이는 보안 SSL 트래픽이 방화벽을 통과하는데 유용하게 사용될 수 있다

#### 4. SSL 터널링 vs HTTP/HTTPS 게이트웨이

- HTTPS 프로토콜은 원격 HTTPS 서버와 SSL 세션을 시작하는 게이트웨이를 두고 클라이언트 측의 HTTPS 트랜잭션을 수행하는 방식으로 게이트웨이를 통과한다.
- 응답은 프락시가 받아서 복화하고 난 후에 HTTP를 통해 클라이언트로 전송 (게이트웨이가 FPT를 처리하는 방식과 같다)
- 이 접근은 단점이 있음
  - 클라이언트-게이트웨이 사이에 보안이 적용되지 않은 HTTP 커넥션이 맺어져있다
  - 프락시가 인증을 담당하기 때문에 원격 서버에 SSL 클라이언트 인증을 할 수 없다
  - 게이트웨이는 SSL을 완벽히 지원해야 한다.
- 이 상황에서 SSL 터널링을 사용하면 프락시에 SSL를 구현할 필요가 없다
  SSL세션은 클라이언트가 생성한 요청과 목적지(보안이 적용된) 웹 서버 간에 생성된다. 
  프락시 서버는 트랜잭션의 보안에는 관여하지 않고 암호화된 데이터를 그대로 터널링 할 뿐이다.

#### 5. 터널 인증

- HTTP의 다른 기능들은 터널과 함께 적절히 사용할 수 있다.
- 플락시 인증 기능은 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용할 수 있다

#### 6. 터널 보안에 대한 고려사항들

- 회사 방화벽에 터널을 생성하여 게임 트래픽을 유입할 수 있도 있고
  회사의 이메일 차단 장치를 우회하려고 터널을 사용할 수 도 있다
- 터널의 오용을 최소화 하기 위해 게이트웨이는 HTTPS 전용 포트인 443 같이 잘 알려진 특정 포트만을 터널링할 수 있게 허용해야 함

## 6. 릴레이

- HTTP 릴레이는 HTTP 명세를 완전히 준수하지는 않는 간단한 HTTP 프락시다. 
- 릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 맹목적으로 전달한다.
- HTTP 복잡하기에 맹목적으로 트래픽을 전달하는 간단한 프락시를 구현하는 방식이 유용할 때가 있다
- 데이터를 맹목적으로 전달하도록 구현하기는 쉽기 때문에, 단순 필터링이나 진단 혹은 콘텐츠를 변환을 하는데 사용하기도 한다. 
- 하지만 이는 잠재적으로 심각한 상호 운용 문제를 가지고 있기에 주의해서 배포해야 한다. 
- 단순 맹목적 릴레이를 구현하는데 관련된 더 일반적인(악명높은) 문제 중 하나는, 맹목적 릴레이가 Connection 헤더를 제대로 처리하지 못해서 keep-alive 커넥션 행(hang)에 걸리는 것이다. 
- 그림 8-14
  - 릴레이는 keep-alive에 대해 아무것도 모르기 때문에, 
    원 서버가 커넥션을 끊기를 기다리며 받은 데이터 전부를 그대로 클라이언트에게 전달한다.
    하지만 원 서버는 릴레이가 자신에게 커넥션을 계속 맺고 있기를 요청했다고 믿기 때문에 커넥션을 끊지 않을 것이다. 
    따라서 릴레이는 커넥션이 끊길 때를 기다리며 계속 커넥션을 맺고(hang ) 있을 것
- 릴레이를 조금이나마 똑또가게 만드는 방법이 있지만
  프락시의 단순함 이면에는 상호 운용과 관련한 문제가 발생할 위험이 있다. 
  만약 특정 목적을 위해서 단순한 HTTP 릴레이를 구축하는 중이라면, 그것을 어떻게 사용할지 신중히 고민해봐야 한다.
  여러 문제를 예방하기 위해
  HTTP 를 제대로 준수하는 프락시를 사용하는 것이 좋다. 
  

