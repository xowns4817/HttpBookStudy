## 7장 캐시 (p.185)
 - 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치이다.
 - 캐시는 불필요한 데이터 전송을 줄여 네트워크 요금으로 인한 비용을 줄여준다.
 - 캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러 올 수 있게 된다.
 - 캐시는 서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있다.
 - 페이지를 먼 곳에서 불러옴으로 발생하는 지연을 줄여준다.
 - 이번 장에서는..
    - 어떻게 캐시가 성능을 개선하고 비용을 줄이는지?
    - 어떻게 그 효과를 측정하는지?
    - 그 효과를 극대화하기 위해 캐시를 어디에 위치시켜야 할지?
    - 어떻게 HTTP가 캐시된 사본을 신선하게 유지하는지?
    - 어떻게 캐시가 다른 캐시나 서버와 상호작용하는지?

### 7.1 불필요한 데이터 전송(p.185)
 - 첫 요청에 대한 응답을 캐싱하면 뒤이어 같은 요청들이 올 경우 캐시된 사본을 응답해주면 서버의 트래픽 낭비를 줄일 수 있다.

### 7.2 대역폭 병목(p.186)
 - 클라이언트와 원 서버와의 네트워크 내에 병목이 존재한다면(느린 네트워크가 존재한다면) 클라이언트와 가까운 곳에 캐시를 두면 속도를 개선할 수 있음.

### 7.3 갑작스런 요청 쇄도(Flash Crowds)(p.187)
 - 갑작스런 사건으로 인해 많은 사람이 거의 동시에 웹 문서에 접근할 때 이런 일이 발생한다.
 - 이 결과로 초래된 불필요한 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기한다.

### 7.4 거리로 인한 지연(p.188)
 - 7.2처럼 대역폭이 문제가 되지 않더라도, 거리가 문제가 될 수 있음.
 - 이상적인 경우라고 하더라도 트래픽은 빛의 속도보다는 느림.
 - 때문에 물리적으로 멀리 떨어진 곳과 여러번의 요청/응답을 반복할 때 병목이 없더라도 응답이 느릴 수 있다.
 - 이를 막기위해 클라이언트 근처로 캐싱을 하는 것을 고려해볼 수 있다.

### 7.5 적중과 부적중(p.189)
 - 요청에 대한 캐시 있음 -> 캐시 적중 -> 캐시 사본 응답
 - 요청에 대한 캐시 없음 -> 캐시 부적중 -> 원 서버로 요청 / 응답

#### 7.5.1 재검사(Revalidation)(p.190)
 - 원 서버 콘텐츠는 변경될 수 있다. 때문에 캐시는 반드시 그들이 가지고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야한다. 이를 재검사라고 부름
 - 효과적인 재검사를 위해서 HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 검사할 수 있는 방법을 정의했다.
 - 캐시는 원한다면 언제든지 사본을 재검사할 수 있다.
 - 캐시된 사본의 재검사가 필요할 때 원 서버에 재검사 요청을 보내고, 변경되지 않았다면 304 Not Modified 응답을 보낸다.
 - **재검사 적중은 캐시 부적중보다는 빠르다.** -> 객체 데이터를 받아올 필요는 없기 때문
 - 재검사를 위해 몇가지 방법이 있으나, 가장 많이 사용되는건 **If-Modified-Since** 헤더이다.
    - 서버에 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 다시 보내달라는 의미이다.
    - 이때 3가지 경우가 존재한다.
        - 서버 콘텐츠가 변경되지 않은 경우 -> 재검사 적중 (304 Not Modified)
        - 서버 콘텐츠가 변경된 경우 -> 재검사 부적중 (200 OK와 함께 전체 컨텐츠 전송)
        - 객체가 삭제된 경우 -> 404 Not Found 응답을 돌려보내고 캐시는 해당 사본 삭제

#### 7.5.2 적중률(p.192)
 - 캐시가 요청을 처리하는 비율을 캐시 적중률 이라고한다.
 - 캐시 관리자는 캐시 적중률이 100%에 근접하게 되는 것을 좋아할 것임.
 - 적중률이 조금 낮더라도, 캐시는 상당히 트래픽을 줄이고, 성능을 개선할 수 있다는 점에서 도입할만하다.

#### 7.5.3 바이트 적중률(p.192)
 - 문서 크기가 서로 다르기 때문에 큰 문서 1건을 캐싱하는게 작은 문서 1건을 캐싱하는 것보다 개이득임.
 - 이런 이유로 어떤 이들은 적중률을 문서 단위가 아닌 바이트 단위로 측정한다.

#### 7.5.4 적중과 부적중의 구별(p.193)
 - 클라이언트 입장에선 캐시가 적중이었는지 아닌지를 알수 있는 방법을 HTTP 자체가 제공하지는 않는다.
 - 다만 Date 헤더에 기록된 날짜가 현재 날짜가 아닌 오래전 날짜라면 캐시된거라고 추측해 볼 수 있다.
 - 또는 Age 헤더를 사용한다.

### 7.6 캐시 토폴로지(p.193)
 - 한 명에게만 할당된 캐시를 개인 전용 캐시(private cache)라고 부르고 여러 명이 사용하는 캐시는 공용 캐시(public cache)라고 불린다.

#### 7.6.1 개인 전용 캐시(p.193)
 - 웹 브라우저는 개인 전용 캐시를 내장하고 있다.
 - 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고, 사용자가 캐시 사이즈를 설정할 수 있도록 허용한다.

#### 7.6.2 공용 프록시 캐시(p.194)
 - 공용 캐시는 캐시 프록시 서버 혹은 프록시 캐시라고 불리는 특별한 종류의 공유된 프록시 서버다.
 - 마찬가지로 트래픽을 줄일 수 있다.

#### 7.6.3 프록시 캐시 계층들(p.195)
 - [그림 7-9] 참고

#### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링(p.196)
 - 몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만든다.
 - 어떤 부모 캐시와 대화할 것인지, 아니면 요청이 캐시를 완전히 우회해서 원 서버로 가도록 할 것 인지에 대한 캐시 커뮤니케이션 결덩을 동적으로 내림
 - 크게 와닿는 내용은 아닌듯 하다.

### 7.7 캐시 처리 단계(p.198)
 - 오늘날 상용 프록시 캐시는 꽤 복잡함.
 - 매우 고성능이면서 HTTP와 그 외 다른 기술의 고급 기능을 지원하도록 만들어짐.
 - 캐시는 다음과 같은 처리 절차를 거침
    - 요청 받기
    - 파싱
    - 검색
    - 신선도 검사
    - 응답 생성
    - 발송
    - 로깅

#### 7.7.1 단계 1: 요청 받기(p.199)
 - 커넥션에서의 활동을 감지하고 들어오는 데이터를 읽어들임.
 - 고성능 캐시는 여러 개의 커넥션들로부터 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작함.

#### 7.7.2 단계 2: 파싱(p.199)
 - 요청 메시지를 파싱하여 조작하기 쉬운 자료 구조에 담는다.(이전 시간에 봤던 룩업 테이블 처럼)

#### 7.7.3 단계 3: 검색(p.199)
 - 캐시는 URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사한다.
 - 로컬 복사본은 메모리, 디스크, 근처 캐시에 저장되어 있을 수도 있다.
 - 만약 로컬에서 문서를 가져올 수 없다면 캐시는 상황이나 설정에 따라 원 서버나 부모 프록시 캐시에서 가져오거나 실패를 반환한다.

#### 7.7.4 단계 4: 신선도 검사(p.199)
 - 캐시된 사본이 신선도 한계를 넘을 정도로 너무 오래되었다면, 그 객체는 신선하지 않은 것으로 간주되며, 
    캐시는 그 문서를 제공하기 전에 문서에 어떤 변경이 있었는지 검사하기 위해 서버와 재검사를 해야한다.
 - **신선도 검사 규칙은 매우 복잡한데, 이 장의 나머지 부분에서 해당 내용을 설명**한다고 한다.

#### 7.7.5 단계 5: 응답 생성(p.200)
 - 캐시는 캐시된 응답을 원 서버에서 온 것처럼 보이게 만든다.
 - 캐시는 클라이언트에 맞게 원 서버에서 온 헤더를 조정해야할 책임이 있다.
 - 다만 Date 헤더 만큼은 조정해서는 안된다. 이는 그 객체가 원 서버에 최초로 생겨난 일시를 말한다.

#### 7.7.6 단계 6: 전송(p.200)
 - 응답 헤더가 준비되면 캐시는 응답을 클라이언트에게 돌려준다.
 - 고성능 캐시는 종종 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피함으로써 데이터를 효과적으로 전송하기 위해 노력한다.
    - 원 서버에서 온 콘텐츠를 네트워크 I/O 버퍼 to 네트워크 I/O 버퍼로 연결한다는 의미인듯.

#### 7.7.7 단계 7: 로깅(p.200)
 - 캐시는 통계나 디버깅을 위해 로그 파일과 캐시 사용에 대한 통계를 유지한다.
 - 로그 파일 포맷에 대해서는 21장에서 자세히 다룬다.

#### 7.7.8 캐시 처리 플로 차트(p.201)
 - 캐시의 GET 요청을 처리하는 방법을 [그림 7-12]가 잘 보여주고 있다.

### 7.8 사본을 신선하게 유지하기(p.201)
 - 캐시된 사본 모두가 서버의 문서와 항상 일치하는 것은 아님.
 - 오래된 데이터를 제공하는 캐시는 불필요
 - HTTP는 이를 문서 만료와 서버 재검사를 통해 달성한다.

#### 7.8.1 문서 만료(p.201)
 - Cache-Control과 Expires라는 헤더를 이용해서 origin 서버가 각 문서에 유효기간을 붙일 수 있게 함.
 - (캐시되었거나 검사되지 않은 리소스의 제공을 거부하는 헤더가 클라이언트 요청에 포함되어 있지 않으면) 서버와의 접촉 없이 사본을 제공할 수 있다.
   - 리소스의 제공을 거부하는 헤더??
     - Cache-Control: no-cache 같은 헤더 -> 매번 캐시되어있는지 원 서버에 물어본다.

#### 7.8.2 유효기간과 나이(p.202)
 - 1.0+는 Expires, 1.1은 Cache-Control:max-age에 유효기간을 명시한다.
 - Expires는 절대 유효기간을, Cache-Control: max-age는 초단위의 최대 나이를 포함한다.

#### 7.8.3 서버 재검사(p.203)
 - 캐시된 문서가 만료되었다는 것은 원 서버에 재검사를 해야한다는 의미이지, 더 이상 해당 사본이 원 서버와 다르다는 의미는 아니다.
 - 재검사 결과..
    - 컨텐츠가 변경되었다면, 새로운 사본을 사져와서 오래된 사본 대신 저장하고, 클라이언트에게 요청이 오면 새로운 사본을 준다.
    - 컨텐트가 변견되지 않았다면, 응답 헤더에 새로운 만료일을 포함한 헤더를 보내주어 클라이언트의 캐시 유효기간을 갱신한다.

#### 7.8.4 조건부 메서드와의 재검사(p.204)
 - 캐시를 검사하기 위한 조건부 메서드가 있고, 이게 재검사를 효율적으로 만들어줌.
 - If-Modified-Since, If-None-Match가 있다.
 - 이들 조건부 메서드는 해당 조건에 만족하는 경우에만 새로운 사본을 보내도록 한다.

#### 7.8.5 If-Modified-Since: 날짜 재검사(p.204)
 - If-Modified-Since가 가장 흔히 쓰이는 캐시 재검사 헤더이다.
 - 줄여서 흔히 IMS 요청이라고 한다고 함.
 - 만약 문서가 주어진 날짜 이후 변경되었다면 -> 일반적인 GET 요청 처럼 동작하여 새로운 문서가 반환된다.
 - 만약 문서가 주어진 날짜 이후 변경되지 않았다면 -> 304 Not Modified 응답 메시지를 보내준다.
 - 또한 응답헤더에는 Last-Modified 헤더가 포함된다.
 - 몇몇 웹 서버는 이 스펙을 실제 날짜 비교로 구현하지 않아서, 단순 문자열 비교만 한다.(잘못 구현된 듯?)

#### 7.8.6 If-None-Match: 엔터티 태그 재검사(p.206)
 - 최근 변경 일시 재검사가 적절히 행해지기 어려운 상황이 몇가지 있음.
 - 너무 사소하거나 수정일시만 바뀌고 실제 컨텐츠가 변경되지 않았거나 등
 - 이때 ETag 헤더를 이용하여, 캐시를 할 수 있다.

#### 7.8.7 약한 검사기와 강한 검사기(p.207)
 - 보통 엔터티 태그의 캐시는 강한 검사기이고, 이는 컨텐츠가 바뀔 때 마다 사본을 갱신한다.
 - 약한 검사기는 어느 정도의 변경은 허용한다. 접두사로 W/로 구분함.
 - 약한 검사기를 이용하는 이유는 어느 정도의 변경은 허용할만한 상황(앞서 7.8.6의 예시처럼)

#### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가(p.208)
 - 서버의 응답을 따른다.
 - 만약 클라이언트의 IMS와 ETag가 동시에 들어왔다면 둘다 만족해야만 304 Not Modified를 응답할 수 있다.

### 7.9 캐시제어(p.209)
 - Cache-Control에도 우선순위가 있음.

#### 7.9.1 no-cache와 no-store 응답 헤더(p.209)
 - no-store -> 캐시하지 않음.
 - no-cache -> 캐시되는데, 항상 재검사를 한다.

#### 7.9.2 Max-Age 응답 헤더(p.210)
 - s-maxage는 max-age처럼 행동하지만 공용 캐시에만 적용된다.
 - max-age를 0으로 설정하면 no-cache처럼 동작한다.

#### 7.9.3 Expires 응답 헤더(p.210)
 - Expires 헤더는 deprecated임.
 - 이유는 많은 서버가 동기화되어 있지 않거나 부정확한 시계를 가지고 있다.
 - Expires: 0은 문서를 항상 만료되도록 할 수 있지만, 문법 위반임(날짜가 와야되니까)

#### 7.9.4 Must-Revalidate 응답 헤더(p.211)
 - must-revalidate는 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안된다는 의미임.
 - 여기서 재검사 시도를 했을 때 원 서버가 사용할 수 없는 상태라면 캐시는 504 Gateway Timeout error를 반환

#### 7.9.5 휴리스틱 만료(p.211)
 - 응답에 캐시 관련 헤더가 포함되지 않았다면 캐시 서버는 경험적인 방법으로 최대 나이를 계산한다.
 - 만약 계산 결과 얻은 최대 나이 값이 24시간 보다 크다면 Heuristic Expiration 경고를 응답 헤더에 추가해야한다.

#### 7.9.6 클라이언트 신선도 제약(p.212)
 - 웹 브라우저는 캐시를 강제로 갱신시켜주는 리프레시나 리로드 버튼을 가지고 있다.
 - max-stale, min-fresh 등을 통해 캐시를 엄격하게 하거나 느슨하게 할 수 있다.

#### 7.9.7 주의할 점(p.213)
 - 문서 만료는 완벽한 시스템이 아님.
 - 실수로 유효 기간을 까마득한 미래로 설정해버린다면 만료되기 전까지는 그 문서에 대한 어떤 변경도 캐시에 반영되지 않을 것이다.

### 7.10 캐시 제어 설정(p.213)
 - 아파치에 대한 캐시 설정을 하는 부분들임..

### 7.11 자세한 알고리즘(p.216)
 - 캐시 만료 공식의 적나라한 세부 사항을 애기하려는 듯.

#### 7.11.1 나이와 신선도 수명(p.217)
 - 캐시는 사본의 나이와 수명만 따지면 된다.
 - 나이가 수명보다 적다면 신선, 반대라면 신선하지 않은 것이다.

#### 7.11.2 나이 계산(p.217)
 - 나이 계산 공식들이 여러개 나와있으나.. 요약하자면 다음 과같은 것들을 고려한다.
   - 서버 별로 다를 수 있는 시간
   - 네트워크 지연에 대한 보상

#### 7.11.3 완전한 나이 계산 알고리즘(p.220)
 - HTTP/1.1 의 나이 계산 식
   - 나이 = 문서가 우리 캐시에 도착했을 때의 나이 + 사본이 얼마나 오래 우리 캐시에 있었는지
 - [그림 7-18]이 잘 설명해주고 있는듯.

#### 7.11.4 신선도 수명 계산(p.221)
 - 신선도 수명은 서버와 클라이언트의 제약조건에 의존

#### 7.11.5 완전한 서버 신선도 알고리즘(p.222)
 - 신선도를 계산하는 perl 의사 코드를 보여주고 있음.

### 7.12 캐시와 광고(p.223)
 - 캐시는 성능을 개선하고 트래픽을 줄인다.
 - 사용자를 도와 더 좋은 경험을 제공한다.

#### 7.12.1 광고 회사의 딜레마(p.224)
 - 캐시는 원 서버가 실제 접근 횟수를 알 수 없게 숨김으로서, 광고 회사로 하여금 정확한 광고 노출 횟수를 파악하기 어렵게 한다.

#### 7.12.2 퍼블리셔의 응답(p.224)
 - 오늘날 광고회사들은 캐시가 광고 시청 수를 가로채지 못하도록 모든 종류의 캐시 무력화 기법을 사용함.
 - 캐시는 그들에게 적중이 얼마나 많이 일어났는지 알려주어야한다.(돈 문제가 걸림)

#### 7.12.3 로그 마이그레이션(p.225)
 - 이상적인 해결책 중 하나는 적중된 로그를 유지하여 이 로그를 원 서버에게 나누어 주는 것이다.
 - 하지만 이는 프라이버시, 인증, 로그 사이즈 등의 이슈로 쉽지 않음.
 - 이를 위해 광고 수익을 교정해주는 지원 인프라를 개발하는 벤처들이 있음.

#### 7.12.4 적중 측정과 사용량 제한(p.225)
 - RFC 2227에서는 더 간단한 방법을 정의한다.
 - 이 프로토콜은 HTTP에 캐시 적중 횟수를 정기적으로 서버에게 돌려주는 Meter라고 하는 헤더를 이용한다.


## 8장 통합점: 게이트웨이, 터널, 릴레이(p.227)
 - 이 장에서는 게이트웨이, 애플리케이션 인터페이스, 터널, 릴레이 등을 다룬다.

### 8.1 게이트웨이(p.228)
 - 게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동으로 변환하여 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 한다.
 - 게이트웨이의 3가지 예 [그림 8-2]를 보면 게이트웨이가 하는 역할을 좀 더 알 수 있음.
   - 다른 프로토콜 변환
   - HTTPS/HTTP 보안
   - CGI
 
#### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이(p.229)
 - 클라이언트측 프로토콜이 HTTP, 서버측 프로토콜이 NNTP라면 이를 변환하는 게이트웨이를 HTTP/NNTP 게이트웨이라고 한다.

### 8.2 프로토콜 게이트웨이(p.230)
 - [그림 8-4] 처럼 FTP URL을 사용하고 있지만, 프로토콜은 HTTP를 사용하고 있는걸 볼 수 있다.
 - 서버는 내부에서 FTP로 바뀐 요청에 대한 응답을 다시 게이트웨이에서 HTTP로 바꿔서 응답한다.

#### 8.2.1 HTTP/*: 서버 측 웹 게이트웨이(p.231)
 - 앞서 이야기 한 것처럼 게이트웨이에서 HTTP -> FTP로 변경되면서 FTP에 적합한 동작을 한다.

#### 8.2.2 HTTP/HTTPS: 서버 측 보안 게이트웨이(p.232)
 - [그림 8-6] 처럼 HTTP로 들어온 요청을 HTTPS로 내부적으로 변환할 수 있다. (다음에 나오는 HTTPS/HTTP가 더 널리 쓰일듯)

#### 8.2.3 HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이(p.233)
 - [그림 8-7] 처럼 동작함. HTTPS 암복호화 로직을 원 서버에서 게이트웨이로 이관함으로서 얻을 수 있는 이점은 다음과 같다.
   - HTTPS 로직을 효율적으로 처리할 수 있는 하드웨어가 내장되는 경우 더 빠르게 트래픽을 처리할 수 있다.
   - HTTPS 관련 설정을 원 서버들에 일일이 해줄 필요가 없이 게이트웨이에만 해주면 된다.

### 8.3 리소스 게이트웨이(p.233)
 - 애플리케이션 게이트웨이에서 유명했던 최초의 API는 공용 게이트웨이 인터페이스(CGI)였음.
 - CGI는 특정 URL에 대한 HTTP 요청에 따라 프로그램을 실행하고, 프로그램의 출력을 수집하여 HTTP 응답으로 회산하는 표준화된 인터페이스 집합이다.

#### 8.3.1 공용 게이트웨이 인터페이스(p.235)
 - CGI는 최초의 서버 확장이자 지금까지도 널리 쓰이는 서버 확장임.
 - 전통적인 CGI는 매 요청마다 새로운 프로세스를 만들어서 오버헤드가 컸음.
 - 이를 해결하기 위해 데몬을 띄워놓고 그 위에서 동작하는 Fast CGI가 개발되었음.

#### 8.3.2 서버 확장 API(p.236)
 - CGI의 기본 기능에 확장된 API를 제공하기 위한 방법을 각 웹 서버 구현체들이 가지고 있다고 한다.

### 8.4 애플리케이션 인터페이스와 웹 서비스(p.236)
 - 애플리케이션이 상호 운용을 하다보면 HTTP 헤더로는 표현하기 힘든 복잡한 정보를 교환해야 할 수도 있음.
 - 이를 위해 SOAP의 XML이 사용되기도 하였음.
 - 현재는 REST의 JSON이 표준처럼 사용된다.

### 8.5 터널(p.237)
 - 웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근한느 방법을 제공한다.
 - 웹 터널을 사용하는 가장 일반적인 이유는 HTTP 커넥션 안에 HTTP가 아닌 트래픽을 얹기 위함이다.

#### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기(p.238)
 - CONNECT 메소드를 사용한다. 책에서는 HTTP -> SSL 연결을 하는 예시를 들고 있다.
 - 커넥션 요청 -> 연결 -> 통신 -> 커넥션 종료 순으로 이루어진다.
 - 일반적인 HTTP 응답과는 달리 Content-Type 헤더를 포함할 필요가 없음.

#### 8.5.2 데이터 터널링, 시간, 커넥션 관리(p.240)
 - 터널을 통해 전달되는 데이터는 게이트웨이가 볼 수 없다.

#### 8.5.3 SSL 터널링(p.241)
 - 웹 터널은 원래 방화벽을 통해 암호화된 SSL 트래픽을 전달하려고 개발되었음.
 - [그림 8-11]의 (b) 그림이 정석적인 사용법을 보여주고 있다.
 - 하지만 이런 터널을 잘못 사용하면 악의적인 트래픽이 방화벽을 통해 걸러지지 않고 내부망으로 유입되는 경로가 될 수도 있다.

#### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이(p.242)
 - 전자에 비해 후자는 게이트웨이가 해야할 역할이 많아지고, SSL을 완벽히 지원해야 한다는 단점이 있다. 
 - (경험상) SSL 터널링은 매번 터널링 사용 설정을 해줘야함.

#### 8.5.5 터널 인증(p.243)
 - 터널에도 인증을 할 수 있다. (프록시 인증)

#### 8.5.6 터널 보안에 대한 고려사항들(p.243)
 - 보통 터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없음.
 - 터널 오용을 최소화하기 위해서, 게이트웨이는 특정 포트만 터널링할 수 있게 허용해야 한다.

### 8.6 릴레이(p.244)
 - HTTP 릴레이는 HTTP 명세를 완전히 준수하지 않는 간단한 HTTP 프록시다.
 - 요청, 응답을 맹목적으로 전달하기만한다.
 - 여기서 앞서 프록시 챕터에서 지속 커넥션 관련 잘못된 처리로 발생하는 위험이 동일하게 발생한다.
 - 이러한 위험을 예방하기 위해서는 릴레이보다는 HTTP를 제대로 준수하는 프록시를 운용하는게 좋다.