### 7장 캐시
- 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면, 그 문서는 원 서버가 아니라 그 캐시로 부터 제공된다.

#### 7.1 불필요한 데이터 전송
- 캐시를 이용하면, 첫 번째 서버 응답은 캐시에 보관된다. 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용될 수 있기 때문에, 원 서버가 중복해서 트래픽을 주고 받는 낭비가 줄어들게 된다.

#### 7.2 대역폭 병목
- 캐시는 네트워크 병목을 줄여준다. 
- 책 예시
  - 클라이언트 <-> 본사 ( 1.4Mbit/sec )
  - 클라이언트 <-> 캐시 ( 100Mbit/sec ) 
  - 5MB(5M*8bit = 40Mbit )의 파일을 클라이언트에서 본사, 캐시로 각각 요청했을때 본사는 40/1.4 = 35초. 캐시는 40/100 = 0.4초

#### 7.3 갑작스런 요청 쇄도(Flash Crowds)
 - 캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다. ( 로컬에 캐싱되어있으면 서버를 탈 필요 없기때문에 빠른 응답을 받을 수 있음)

#### 7.4 거리로 인한 지연 
 - 모든 네트워크 라우터는 인터넷 트래픽을 지연시킴 -> 거리가 멀어질 수록 더 많은 라우터를 탈 것이고 그럼 더 느려질 것임. ( 로컬에 캐싱되어있으면 서버를 탈 필요 없기때문에 빠른 응답을 받을 수 있음)

#### 7.5 적중과 부적중 ( 그림 7-4 )
 - 캐시에 요청이 도착했을 때, 만약 그에 대응하는 사본이 있다면 그를 이용해 요청처리 가능 ( cache hit )
 - 만약, 대응하는 사본이 없다면 원 서버로 전달된다. ( cache miss )

##### 7.5.1 재검사(Revalidation) -> 언제, 재 검사를 해야하는지 ?
 - 원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 한다.
 - 효과적인 재검사를 위해, HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한 요청을 정의했다.
 - 캐시는 스스로 언제든지 사본을 재검사 할 수 있지만, 대부분의 캐시는 클라이언트가 사본을 요청하였으며 그 사본이 검사를 할 필요가 있을 정보도 충분히 오래된 경우에만 재검사를 진행한다.
 - 캐시는 캐시된 사본의 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보낸다. 콘텐츠가 변경되지 않았다면, 서버는 304 Not Modified응답을 보낸다. ( = 캐시에 가지고 있는 데이터로 응답해라. -> body 없음. )
 - HTTP는 캐시된 객체를 재확인하기 위한 몇 가지 도구를 제공하는데, 그 중에서 가장 많이 쓰이는 것은 If-Modified-Since 헤더이다. ( 서버에게 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내 달라는 의미이다. )
- GET If-Modified-Since 요청이 서버에 도착했을 때 일어날 수 있는 세가지 상황
  - 1. 서버 콘텐츠가 변경되지 않은 경우
  - 2. 서버 콘텐츠가 변경된 경우
  - 3. 객체가 삭제된 경우.

##### 재검사 적중
 - 만약, 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 HTTP 304 Not Modified 응답을 보낸다. ( 그림 7-6 )
##### 재검사 부적중
 - 만약, 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 HTTP 200 OK 응답을 클라이언트에게 보낸다.
##### 객체 삭제
 - 만약, 서버 객체가 삭제되었다면, 서버는 404 Not Found 응답을 보내며, 캐시 사본을 삭제한다.

##### 7.5.2 적중률
 - 캐시가 요청을 처리하는 비율을 캐시 적중률이라고 부른다. ( 0% -> 서버에서 가져옴, 100% -> 캐시에서 가져옴)

##### 7.5.3 바이트 적중률
 - 바이트 적중률이란 캐시를 통해 제공된 모든 바이트의 비율을 표현한다.
 - 문서 적중률과 바이트 적중률은 둘 다 캐시 성능에 대한 유용한 지표이다.

##### 7.5.4 적중과 부적중의 구별
 - Date 해더를 이용해 클라이언트가 응답이 캐시에서 왔는지 알 수 있다. 응답의 Date 해더 값을 현재시각과 비교해서 더 오래되었다면 캐시인것을 알 수 있다. ( Date해더는 해당 응답의 데이터 생성 시간 )
 - Age 해더 ( 응답이 얼마나 오래 되었는지 판단 )

#### 7.6 캐시 토폴로지
 - 캐시는 한 명의 사용자에게만 할당될 수도 있고 수천 명의 사용자들 간에 공유 될 수도 있다.

##### 7.6.1 개인 전용 캐시
 - 웹 브라우저는 개인 전용 캐시를 내장하고 있다. ( 브라우저 캐시 )
 - 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 메모리와 디스크에 캐시해 놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용한다.
  
##### 7.6.2 공용 프락시 캐시
 - 공용 캐시는 캐시 프락시 서버 혹은 더 흔히 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버다.

### 7.7 캐시 처리 단계
 - HTTP GET 메시지 하나를 처리하는 기본적인 캐시 처리 절차는 일곱 단계로 이루어져 있다.
 - 1. 요청 받기 : 캐시는 네트워크로 부터 도착한 요청 메시지를 읽는다.
 - 2. 파싱 : 캐시는 메시지를 파싱하여 URL과 헤더들을 추출한다.
 - 3. 검색 : 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다. ( 그리고 로컬에 저장한다. )
 - 4. 신선도 검사 : 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다. ( If-Modified-Since ) -> 서버는 변경 된 것이 없다면 304 Not Modified를 있다면 200 Ok를 리던한다.
 - 5. 응답 생성 : 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
 - 6. 발송 : 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.
 - 7. 로깅 : 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다.

##### 7.7.1 단계 1 : 요청 받기
 - 캐시는 네트워크 커넥션에서의 활동을 감지하고, 들어오는 데이터를 읽어들인다.
##### 7.7.2 단계 2: 파싱
 - 캐시는 요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 담는다.
##### 7.7.3 단계 3: 검색
 - 캐시는 URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사한다. 캐시된 객체는 또한 객체가 얼마나 오랫동안 캐시에 머무르고 있었는지 알려주는 기록(DATE 값)이나 얼마나 자주 사용되었는지에 대한 몇몇 메타데이터를 포함한다.
##### 7.7.4 단계 4: 신선도 검사
 - HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해준다. 이 기간 동안, 문서는 '신선'한 것으로 간주되고 캐시는 서버와의 접촉 없이 이 문서를 제공할 수 있다.
 - 그러나, 캐시를 너무 오래 가지고 있었다면 신선도 체크를 위해 서버와의 재검사를 해야한다. ( age 값을 보고 판단 ? )
##### 7.7.5 단계 5 : 응답 생성
 - 캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성한다.
 - 캐시는 클라이언트에 맞게 이 헤더를 조정해야 하는 책임이 있다.
 - 캐시는 신선도 정보를 삽입하 ( Cache-Control, Age, Expire 헤더), 또한 요청이 프락시를 거쳐갔음을 알려주기 위해 Via 해더를 포함시킨다.
 - 캐시가 Date 헤더를 조정해서는 안된다. ( Date 헤더는 그 객체가 원 서버에서 최초로 생겨난 일시를 표현한 것이다. 이를 통해 캐시에 얼마나 머물렀는지 알 수 있다.)
##### 7.7.6 단계 6 : 전송
 - 응답 헤더가 준비되면, 캐시는 응답을 클라이언트에게 돌려준다. 
##### 7.7.7 단계 7 : 로깅
##### 7.7.8 캐시 처리 폴트 차트
 - 그림 7-12 참조
#### 7.8 사본을 신선하게 유지하기
 - 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야 한다.
 - HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 메커니즘을 가지고 있다. ( 문서 만료와 서버 재검사 )

##### 7.8.1 문서 만료
 - HTTP는 Cache-Control(max-age)과 Expires라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다. 
 - 캐시된 문서가 만료된다면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 재검사 해야하며, 만약 그렇다면 신선한 사본을 얻어와야 한다. ( 새 유효기간과 함께 )
##### 7.8.2 유효기간과 나이
 - 서버는 본문과 함께 하는, HTTP/1.0+ Expires나 Http/1.1 Cache-Control:max-age 응답 헤더를 이용해서 유효기간을 명시한다.
 - Cache-Control: max-age -> 문서의 최대 나이를 정의한다. 최대 나이는 문서가 처음 생성된 이후부터, 제공하기에는 더 이상 신선하지 않다고 판단될 때 까지 경과한 시간이다. ( 초 단위 ) 
 - Expires : 절대 유효시간을 명시한다. 만약, 유효시간이 경과했다면, 그 문서는 더 이상 신선하지 않다. ( Cache-Control의 max-age가 있는 경우 이 헤더는 무시 된다.)
##### 7.8.3 서버 재검사
 - 캐시된 문서가 만료 되었다는 것은 그 문서가 서버에 존재하는 문서와 다르다는게 아니라, 다만 신선한지 서버와 검사할 시간이 됬다는 것을 의미한다.
 - 이때, 캐시가 원 서버에게 문서가 변경되었는지 여부를 물어보게 된다. ( 서버 재검사 )
 - 1. 변경 되었다면 ? -> 200 Ok -> 새 헤더 및 문서를 가져온다.
 - 2. 변경 되지 않았다면 ? -> 304 Not Modified, 새 만료일을 포함한 새 헤더들만 가져와 캐시안의 헤더를 갱신한다.
 - 캐시는 문서의 신선도를 매 요청마다 검증할 필요가 없다. 문서가 만료되었을 때 한 번만 서버와 재검사 한다. ( 캐시의 만료일 전까지는 서버를 안타고 캐시에 있는 데이터를 주는데 그렇다면 캐시의 만료일 전에 서버의 문서가 변경된 경우라면 ?? 잘못된 정보를 주는게 아닌가? )
##### 7.8.4 조건부 메서드와의 재검사
 - HTTP의 조건부 메서드는 재검사를 효율적으로 만들어준다. 
 - HTTP는 캐시가 서버에게 "조건부 GET'이라는 요청을 보낼 수 있도록 해준다. ( 서버가 갖고 있는 문서가 캐시가 갖고있는 문서와 다를 경우에만 객체 본문을 보내라. )
 - HTTP는 다섯 가지 조건부 요청 헤더를 정의한다. 그 중 If-Modified-Since와 If-None-Match는 캐시 재검사를 할 때 유용하다. ( 모든 조건부 헤더는 "If-" 접두어로 시작한다. )
  - - If-Modified-Since < date > : 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리한다. 콘텐츠가 변경된 경우에만 콘텐츠를 가져오기 위해 Last-Modified 서버 응답 헤더와 함께 사용된다.
  - - If-None-Match < tags > : ETag를 비교한다. 서버의 ETag와 다를때만 요청을 처리한다.
  - ETag : 유효토큰은 효율적인 자원 업데이트 체크를 가능하게 한다. HTTP 컨텐츠가 바뀌었는지 검사하는 태그로 같은 주소의 자원이더라도 컨텐츠가 달라졌다면 ETag가 다르다. ( Etag: W/"3bf2-wdj3VvN8/CvXVgafkI30/TyczHk" ) -> 실습
##### 7.8.5 If-Modified-Since : 날짜 재검사
 - If-Modified-Since 재검사 요청을 'IMS' 요청으로 불린다. IMS 요청은 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 한다.
##### 7.8.6 If-None-Match: 엔터티 태그 재검사
 - 다음 예시는 최근 변경실시 재검사 ( If-Modified-Since )가 적절히 행해지기 어려운 상황이다.
 - 1. 문서가 일정간격으로 다시 쓰여지지만 실제로는 같은 데이터를 포함하고 있다. 내용 변경은 없지만 변경시간은 바뀔 수 있다.
 - 2. 어떤 문서들은 해당 문서가 변경 되었다고 판단하기에는 너무 사소한 변경들이다. ( ex 주석, 줄간격, 띄어쓰..등등 )
 - 3. 어떤 서버들은 그들이 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판단할 수 없다.
- 이때 If-None-Match 조건부 해더를 사용할 수 있다.( ETag )
#### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가 ?
 - 둘 중 헤더값에 있는 것을 사용하되 둘 다 있다면 둘 다 사용한다. ( 둘 중 하나로는 완벽하게 처리 안됨)
 - 다음 2가지 경우를 가정해 보자
   - 1. max-age만 있는경우 : max-age 시간이 다 됬을때 ETag가 없는경우 ? -> 서버에서 새로운 데이터를 받아와야 되지만, ETag가 있는경우라면 ETag값만 비교해서 서버값과 다르면 받아오고 아닐경우는 안받아온다.
   - 2. ETag만 있는 경우 : 매번 서버와 ETag값을 비교해야됨.
   - -> 따라서, max-age와 ETag값 둘다 있다면 ? 기본적으로 max-age가 다 될 때까지는 유효하다고 생각하고 캐시에있는값 리턴하고 max-age가 다 되면 ETag값을 서버와 비교해서 다르면 받아오고 아니면 max-age 없데이트. ( 만약, max-age가 다 안됬는데 서버에서 값이 바뀌었다면 ? 어떻게 되는가 ? max-age 시간이 될때 까지는 신선하지 않은 정보를 주는건가? 이럴때 Cache-Control: must-revalidate를 하면 서버와 매번 검사하니까 신선한 정보를 줄 수 있을거 같긴한데... 매번 검사하니까 느릴거같음.. -> 파일이름을 바꾸는 방법이 한가지 대안이 될 수 있다. )
### 7.9 캐시 제어
 - HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러가지 방법을 정의한다.
 - 우선순위 대로 나열하면 다음과 같다.
 -  Cache-Control : no-store 헤더를 응답에 첨부할 수 있다.
 -  Cache-Control : no-cache 헤더를 응답에 첨부할 수 있다.
 -  Cache-Control : must-revalidate 헤더를 응답에 첨부할 수 있다.
 -  Cache-Control : max-age 헤더를 응답에 첨부할 수 있다.
 -  Expires 날짜 헤더를 응답에 첨부할 수 있다.
 -  아무 만료 정보도 주지 않고, 캐시 스스로가 휴리스틱한 방법으로 결정하게 할 수 있다.
##### 7.9.1 no-cache와 no-store 응답 헤더
 - HTTP/1.1은 신선도를 관리하기 위해, 객체를 캐시하는 것을 제한하거나 캐시된 객체를 제공하는 여러가지 방법을 제공한다. 
- 'no-cache'는 캐시를 쓰지말라는게 아니라 모든 캐시를 쓰기전에 서버에서 이 캐시가 신선한지 재검사를 해야된다는 뜻이다.
 - 'no-store'가 표시된 응답은 캐시가 그 응답의 사본을 만드는 것을 금지한다.  ( max-age가 0이라는 뜻이다. 요청할때마다 ETag를 검사한다.)
 - 'no-store'로 표시된 응답은 사실 로컬 캐시 저장소에 저장될 수 있다. 다만 먼저, 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없다.
 - Pragma: no-cache 헤더는 HTTP/1.0+와의 하위호환성을 위해 HTTP/1.1에 포함되어 있다. 1.0 에플리케이션에 대응해야 하는것이 아니라면 Cache-Control: no-cache를 사용한다.
##### 7.9.2 Max-Age 응답 헤더
 - Cache-Control: max-age 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간이고, 초로 나타낸다. ( 해당 초 만큼 유효하다는 뜻이다. )
 - 서버는 max-age를 0으로 설정함으로써, 매 접근마다 문서를 캐시하거나 리프레시 하지 않도록 할 수 있다. ( max-age를 0으로 설정하면 0초동안 유효하는 뜻이다. 즉, 유효하지 않다는 뜻이므로 서버로 부터 데이터 받아온다. )
 - age 해더를 통해 max-age 시간 내에서 얼마나 시간이 흘렀는지 초 단위로 확인할 수 있다.
```
  age: 21598
  cache-control: public, max-age=31536000
```
- 해당 캐시는 31536000초 만큼 유효한데 캐시가 내 pc에 머물러 있는 시간은 현재 21598만큼의 시간이 흘렀다. -> age 헤더는 실시간으로 안바뀌는건가? (테스트)
##### 7.9.3 Expires 응답 헤더
 - Deprecated 
 - Expires 헤더는 실제 만료 날짜를 명시한다. -> 모든 pc의 시간이 동기화 되어있지 않기 때문에 정확하지 않을 수 있다.
##### 7.9.4 Must-Revalidate 응답 헤더
 - 캐시는 성능을 개선하기 위해 신선하지 않은(만료된) 객체를 제공하도록 설정될 수 있다. 만약, 캐시가 만료 정보를 엄격하게 따르길 원한다면, Cache-Control: must-revalidate를 붙여준다.
 - Cache-Control: must-revalidate 응답 헤더는 캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안됨을 의미한다.
##### 7.9.5 휴리스틱 만료
 - 만약, 응답이 Cache-Control: max-age 헤더나 Expires 헤더 중 어느 것도 포함하지 않고 있다면, 캐시는 경험적인 방법으로 최대 나의를 계산할 것이다. 
##### 7.9.6 클라이언트 신선도 제약
 - 웹 브라우저의 리프레시 버튼은 신선하지 않은 콘텐츠를 강제로 갱신시켜 ( = Cache-control 요청 헤더가 추가된 GET 요청을 발생시켜서), 강제로 재검사 하거나 서버로부터 콘텐츠를 무조건 가져온다. 

### 8장 통합점: 게이트웨이, 터널, 릴레이
 - 게이트 웨이 : 서로 다른 프로토콜과 에플리케이션 간의 HTTP 인터페이스
 - 터널 : HTTP 커넥션을 통해서 HTTP 가 아닌 트래픽을 전송하는 데 사용된다.
 - 릴레이 : 단순한 HTTP 프락시로, 한 번에 한 개의 홉에 데이터를 전달하는 데 사용한다.

#### 8.1 게이트 웨이
 - 게이트웨이는 리소스와 에플리케이션을 연결하는 역할을 한다.
 - 게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동으로 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 하기도 한다.
 - 3가지 예시 ( 그림 8-2 )
##### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이
 - 웹 게이트웨이는 한쪽에서는 HTTP로 통신하고 다른 한쪽에서는 HTTP가 아닌 다른 프로토콜로 통신한다. ( 클라이언트 측 프로토콜과 서버 측 프로토콜을 빗금으로 구분한다.)
- 서버 측 게이트웨이는 클라이언트와 HTTP로 통신하고, 서버와는 외래 프로토콜로 통신한다. ( 그림 8-2 a )
- 클라이언트 측 게이트웨이는 클라이언트와 외래 프로토콜로 통신하고, 서버와는 HTTP로 통신한다. ( 그림 8-2 b )

#### 8.2 프로토콜 게이트웨이
 - 그림 8-3, 8-4, 8-5, 8-6, 8-7 설명

#### 8.3 리소스 게이트웨이
 - CGI 란 ? -> 클라이언트 <-> WAS <-> DB

#### 8.5 터널
 - 웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 에플리케이션을 사용해 접근하는 방법을 제공한다. 
 - 웹 터널을 사용하면 HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP 위에 올릴 수 있다.
##### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기
 - 웹 터널은 HTTP의 CONNECT 메서드를 사용하여 커넥션을 맺는다.
 - CONNECT 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기를 요청한다. ( 그림 8-10 참조)
##### CONNECT 요청
 - CONNECT 문법은 시작줄을 제외하고는 다른 HTTP 메서드와 같다. 
```
  CONNECT home.netscape.com:443 HTTP/1.0
  User-agent: Mozillia/4.0
```
##### CONNECT 응답
 - 일반적인 응답과는 달리 Content-Type 헤더를 포함할 필요는 없다. 커넥션이 메시지를 전달하는 대신 바이트를 그대로 전달하기 때문에.
```
  HTTP/1.0 200 Connection Established
  Proxy-agent: Netscape-Proxy/1.1
```
##### 8.5.3 SSL 터널링 ( 질문 )
 - SSL 같이 암호화된 프로토콜은 정보가 암호화되어 있기 때문에 낡은 방식의 프락시에서는 처리되지 않는다.
 - 터널은 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송하여 80 포트의 HTTP만을 허용하는 방화벽을 통화시킬 수 있다.
##### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이
##### 8.5.5 터널 인증
##### 8.5.6 터널 보안에 대한 고려사항들
#### 8.6 릴레이
 - HTTP 릴레이는 HTTP 명세를 완전히는 준수하지 않는 간단한 HTTP 프락시이다.
 - 릴레이 역시 프락시이기 때문에 connection 해더를 제대로 처리하지 못할 경우 Keep-alive 커넥션 행에 걸릴수 있다. ( 프락시는 connection 헤더를 알지 못함. )


