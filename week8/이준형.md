# 4부 엔터티, 인코딩, 국제화(p.391)
## 15장 엔터티와 인코딩(p.393)
- HTTP는 매일 엄청나게 많은 양의 미디어 객체를 실어 나른다.
- 미디어 객체란 이미지, 텍스트, 동영상 등을 의미한다.
- HTTP는 이것이 올바르게 전송되고, 식별되고, 추출되고, 처리되는 것을 보장한다.
- 이것을 위해 HTTP는 콘텐츠를 나르기 위한 잘 라벨링된 엔터티를 사용한다.

### 15.1 메시지는 컨테이너, 엔터티는 화물(p.394)
- HTTP 메시지를 운송 시스템의 컨테이너라고 생각하면, HTTP 엔터티는 컨테이너에 실린 화물이다.
- 다음 엔터티 헤더는 18자에 불과한 플레인 텍스트 문서를 의미한다.
```
HTTP/1.0 200 OK
Server: Netscape-Enterprise/3.6
Date: Sun, 17 Sep 2000 00:01:05 GMT
Content-type: text/plain
Content-length: 18

Hi! I'm a message!
```
- 엔터티 헤더별로 다음과 같은 의미를 나타낸다.
    - Content-Type : 엔터티에 의해 전달된 객체 종류(MIME)
    - Content-Length : 전달되는 메시지의 길이나 크기
    - Content-Language : 전달되는 객체와 가장 잘 대응되는 자연어
    - Content-Encoding : 객체 데이터에 대해 행해진 변형(압축 등)
    - Content-Location : 요청 시점을 기준으로, 객체의 또 다른 위치
    - Content-Range : 해당 엔터티가 부분 엔터티라면, 전체에서 어느 부분인지 알려줌
    - Content-MD5 : 엔터티 본문의 체크섬(md5)
    - Last-Modified : 이 컨텐츠가 생성 혹은 수정된 시간
    - Expires : 이 컨텐츠가 더 이상 신선하지 않다고 간주되는 시간
    - Allow : 이 리소스가 어떤 요청 메서드를 허용하는지
    - Etag : 15.7에서 다시 언급, (엄밀히 말하면 엔터티 해더 아님.)
    - Cache-Control : 이 문서가 어떻게 캐시될 수 있는지에 대한 지시자 (엄밀히 말하면 엔터티 해더 아님.)

#### 15.1.1 엔터티 본문(p.396)
- 엔터티 본문은 가공되지 않은 데이터만을 가지고 있다.
- 그 외 엔터티에 대한 정보는 엔터티 헤더에 있다.
- 엔터티 본문은 헤더 필드의 끝을 의미하는 CRLF 줄 바로 다음부터 시작한다.
- [그림 15-2]를 보면 16 진수로 표현된 HTTP 패킷의 CRLF(0x0D0A)를 확인할 수 있다.

### 15.2 Content-Length: 엔터티의 길이(p.397)
- Content-Length는 엔터티 본문의 크기를 나타낸다.
- gzip으로 압축된 텍스트 파일의 경우 원래 크기가 아닌 압축된 후의 크기이다.
- 메시지를 청크 인코딩으로 전송하지 않는 이상, 필수적인 헤더이다.

#### 15.2.1 잘림 검출(p.397)
- 옛날 HTTP는 커넥션이 닫히면 메시지가 끝났다고 인지했다. 이때 Content-Length가 없다면 커넥션이 정상적으로 닫힌 것인지 메시지가 전송 중에 crash가 발생해서 닫힌 것인지 구분할 수 없다.
- 때문에 클라이언트는 메시지가 잘렸는지를 확인하기 위해 Content-Length를 필요로 한다.

#### 15.2.2 잘못된 Content-Length(p.398)
- Content-Length를 빠뜨린 것보다 위험할 수 있는게 Content-Length를 잘못 가지고 있는 것이다.
- 초칭기 서버와 클라이언트들은 이 계산과 관련된 버그를 가지고 있었다. (요즘은 드물듯)

#### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)
- Content-Length는 지속 커넥션에서는 필수이다. 열려있는 커넥션에서 연속해서 다음 응답이 온다면, 클라이언트 입장에서는 어디가 메시지의 끝인지 알 수 없기 때문이다. (**다음 메시지의 헤더의 내용이 이전 메시지의 본문처럼 취급될 수도 있다는 것이다.**)
- 다만 예외적으로 지속 커넥션을 사용해도 청크 인코딩의 경우 Content-Length가 없어도 된다. (아직 청크가 모두 전송되지 않았다면 계산할 수도 없다.)

#### 15.2.4 콘텐츠 인코딩(p.399)
- HTTP는 보안이나 압축을 위해 엔터티 본문을 압축할 수 있도록 해준다.
- 만약 본문의 컨텐츠가 인코딩되어 있다면, Content-Length 헤더는 인코딩 되지 않은 원본의 길이가 아닌 인코딩된 본문의 길이를 바이트 단위로 정의한다.
- **절대 인코딩 되기 전의 사이즈를 보내면 안된다.**

#### 15.2.5 엔터티 본문 길이 판별을 위한 규칙(p.399)
- 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는 Content-Length 헤더가 무시된다. 다만 잘못 구현된 HTTP 애플리케이션은 Content-Length가 언제나 본문이 있으면 그걸 해석하려고 본문을 무시하지 않고 읽는다.
- Transfer-Encoding은 조금 특별하다. 이에 대해선 뒷 부분에서 다시 다룬다.
- multipart/byteranges 미디어 타입을 사용하고 Content-Length가 정의되지 않았다면, 멀티파트 메시지는 각 부분을 각자 스스로 크기를 정의할 것이다. 송신자는 수신자가 이것을 해석할 수 있다는 것을 알기 전까지는 이 헤더를 보내지 않아야한다. -> HTTP1/1은 이 규칙을 따르지 않는다고 한다. (https://developer.mozilla.org/ko/docs/Web/HTTP/Range_requests#%EC%84%9C%EB%B2%84%EC%97%90_%ED%8A%B9%EC%A0%95_%EB%B2%94%EC%9C%84%EB%A5%BC_%EC%9A%94%EC%B2%AD)
- 위의 어떤 규칙에도 해당 안되면, 엔터티는 커넥션이 닫힐 때 끝난다. 다만, 오직 **서버만이 커넥션이 종료되었다고 알리기 위해 커넥션을 닫을 수 있다.** 클라이언트가 먼저 커넥션을 닫으면 서버는 응답을 전달할 방법이 없다.
- HTTP/1.1 명세에는 본문은 있지만 Content-Length는 없는 경우 메시지의 길이를 판별할 수 없다면 400 Bad Request를 응답으로 보내고 유효한 Content-Length를 요구하고 싶다면 411 Length Required 응답을 보내라고 조언하고 있다.

### 15.3 엔터티 요약 -> Entity Digest(p.401)
- HTTP가 TCP/IP 같은 신뢰할 만한(reliable) 전송 프로토콜 위에서 동작함에도 불구하고, 여러가지 이유로 메시지의 일부분이 전송 중에 변형되는 일이 일어난다.
- 이러한 변경을 확인하기 위해 체크섬으로 기본적인 검사를 할 수 있다.
- **Content-MD5는 전송 인코딩을 하지 않은 최초 상태의 본문을 MD5한 결과**이다.

### 15.4 미디어 타입과 차셋(Charset)
- Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다. MIME는 IANA에서 관리한다.
- 주 타입 / 부 타입 으로 구성된다. 예를들면 text/html 처럼.
- [표 15-1]에 자주 사용되는 MIME 타입이 나열되어 있다.

#### 15.4.1 텍스트 매체를 위한 문자 인코딩
- Conetent-Type 헤더는 문자 집합을 알려주기 위해 charset 이라는 값도 추가된다. 이는 16장에서 자세히 다룬다.

#### 15.4.2 멀티파트 미디어 타입(p.403)
- 멀티파트 메시지는 각 파트별로 MIME 타입을 가진다.

#### 15.4.3 멀티파트 폼 제출(p.403)
- 멀티파트 폼으로 제출되는 헤더는 부모 헤더의 경우 multipart/form-data or multipart/mixed 헤더에 멀티파트 본문을 함께 보낸다.
- 자식 헤더에는 각자 자식 컨텐츠 본문에 해당하는 MIME 타입을 가진다.
- 책에 나와있는 예시를 확인하자. 가장 마지막에 있는 예시가 모든걸 종합적으로 보여준다.

#### 15.4.4 멀티파트 범위 응답(p.404)
- 범위 요청 자체에 대한 응답도 multipart가 될 수 있다는 예시를 보여주고 있음.
- 뒷 부분에서 자세히 다시 이야기 한다고함.

### 15.5 콘텐츠 인코딩(p.405)
- HTTP 애플리케이션은 때때로 컨텐츠를 보내기 전에 인코딩을 하려고 함.
- 압축<->해제 과정에 걸리는 시간보다 네트워크 시간이 길다면 압축<->해제를 하는게 유리하다.
- 이 외에도 보안을 위해 인코딩할 수도 있다.

#### 15.5.1 콘텐츠 인코딩 과정(p.405)
- 웹 서버가 원본의 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성
- 컨텐츠 인코딩 서버가 인코딩된 메시지 생성, 인코딩된 메시지의 Content-Length는 달라진다. 인코딩 서버는 Content-Encoding 헤더를 추가하여 수신측이 메시지를 어떻게 디코딩 해야할지 알려준다.
- 수신측은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.
- [그림 15-3]에 위의 과정이 나와있다.

#### 15.5.2 콘텐츠 인코딩 유형(p.407)
- 인코딩은 표준화된 값을 사용하며, 이는 IANA에 의해 관리된다.
- gzip, compress, deflate, identity 등이 가장 많이 사용되는 Content-Encoding 이다.
- 각각의 알고리즘은 [표 15-2]에 간단히 나와있고 자세한건 검색해서 확인하면된다.

#### 15.5.3 Accept-Encoding 헤더(p.407)
- 서버는 클라이언트가 이해할 수 있는 인코딩 방식만을 사용해야 하므로 클라이언트 -> 서버로 보내는 요청 헤더에는 Accept-Encoding 헤더가 포함된다. 이 값은 클라이언트가 이해할 수 있는 인코딩 형식을 의미한다.
- 해당 헤더가 없다면 서버는 클라이언트가 어떤 인코딩이든 받아들일 수 있다고 가정한다.
- 여기서도 q 값을 통해 협상을 하게 되는데, 17장에서 자세히 다룬다고 한다.

### 15.6 전송 인코딩과 청크 인코딩(p.408)
- 압축 알고리즘은 콘텐츠 타입에 영향을 많이 받는다. 일반적인 텍스트 파일은 gzip으로 효율적으로 압축되지만, JPEG는 이미 압축된 형태로 gzip으로는 잘 압축되지 않는다.
- 콘텐츠 인코딩은 엔터티 부분만 인코딩하지만, **전송 인코딩은 메시지 전체에 대해 인코딩**한다.
- [그림 15-5]를 보면 Transfer-encoding: chuncked로 표시되어 있고 아래부분에 인코딩된 블록이 존재하는 것을 확인할 수 있다.

#### 15.6.1 안전한 전송(p.409)
- 역사적으로 전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 '안전한 전송'을 위해 존재했다.
- 이 안전한 전송 이라는건 여러가지 의미로 사용될 수 있는데 HTTP에서는 주된 의미는 다음 2가지를 의미한다.
    - 알 수 없는 크기 : 어떤 컨텐츠들은 그 컨텐츠의 전체 사이즈를 알기 전에 데이터의 전송을 시작하려고 한다. 이 때 Content-Length에 컨텐츠의 길이를 넣을 수 없기 때문에 HTTP는 청크 조각들의 끝을 의미하는 데이터를 보내기 전까지 조각조각의 데이터를 보낸다.
    - 보안 : 공용 전송 네트워크로 메시지 컨텐츠를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 뒤섞어 버릴 수도 있다. 하지만 HTTPS가 이미 전송 계층에서의 보안을 담당하기 때문에 보안을 위한 전송 인코딩은 흔하지 않다.

#### 15.6.2 Transfer-Encoding 헤더(p.410)
- 전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 단 두개다.
- Transfer-Encoding : 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.
- TE : 어떤 확장된 전송 인코딩을 사용할 수 있는지 상대에게 알려주기 위해 요청 헤더에 사용한다. (Accept-Transfer-Encoding이 더 직관적이었을텐데.. 라고 저자의 각주가 있다.)
- Trailer? : https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Trailer
- HTTP/1.1 에서는 청크 인코딩을 반드시 제공하도록 정의한다.
- HTTP/1.1 이후에 새로운 HTTP 확장잉 나왔을 때 새로운 전송 인코딩이 추가된다면, 청크 전송 인코딩은 가장 높은 우선순위로 적용되어야함.

#### 15.6.3 청크 인코딩(p.411)
- 청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갠다. 서버는 각 청크를 순차적으로 보낸다.
- 청크 인코딩을 사용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없어진다. 본문이 동적으로 생성됨에 따라 그 일부를 청크로 만들고 전송한다. 이것을 본문을 모두 보낼 때까지 반복한다.
- 청크 인코딩은 전송 인코딩의 한 형태로, **본문의 속성을 의미하는 것이 아니라 메시지의 속성을 의미**한다. 즉, 멀티파트 인코딩과 다르다. (멀티파트는 본문을 인코딩)
- 청크와 지속 커넥션
    - 지속 커넥션이 아니라면 클라이언트는 본문의 길이를 알 필요가 없다. 서버가 보내주는 걸 끝내는 곳 까지가 본문이기 때문에.
    - 하지만 지속커넥션에서는 본문을 쓰기 전에 반드시 Content-Length를 포함해야한다. 하지만 동적으로 생성되는 컨텐츠는 그 길이를 알 수 없다.
    - 청크 인코딩은 이 문제를 해결할 수 있다. 서버는 마지막에 크기가 0인 청크로 끝을 알린다. 그 전까지는 동적으로 청크를 계속 보낼 수 있다.
    - [그림 15-6]이 청크 인코딩으로 전송되는 데이터의 구조를 보여준다.
- 청크 인코딩된 메시지의 트레일러
    - 클라이언트가 TE 헤더로 트레일러를 받아들일 수 있음을 알렸거나, 트레일러의 컨텐츠를 클라이언트가 이해하고 사용할 필요가 없는 경우 청크 메시지의 트레일러를 사용할 수 있다.
    - [그림 15-6]에서 마지막에 트레일러를 포함하고 있다. 클라이언트는 Trailer 헤더에 명시된 Content-MD5 헤더가 청크에 포함될 때까지 계속 메시지를 읽을 것이다.

#### 15.6.4 콘텐츠와 전송 인코딩의 조합(p.413)
- 콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다. ex. gzip으로 압축된걸 청크로 전송할 수 있다. [그림 15-7] 참고
- **조립은 분해의 역순이다.**

#### 15.6.5 전송 인코딩 규칙(p.414)
- 전송 인코딩이 메시지 본문에 적용될 때 몇가지 규칙이 있다.
    - 'chuncked'를 반드시 포함해야한다. 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우뿐
    - 청크 인코딩을 사용했다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야한다. (끝을 알려야한다.)
    - 청크 전송 인코딩은 반드시 메시지 본문에 한번 이상 적용되어야 한다.
- 이러한 규칙은 수신자가 메시지의 전송 길이를 알아낼 수 있게 해준다.
- 전송 인코딩을 구현한 서버는 비 HTTP/1.1에 전송 인코딩된 메시지를 보내지 않아야한다.(TE 헤더를 통해 알 수 있다.)
- 마찬가지로 서버는 이해할 수 없는 전송 인코딩된 메시지를 받았다면 501 Unimplemented 상태 코드를 응답해야 한다.
- HTTP/1.1 애플리케이션이라면 반드시 최소 청크 인코딩은 전송 인코딩으로 지원해야 한다.

### 15.7 시간에 따라 바뀌는 인스턴스(p.414)
- 웹 객체는 정적이지 않다. http://www.daum.net 만 들어가 보아도 매 시간 다른 결과를 보인다.
- HTTP 프로토콜은 클라이언트가 자신이 가지고 있는 리소스와 서버가 가지고 있는 리소스가 같은지 판별하는 방법을 가지고 있다. 이를 인스턴스 조작이라고 한다.
- 대표적으로 범위 요청과 델타 인코딩이 있다.
- 이에 대해선 뒷 부분에서 다시 언급한다.

### 15.8 검사기와 신선도(p.415)
- 여기는 캐시에서 했던 이야기가 다시 나오는 듯..

### 15.9 범위 요청(p.419)
- HTTP에서는 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해준다.
- Range 헤더를 이용해서 요청하면 그에 해당하는 Byte들을 반환한다.
- 만약 여러 범위를 요청했다면 응답은 multipart/byteranges로 반환될 것이다.
- [그림 15-9]를 참고하자.

### 15.10 델타 인코딩(p.421)
- 앞서 나온 여러가지 캐시 방법들은 문서 전체에 대해 캐시하는 방법에 대해 설명했다면 **델타 인코딩은 문서에서 변경된 부분만을 요청/응답하는 방법에 대한 것**이다.
- RFC 3329에서 델타 인코딩에 대해 기술하고 있다. https://tools.ietf.org/html/rfc3229
- [그림 15-10]을 참고해보자. 본문 마지막에 hammers -> chisels 로 변경된 부분을 델타 인코딩으로 주고 받는다.
- 226 IM Used라는 응답 코드를 사용한다.
- A-IM 헤더는 **A**ccept-**I**nstance-**M**anipulation의 줄임말임.

#### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기(p.424)
- [그림 15-10]에서 5c는 base 문서의 5번째 줄을 지우라는 의미이고, 'chisels.'는 chisels.를 추가하라는 의미이다. 
- 델타 인코딩은 전송 시간을 줄일 수는 있지만 구현하기가 까다로울 수 있다. 변경이 잦고 사용자가 많은 경우 델타 인코딩을 지원하는 서버는 자신이 제공하는 페이지가 변경되는 매 순간의 사본을 모두 유지하고 있어야한다. 그래야 원본과 최신 사본 간의 차이를 델타로 나타낼 수 있다.
- 이는 서버가 유지해야할 디스크의 공간을 늘려야 하는 결과를 가져올 수 있다.

