# 4부 엔터티, 인코딩, 국제화(p.391)
## 15장 엔터티와 인코딩(p.393)
- HTTP는 매일 엄청나게 많은 양의 미디어 객체를 실어 나른다.
- 미디어 객체란 이미지, 텍스트, 동영상 등을 의미한다.
- HTTP는 이것이 올바르게 전송되고, 식별되고, 추출되고, 처리되는 것을 보장한다.
- 이것을 위해 HTTP는 콘텐츠를 나르기 위한 잘 라벨링된 엔터티를 사용한다.

### 15.1 메시지는 컨테이너, 엔터티는 화물(p.394)
- HTTP 메시지를 운송 시스템의 컨테이너라고 생각하면, HTTP 엔터티는 컨테이너에 실린 화물이다.
- 다음 엔터티 헤더는 18자에 불과한 플레인 텍스트 문서를 의미한다.
```
HTTP/1.0 200 OK
Server: Netscape-Enterprise/3.6
Date: Sun, 17 Sep 2000 00:01:05 GMT
Content-type: text/plain
Content-length: 18

Hi! I'm a message!
```
- 엔터티 헤더별로 다음과 같은 의미를 나타낸다.
    - Content-Type : 엔터티에 의해 전달된 객체 종류(MIME)
    - Content-Length : 전달되는 메시지의 길이나 크기
    - Content-Language : 전달되는 객체와 가장 잘 대응되는 자연어
    - Content-Encoding : 객체 데이터에 대해 행해진 변형(압축 등)
    - Content-Location : 요청 시점을 기준으로, 객체의 또 다른 위치
    - Content-Range : 해당 엔터티가 부분 엔터티라면, 전체에서 어느 부분인지 알려줌
    - Content-MD5 : 엔터티 본문의 체크섬(md5)
    - Last-Modified : 이 컨텐츠가 생성 혹은 수정된 시간
    - Expires : 이 컨텐츠가 더 이상 신선하지 않다고 간주되는 시간
    - Allow : 이 리소스가 어떤 요청 메서드를 허용하는지
    - Etag : 15.7에서 다시 언급, (엄밀히 말하면 엔터티 해더 아님.)
    - Cache-Control : 이 문서가 어떻게 캐시될 수 있는지에 대한 지시자 (엄밀히 말하면 엔터티 해더 아님.)

#### 15.1.1 엔터티 본문(p.396)
- 엔터티 본문은 가공되지 않은 데이터만을 가지고 있다.
- 그 외 엔터티에 대한 정보는 엔터티 헤더에 있다.
- 엔터티 본문은 헤더 필드의 끝을 의미하는 CRLF 줄 바로 다음부터 시작한다.
- [그림 15-2]를 보면 16 진수로 표현된 HTTP 패킷의 CRLF(0x0D0A)를 확인할 수 있다.

### 15.2 Content-Length: 엔터티의 길이(p.397)
- Content-Length는 엔터티 본문의 크기를 나타낸다.
- gzip으로 압축된 텍스트 파일의 경우 원래 크기가 아닌 압축된 후의 크기이다.
- 메시지를 청크 인코딩으로 전송하지 않는 이상, 필수적인 헤더이다.

#### 15.2.1 잘림 검출(p.397)
- 옛날 HTTP는 커넥션이 닫히면 메시지가 끝났다고 인지했다. 이때 Content-Length가 없다면 커넥션이 정상적으로 닫힌 것인지 메시지가 전송 중에 crash가 발생해서 닫힌 것인지 구분할 수 없다.
- 때문에 클라이언트는 메시지가 잘렸는지를 확인하기 위해 Content-Length를 필요로 한다.

#### 15.2.2 잘못된 Content-Length(p.398)
- Content-Length를 빠뜨린 것보다 위험할 수 있는게 Content-Length를 잘못 가지고 있는 것이다.
- 초칭기 서버와 클라이언트들은 이 계산과 관련된 버그를 가지고 있었다. (요즘은 드물듯)

#### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)
- Content-Length는 지속 커넥션에서는 필수이다. 열려있는 커넥션에서 연속해서 다음 응답이 온다면, 클라이언트 입장에서는 어디가 메시지의 끝인지 알 수 없기 때문이다. (**다음 메시지의 헤더의 내용이 이전 메시지의 본문처럼 취급될 수도 있다는 것이다.**)
- 다만 예외적으로 지속 커넥션을 사용해도 청크 인코딩의 경우 Content-Length가 없어도 된다. (아직 청크가 모두 전송되지 않았다면 계산할 수도 없다.)

#### 15.2.4 콘텐츠 인코딩(p.399)
- HTTP는 보안이나 압축을 위해 엔터티 본문을 압축할 수 있도록 해준다.
- 만약 본문의 컨텐츠가 인코딩되어 있다면, Content-Length 헤더는 인코딩 되지 않은 원본의 길이가 아닌 인코딩된 본문의 길이를 바이트 단위로 정의한다.
- **절대 인코딩 되기 전의 사이즈를 보내면 안된다.**

#### 15.2.5 엔터티 본문 길이 판별을 위한 규칙(p.399)
- 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는 Content-Length 헤더가 무시된다. 다만 잘못 구현된 HTTP 애플리케이션은 Content-Length가 언제나 본문이 있으면 그걸 해석하려고 본문을 무시하지 않고 읽는다.
- Transfer-Encoding은 조금 특별하다. 이에 대해선 뒷 부분에서 다시 다룬다.
- multipart/byteranges 미디어 타입을 사용하고 Content-Length가 정의되지 않았다면, 멀티파트 메시지는 각 부분을 각자 스스로 크기를 정의할 것이다. 송신자는 수신자가 이것을 해석할 수 있다는 것을 알기 전까지는 이 헤더를 보내지 않아야한다. -> HTTP1/1은 이 규칙을 따르지 않는다고 한다. (https://developer.mozilla.org/ko/docs/Web/HTTP/Range_requests#%EC%84%9C%EB%B2%84%EC%97%90_%ED%8A%B9%EC%A0%95_%EB%B2%94%EC%9C%84%EB%A5%BC_%EC%9A%94%EC%B2%AD)
- 위의 어떤 규칙에도 해당 안되면, 엔터티는 커넥션이 닫힐 때 끝난다. 다만, 오직 **서버만이 커넥션이 종료되었다고 알리기 위해 커넥션을 닫을 수 있다.** 클라이언트가 먼저 커넥션을 닫으면 서버는 응답을 전달할 방법이 없다.
- HTTP/1.1 명세에는 본문은 있지만 Content-Length는 없는 경우 메시지의 길이를 판별할 수 없다면 400 Bad Request를 응답으로 보내고 유효한 Content-Length를 요구하고 싶다면 411 Length Required 응답을 보내라고 조언하고 있다.

### 15.3 엔터티 요약 -> Entity Digest(p.401)
- HTTP가 TCP/IP 같은 신뢰할 만한(reliable) 전송 프로토콜 위에서 동작함에도 불구하고, 여러가지 이유로 메시지의 일부분이 전송 중에 변형되는 일이 일어난다.
- 이러한 변경을 확인하기 위해 체크섬으로 기본적인 검사를 할 수 있다.
- **Content-MD5는 전송 인코딩을 하지 않은 최초 상태의 본문을 MD5한 결과**이다.

### 15.4 미디어 타입과 차셋(Charset)
- Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다. MIME는 IANA에서 관리한다.
- 주 타입 / 부 타입 으로 구성된다. 예를들면 text/html 처럼.
- [표 15-1]에 자주 사용되는 MIME 타입이 나열되어 있다.

#### 15.4.1 텍스트 매체를 위한 문자 인코딩
- Conetent-Type 헤더는 문자 집합을 알려주기 위해 charset 이라는 값도 추가된다. 이는 16장에서 자세히 다룬다.

#### 15.4.2 멀티파트 미디어 타입(p.403)
- 멀티파트 메시지는 각 파트별로 MIME 타입을 가진다.

#### 15.4.3 멀티파트 폼 제출(p.403)
- 멀티파트 폼으로 제출되는 헤더는 부모 헤더의 경우 multipart/form-data or multipart/mixed 헤더에 멀티파트 본문을 함께 보낸다.
- 자식 헤더에는 각자 자식 컨텐츠 본문에 해당하는 MIME 타입을 가진다.
- 책에 나와있는 예시를 확인하자. 가장 마지막에 있는 예시가 모든걸 종합적으로 보여준다.

#### 15.4.4 멀티파트 범위 응답(p.404)
- 범위 요청 자체에 대한 응답도 multipart가 될 수 있다는 예시를 보여주고 있음.
- 뒷 부분에서 자세히 다시 이야기 한다고함.