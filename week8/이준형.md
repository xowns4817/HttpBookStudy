# 4부 엔터티, 인코딩, 국제화(p.391)
## 15장 엔터티와 인코딩(p.393)
- HTTP는 매일 엄청나게 많은 양의 미디어 객체를 실어 나른다.
- 미디어 객체란 이미지, 텍스트, 동영상 등을 의미한다.
- HTTP는 이것이 올바르게 전송되고, 식별되고, 추출되고, 처리되는 것을 보장한다.
- 이것을 위해 HTTP는 콘텐츠를 나르기 위한 잘 라벨링된 엔터티를 사용한다.

### 15.1 메시지는 컨테이너, 엔터티는 화물(p.394)
- HTTP 메시지를 운송 시스템의 컨테이너라고 생각하면, HTTP 엔터티는 컨테이너에 실린 화물이다.
- 다음 엔터티 헤더는 18자에 불과한 플레인 텍스트 문서를 의미한다.
```
HTTP/1.0 200 OK
Server: Netscape-Enterprise/3.6
Date: Sun, 17 Sep 2000 00:01:05 GMT
Content-type: text/plain
Content-length: 18

Hi! I'm a message!
```
- 엔터티 헤더별로 다음과 같은 의미를 나타낸다.
    - Content-Type : 엔터티에 의해 전달된 객체 종류(MIME)
    - Content-Length : 전달되는 메시지의 길이나 크기
    - Content-Language : 전달되는 객체와 가장 잘 대응되는 자연어
    - Content-Encoding : 객체 데이터에 대해 행해진 변형(압축 등)
    - Content-Location : 요청 시점을 기준으로, 객체의 또 다른 위치
    - Content-Range : 해당 엔터티가 부분 엔터티라면, 전체에서 어느 부분인지 알려줌
    - Content-MD5 : 엔터티 본문의 체크섬(md5)
    - Last-Modified : 이 컨텐츠가 생성 혹은 수정된 시간
    - Expires : 이 컨텐츠가 더 이상 신선하지 않다고 간주되는 시간
    - Allow : 이 리소스가 어떤 요청 메서드를 허용하는지
    - Etag : 15.7에서 다시 언급, (엄밀히 말하면 엔터티 해더 아님.)
    - Cache-Control : 이 문서가 어떻게 캐시될 수 있는지에 대한 지시자 (엄밀히 말하면 엔터티 해더 아님.)

#### 15.1.1 엔터티 본문(p.396)
- 엔터티 본문은 가공되지 않은 데이터만을 가지고 있다.
- 그 외 엔터티에 대한 정보는 엔터티 헤더에 있다.
- 엔터티 본문은 헤더 필드의 끝을 의미하는 CRLF 줄 바로 다음부터 시작한다.
- [그림 15-2]를 보면 16 진수로 표현된 HTTP 패킷의 CRLF(0x0D0A)를 확인할 수 있다.

### 15.2 Content-Length: 엔터티의 길이(p.397)
- Content-Length는 엔터티 본문의 크기를 나타낸다.
- gzip으로 압축된 텍스트 파일의 경우 원래 크기가 아닌 압축된 후의 크기이다.
- 메시지를 청크 인코딩으로 전송하지 않는 이상, 필수적인 헤더이다.

#### 15.2.1 잘림 검출(p.397)
- 옛날 HTTP는 커넥션이 닫히면 메시지가 끝났다고 인지했다. 이때 Content-Length가 없다면 커넥션이 정상적으로 닫힌 것인지 메시지가 전송 중에 crash가 발생해서 닫힌 것인지 구분할 수 없다.
- 때문에 클라이언트는 메시지가 잘렸는지를 확인하기 위해 Content-Length를 필요로 한다.

#### 15.2.2 잘못된 Content-Length(p.398)
- Content-Length를 빠뜨린 것보다 위험할 수 있는게 Content-Length를 잘못 가지고 있는 것이다.
- 초칭기 서버와 클라이언트들은 이 계산과 관련된 버그를 가지고 있었다. (요즘은 드물듯)

#### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)
- Content-Length는 지속 커넥션에서는 필수이다. 열려있는 커넥션에서 연속해서 다음 응답이 온다면, 클라이언트 입장에서는 어디가 메시지의 끝인지 알 수 없기 때문이다. (**다음 메시지의 헤더의 내용이 이전 메시지의 본문처럼 취급될 수도 있다는 것이다.**)
- 다만 예외적으로 지속 커넥션을 사용해도 청크 인코딩의 경우 Content-Length가 없어도 된다. (아직 청크가 모두 전송되지 않았다면 계산할 수도 없다.)

#### 15.2.4 콘텐츠 인코딩(p.399)
- HTTP는 보안이나 압축을 위해 엔터티 본문을 압축할 수 있도록 해준다.
- 만약 본문의 컨텐츠가 인코딩되어 있다면, Content-Length 헤더는 인코딩 되지 않은 원본의 길이가 아닌 인코딩된 본문의 길이를 바이트 단위로 정의한다.
- **절대 인코딩 되기 전의 사이즈를 보내면 안된다.**

#### 15.2.5 엔터티 본문 길이 판별을 위한 규칙(p.399)
- 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는 Content-Length 헤더가 무시된다. 다만 잘못 구현된 HTTP 애플리케이션은 Content-Length가 언제나 본문이 있으면 그걸 해석하려고 본문을 무시하지 않고 읽는다.
- Transfer-Encoding은 조금 특별하다. 이에 대해선 뒷 부분에서 다시 다룬다.
- multipart/byteranges 미디어 타입을 사용하고 Content-Length가 정의되지 않았다면, 멀티파트 메시지는 각 부분을 각자 스스로 크기를 정의할 것이다. 송신자는 수신자가 이것을 해석할 수 있다는 것을 알기 전까지는 이 헤더를 보내지 않아야한다. -> HTTP1/1은 이 규칙을 따르지 않는다고 한다. (https://developer.mozilla.org/ko/docs/Web/HTTP/Range_requests#%EC%84%9C%EB%B2%84%EC%97%90_%ED%8A%B9%EC%A0%95_%EB%B2%94%EC%9C%84%EB%A5%BC_%EC%9A%94%EC%B2%AD)
- 위의 어떤 규칙에도 해당 안되면, 엔터티는 커넥션이 닫힐 때 끝난다. 다만, 오직 **서버만이 커넥션이 종료되었다고 알리기 위해 커넥션을 닫을 수 있다.** 클라이언트가 먼저 커넥션을 닫으면 서버는 응답을 전달할 방법이 없다.
- HTTP/1.1 명세에는 본문은 있지만 Content-Length는 없는 경우 메시지의 길이를 판별할 수 없다면 400 Bad Request를 응답으로 보내고 유효한 Content-Length를 요구하고 싶다면 411 Length Required 응답을 보내라고 조언하고 있다.

### 15.3 엔터티 요약 -> Entity Digest(p.401)
- HTTP가 TCP/IP 같은 신뢰할 만한(reliable) 전송 프로토콜 위에서 동작함에도 불구하고, 여러가지 이유로 메시지의 일부분이 전송 중에 변형되는 일이 일어난다.
- 이러한 변경을 확인하기 위해 체크섬으로 기본적인 검사를 할 수 있다.
- **Content-MD5는 전송 인코딩을 하지 않은 최초 상태의 본문을 MD5한 결과**이다.

### 15.4 미디어 타입과 차셋(Charset)
- Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다. MIME는 IANA에서 관리한다.
- 주 타입 / 부 타입 으로 구성된다. 예를들면 text/html 처럼.
- [표 15-1]에 자주 사용되는 MIME 타입이 나열되어 있다.

#### 15.4.1 텍스트 매체를 위한 문자 인코딩
- Conetent-Type 헤더는 문자 집합을 알려주기 위해 charset 이라는 값도 추가된다. 이는 16장에서 자세히 다룬다.

#### 15.4.2 멀티파트 미디어 타입(p.403)
- 멀티파트 메시지는 각 파트별로 MIME 타입을 가진다.

#### 15.4.3 멀티파트 폼 제출(p.403)
- 멀티파트 폼으로 제출되는 헤더는 부모 헤더의 경우 multipart/form-data or multipart/mixed 헤더에 멀티파트 본문을 함께 보낸다.
- 자식 헤더에는 각자 자식 컨텐츠 본문에 해당하는 MIME 타입을 가진다.
- 책에 나와있는 예시를 확인하자. 가장 마지막에 있는 예시가 모든걸 종합적으로 보여준다.

#### 15.4.4 멀티파트 범위 응답(p.404)
- 범위 요청 자체에 대한 응답도 multipart가 될 수 있다는 예시를 보여주고 있음.
- 뒷 부분에서 자세히 다시 이야기 한다고함.

### 15.5 콘텐츠 인코딩(p.405)
- HTTP 애플리케이션은 때때로 컨텐츠를 보내기 전에 인코딩을 하려고 함.
- 압축<->해제 과정에 걸리는 시간보다 네트워크 시간이 길다면 압축<->해제를 하는게 유리하다.
- 이 외에도 보안을 위해 인코딩할 수도 있다.

#### 15.5.1 콘텐츠 인코딩 과정(p.405)
- 웹 서버가 원본의 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성
- 컨텐츠 인코딩 서버가 인코딩된 메시지 생성, 인코딩된 메시지의 Content-Length는 달라진다. 인코딩 서버는 Content-Encoding 헤더를 추가하여 수신측이 메시지를 어떻게 디코딩 해야할지 알려준다.
- 수신측은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.
- [그림 15-3]에 위의 과정이 나와있다.

#### 15.5.2 콘텐츠 인코딩 유형(p.407)
- 인코딩은 표준화된 값을 사용하며, 이는 IANA에 의해 관리된다.
- gzip, compress, deflate, identity 등이 가장 많이 사용되는 Content-Encoding 이다.
- 각각의 알고리즘은 [표 15-2]에 간단히 나와있고 자세한건 검색해서 확인하면된다.

#### 15.5.3 Accept-Encoding 헤더(p.407)
- 서버는 클라이언트가 이해할 수 있는 인코딩 방식만을 사용해야 하므로 클라이언트 -> 서버로 보내는 요청 헤더에는 Accept-Encoding 헤더가 포함된다. 이 값은 클라이언트가 이해할 수 있는 인코딩 형식을 의미한다.
- 해당 헤더가 없다면 서버는 클라이언트가 어떤 인코딩이든 받아들일 수 있다고 가정한다.
- 여기서도 q 값을 통해 협상을 하게 되는데, 17장에서 자세히 다룬다고 한다.

### 15.6 전송 인코딩과 청크 인코딩(p.408)
- 압축 알고리즘은 콘텐츠 타입에 영향을 많이 받는다. 일반적인 텍스트 파일은 gzip으로 효율적으로 압축되지만, JPEG는 이미 압축된 형태로 gzip으로는 잘 압축되지 않는다.
- 콘텐츠 인코딩은 엔터티 부분만 인코딩하지만, **전송 인코딩은 메시지 전체에 대해 인코딩**한다.
- [그림 15-5]를 보면 Transfer-encoding: chuncked로 표시되어 있고 아래부분에 인코딩된 블록이 존재하는 것을 확인할 수 있다.

#### 15.6.1 안전한 전송(p.409)
- 역사적으로 전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 '안전한 전송'을 위해 존재했다.
- 이 안전한 전송 이라는건 여러가지 의미로 사용될 수 있는데 HTTP에서는 주된 의미는 다음 2가지를 의미한다.
    - 알 수 없는 크기 : 어떤 컨텐츠들은 그 컨텐츠의 전체 사이즈를 알기 전에 데이터의 전송을 시작하려고 한다. 이 때 Content-Length에 컨텐츠의 길이를 넣을 수 없기 때문에 HTTP는 청크 조각들의 끝을 의미하는 데이터를 보내기 전까지 조각조각의 데이터를 보낸다.
    - 보안 : 공용 전송 네트워크로 메시지 컨텐츠를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 뒤섞어 버릴 수도 있다. 하지만 HTTPS가 이미 전송 계층에서의 보안을 담당하기 때문에 보안을 위한 전송 인코딩은 흔하지 않다.

#### 15.6.2 Transfer-Encoding 헤더(p.410)
- 전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 단 두개다.
- Transfer-Encoding : 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.
- TE : 어떤 확장된 전송 인코딩을 사용할 수 있는지 상대에게 알려주기 위해 요청 헤더에 사용한다. (Accept-Transfer-Encoding이 더 직관적이었을텐데.. 라고 저자의 각주가 있다.)
- Trailer? : https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Trailer
- HTTP/1.1 에서는 청크 인코딩을 반드시 제공하도록 정의한다.
- HTTP/1.1 이후에 새로운 HTTP 확장잉 나왔을 때 새로운 전송 인코딩이 추가된다면, 청크 전송 인코딩은 가장 높은 우선순위로 적용되어야함.

#### 15.6.3 청크 인코딩(p.411)
- 청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갠다. 서버는 각 청크를 순차적으로 보낸다.
- 청크 인코딩을 사용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없어진다. 본문이 동적으로 생성됨에 따라 그 일부를 청크로 만들고 전송한다. 이것을 본문을 모두 보낼 때까지 반복한다.
- 청크 인코딩은 전송 인코딩의 한 형태로, **본문의 속성을 의미하는 것이 아니라 메시지의 속성을 의미**한다. 즉, 멀티파트 인코딩과 다르다. (멀티파트는 본문을 인코딩)
- 청크와 지속 커넥션
    - 지속 커넥션이 아니라면 클라이언트는 본문의 길이를 알 필요가 없다. 서버가 보내주는 걸 끝내는 곳 까지가 본문이기 때문에.
    - 하지만 지속커넥션에서는 본문을 쓰기 전에 반드시 Content-Length를 포함해야한다. 하지만 동적으로 생성되는 컨텐츠는 그 길이를 알 수 없다.
    - 청크 인코딩은 이 문제를 해결할 수 있다. 서버는 마지막에 크기가 0인 청크로 끝을 알린다. 그 전까지는 동적으로 청크를 계속 보낼 수 있다.
    - [그림 15-6]이 청크 인코딩으로 전송되는 데이터의 구조를 보여준다.
- 청크 인코딩된 메시지의 트레일러
    - 클라이언트가 TE 헤더로 트레일러를 받아들일 수 있음을 알렸거나, 트레일러의 컨텐츠를 클라이언트가 이해하고 사용할 필요가 없는 경우 청크 메시지의 트레일러를 사용할 수 있다.
    - [그림 15-6]에서 마지막에 트레일러를 포함하고 있다. 클라이언트는 Trailer 헤더에 명시된 Content-MD5 헤더가 청크에 포함될 때까지 계속 메시지를 읽을 것이다.

#### 15.6.4 콘텐츠와 전송 인코딩의 조합(p.413)
- 콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다. ex. gzip으로 압축된걸 청크로 전송할 수 있다. [그림 15-7] 참고
- **조립은 분해의 역순이다.**

#### 15.6.5 전송 인코딩 규칙(p.414)
- 전송 인코딩이 메시지 본문에 적용될 때 몇가지 규칙이 있다.
    - 'chuncked'를 반드시 포함해야한다. 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우뿐
    - 청크 인코딩을 사용했다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야한다. (끝을 알려야한다.)
    - 청크 전송 인코딩은 반드시 메시지 본문에 한번 이상 적용되어야 한다.
- 이러한 규칙은 수신자가 메시지의 전송 길이를 알아낼 수 있게 해준다.
- 전송 인코딩을 구현한 서버는 비 HTTP/1.1에 전송 인코딩된 메시지를 보내지 않아야한다.(TE 헤더를 통해 알 수 있다.)
- 마찬가지로 서버는 이해할 수 없는 전송 인코딩된 메시지를 받았다면 501 Unimplemented 상태 코드를 응답해야 한다.
- HTTP/1.1 애플리케이션이라면 반드시 최소 청크 인코딩은 전송 인코딩으로 지원해야 한다.

### 15.7 시간에 따라 바뀌는 인스턴스(p.414)
- 웹 객체는 정적이지 않다. http://www.daum.net 만 들어가 보아도 매 시간 다른 결과를 보인다.
- HTTP 프로토콜은 클라이언트가 자신이 가지고 있는 리소스와 서버가 가지고 있는 리소스가 같은지 판별하는 방법을 가지고 있다. 이를 인스턴스 조작이라고 한다.
- 대표적으로 범위 요청과 델타 인코딩이 있다.
- 이에 대해선 뒷 부분에서 다시 언급한다.

### 15.8 검사기와 신선도(p.415)
- 여기는 캐시에서 했던 이야기가 다시 나오는 듯..

### 15.9 범위 요청(p.419)
- HTTP에서는 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해준다.
- Range 헤더를 이용해서 요청하면 그에 해당하는 Byte들을 반환한다.
- 만약 여러 범위를 요청했다면 응답은 multipart/byteranges로 반환될 것이다.
- [그림 15-9]를 참고하자.

### 15.10 델타 인코딩(p.421)
- 앞서 나온 여러가지 캐시 방법들은 문서 전체에 대해 캐시하는 방법에 대해 설명했다면 **델타 인코딩은 문서에서 변경된 부분만을 요청/응답하는 방법에 대한 것**이다.
- RFC 3329에서 델타 인코딩에 대해 기술하고 있다. https://tools.ietf.org/html/rfc3229
- [그림 15-10]을 참고해보자. 본문 마지막에 hammers -> chisels 로 변경된 부분을 델타 인코딩으로 주고 받는다.
- 226 IM Used라는 응답 코드를 사용한다.
- A-IM 헤더는 **A**ccept-**I**nstance-**M**anipulation의 줄임말임.

#### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기(p.424)
- [그림 15-10]에서 5c는 base 문서의 5번째 줄을 지우라는 의미이고, 'chisels.'는 chisels.를 추가하라는 의미이다. 
- 델타 인코딩은 전송 시간을 줄일 수는 있지만 구현하기가 까다로울 수 있다. 변경이 잦고 사용자가 많은 경우 델타 인코딩을 지원하는 서버는 자신이 제공하는 페이지가 변경되는 매 순간의 사본을 모두 유지하고 있어야한다. 그래야 원본과 최신 사본 간의 차이를 델타로 나타낼 수 있다.
- 이는 서버가 유지해야할 디스크의 공간을 늘려야 하는 결과를 가져올 수 있다.


## 16장 국제화(p.427)
- WWW의 진정한 비전에 부응하기 위해서는 HTTP는 여러 언어와 문자로 된 국제 문서들의 처리 및 전송을 지원해야 한다.
- 이 장에서는 두 가지 주요 국제화 이슈인 문자집합 인코딩과 언어 태그를 다룬다.

### 16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원(p.428)
- HTTP 메시지는 Accept-Charset과 Accept-Languate를 통해 지원하는 언어를 요청으로 보낸다.
- 여기에도 q를 통해 협상을 할 수 있다.

### 16.2 문자집합과 HTTP(p.428)
- 웹 문자집합 표준은 꽤 혼란스러울 수 있다. 복잡하고 일관성 없는 전문용어, 읽으려면 돈 주고 사야하는 표준 문서, 익숙하지 않은 외국어가 원인이다.

#### 16.2.1 차셋(Charset)은 글자를 비트로 변환하는 인코딩이다(p.429)
- Charset은 어떻게 엔터티 콘텐츠 비트들을 특정 문자 체계의 글자로 바꾸는지를 말해준다. 각 Charset 태그는 비트들을 글자로 변환하거나 혹은 그 반대의 일을 해주는 알고리즘을 명명함.
- Charset 태그는 IANA에서 관리한다.
- charset은 Content-Type에 포함된다. 다음처럼
```
Content-Type: text/html; charset=iso-8859-6
```
- [그림 16-1]은 charset 매개변수를 이용해 클라이언트가 엔터티 본문에서 어떻게 글자로 변환하는지 보여주고 있다.
- 몇몇 문자 인코딩(대표적으로 우리에게도 익숙한 UTF-8)은 글자당 비트 수가 일정하지 않아 한자처럼 많은 글자로 이루어진 문자체계를 지원할 수 있다.

#### 16.2.2 문자집합과 인코딩은 어떻게 동작하는가(p.430)
- [그림 16-2]는 문자집합과 인코딩이 어떻게 동작하는지 보여주고 있다.
- 데이터 비트 -> 문자코드 -> 유일한 문자 -> 글자 모양 으로 나타내는 과정
- 여기서 [그림 16-2의 c]에 해당하는 과정은 HTTP가 관여하는 부분이 아니다.

#### 16.2.3 잘못된 차셋은 잘못된 글자들을 낳는다(p.431)
- euc-kr <-> utf-8 로 글자 깨지는 경우를 많이 겪어봤을 것이다.
- 占쏙옙 -> https://namu.wiki/w/%E5%8D%A0%EC%8F%99%EC%98%99

#### 16.2.4 표준화된 MIME 차셋 값(p.431)
- 특정 문자 인코딩과 특정 코딩된 문자집합의 결합을 MIME charset이라고 함.
- [표 16-1]에 대표적인 것들이 몇가지 나와있따.

#### 16.2.5 Content-Type charset 헤더와 META 태그(p.433)
- 웹 서버는 Content-Type에 charset을 포함해서 보내지만, 만약 없을 경우 클라이언트는 HTML 문서에서 charset을 추측하려고 한다.
- 다음과 같은 메타태그로 Content-Type을 나타내는 경우도 있다.
```HTML
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-2022-jp">
```

#### 16.2.6 Accept-Charset 헤더(p.433)
- 클라이언트 -> 서버로 보내는 요청에 클라이언트가 원하는 charset을 의미한다.

### 16.3 다중언어 문자 인코딩에 대한 지침(p.434)
- 이번엔 다중언어 문자 체계를 이해해보자.

#### 16.3.1 문자집합 용어(p.434)
- 문자 : 알파벳, 숫자, 구두점, 표이문자, 기호 등 글쓰기의 최소 단위
- 글리프(glyph) : 하나의 글자를 표현하기 위한 획의 패턴이나 다른 것과 구분되는 유일한 시각적 형태. [그림 16-3]을 참고
- 코딩된 문자, 코드 공간 등 책 참고

#### 16.3.2 '차셋(Charset)'은 형편없는 이름이다(p.435)
- 엄밀히 말해 MIME 차셋 태그는 문자집합을 의미하는 것이 아니다. 데이터 비트를 고유한 문자의 코드로 매핑하는 알고리즘의 이름이다.
- RFC 2616에 나오는 구절
```
이 문서에서 '문자집합(character set)'이란 용어는 어떠한 방법을 참조하기 위해 사용되었다 ... 옥텟의 연속을 글자들의 연속으로 변환하기 위해... 주의: 이러한 '문자집합'이란 용어는 '문자 인코딩'의 의미로 더 흔하게 사용된다. 그러나 HTTP와 MIME이 같은 등록소를 공유하는 이상, 용어 역시 공유된다는 사실은 중요하다.
```
- 내용이 잘 이해가 안가긴 하나.. MIME charset이란 [그림 16-2]에서 a~b에 해당하는 역할(매핑 시키는 알고리즘)만을 의미하는데, 이게 마치 문자 집합 자체를 의미하는 것처럼 혼용해서 사용되고 있다는 의미 같다.

#### 16.3.3 문자(p.436)
- 문자는 쓰기의 기본적인 구성요소이다.
- 어떤 문자들은 서로 다른 형태를 가질 수 있고, 때로는 위치에 따라 다른 형태를 가지는 경우도 있다.

#### 16.3.4 글리프(glyphs), 연자(ligatures) 그리고 표현 형태(p.437)
- 문자는 유일하지만 글리프는 유일하지 않다. ([그림 16-3] 참고)
- 어떤 문자들은 연자를 사용하기도 한다. 인접한 글자에 따라 문자의 모양이 달라진다.

#### 16.3.5 코딩된 문자집합(Coded Character Set)(p.438)
- 정수로 매핑되는 문자집합들의 예시를 소개하고 있다.

#### 16.3.6 문자 인코딩 구조(p.440)
- 문자 인코딩의 길이는 고정폭일 수도 있고, 가변폭일 수도 있다. 각각의 특징이 있다.
- 예시를 통해 보는게 나을 것 같다. 책에선 8비트, UTF-8, iso-2022-jp, euc-jp, euc-kr 등을 소개하고 있다.
- 8비트는 고정폭, UTF-8은 가변폭이다.
- 그외 각각의 charset별 특징을 보여주고 있다.

### 16.4 언어 태그와 HTTP(p.444)
- 언어 태그는 언어 이름을 붙이기 위한 짧고 표준화된 문자열이다.
- 한글은 ko-KR, 미국 영어는 en-US

#### 16.4.1 Content-Language 헤더(p.445)
- 응답 헤더에 포함된 Content-Language 헤더는 해당 문서가 어떤 언어 사용자를 위한 것인지 나타낸다.
- 한번에 여러 언어를 ,로 나눠서 나타낼 수도 있다.

#### 16.4.2 Accept-Language 헤더(p.446)
- 클라이언트가 서버에게 원하는 언어를 요청 헤더에 포함할 수 있다.

#### 16.4.3 언어 태그의 종류(p.446)
- ..? RFC 3066에 언어 태그에 대한 표준화된 문법이 있다고 한다.

#### 16.4.4 서브태그(p.447)
- 언어 태그는 하이픈으로 분리된 하나 이상의 서브태그로 이루어져 있다.
- sgn-US-MA 같은 식으로 {주 서브태그(표준)}-{두 번째 서브태그}-{세 번째 서브태그}

#### 16.4.5 대소문자의 구분 및 표현(p.447)
- 모든 태그는 대소문자를 구분하지 않는다. 하지만 관용적으로 소문자는 해당 언어, 대문자는 국가를 의미한다.

#### 16.4.6 IANA 언어 태그 등록(p.447)
- 언어 태그는 IANA에서 관리한다.
- 만약 언어 태그가 표준 국가와 언어 값의 조합이라면, 그 태그는 굳이 등록하지 않아도 된다.
- 국가와 언어 값으로 구성될 수 없는 언어 태그들은 등록이 필요하다.

#### 16.4.7 첫 번째 서브태그: 이름공간(p.448)
- 대표적인 첫 번째 서브 태그들이 나온다.
- x로 시작하면 특정 개인이나 집단 전용의 비표준 확장 서브태그이다.

#### 16.4.8 두 번째 서브태그: 이름공간(p.449)
- 보통 국가/지역을 의미한다.

#### 16.4.9 나머지 서브태그: 이름공간(p.450)
- 추가로 필요하다면 사용. 방언 등

#### 16.4.10 선호 언어 설정하기(p.450)
- 브라우저에서 사용자의 선호 언어를 설정할 수 있다.

#### 16.4.11 언어 태그 참조표(p.450)
- 부록 G 참고

### 16.5 국제화된 URI(p.450)
- 오늘날의 URI는 국제화를 그다지 지원하지 않는다.

#### 16.5.1 국제적 가독성 vs 의미 있는 문자들(p.451)
- URI 설계자들은 전 세계의 모두가 URI를 이메일, 전화, 광고판, 심지어 라디오를 통해 다른 이들과 공유할 수 있기를 원했다. 그러면서도 URI가 사용하기 쉽고 기억하기 쉽길 바랐다. 이 두가지가 서로 충돌한다.
- 불행히도 URI는 비영어권 사람들도 쉽게 사용하고 기억할 수 있도록 설계되지는 못했다.
- 그외 문자를 쓰면 %인코딩으로 표현된다.

#### 16.5.2 URI에서 사용될 수 있는 문자들(p.451)
- URI에서 사용할 수 있는 문자열을 보여주고 있다. [표 16-8] 참고

#### 16.5.3 이스케이핑과 역이스케이핑(unescaping)(p.452)
- 알파벳 외의 국제 문자들을 사용하면 해당 값이 %인코딩된 값으로 변한다.
- 공백 등의 기호도 마찬가지이다.

#### 16.5.4 국제 문자들을 이스케이핑하기(p.453)
- 이스케이프되는 문자열은 0~127 사이의 범위에 있어야한다.

#### 16.5.5 URI에서의 모달 전환(p.453)
- 몇몇 URI는 다른 문자집합의 글자를 표현하기 위해 ASCII 문자열을 사용한다.(% 인코딩을 하는게 아니라)
- 현재 URI는 그다지 국제화에 친화적이지 않다. **URI의 이식성의 목표는 언어 유연성의 목표보다 중요했다.**

### 16.6 기타 고려사항(p.454)
#### 16.6.1 헤더와 명세에 맞지 않는 데이터(p.454)
- HTTP 헤더는 반드시 US-ASCII 문자집합의 글자들로만 이루어져야 한다. (0~127 까지의 문자열)

#### 16.6.2 날짜(p.454)
- HTTP 명세는 올바른 GMT 날짜 형식을 명확히 정의하고 있지만, 모든 웹 서버와 클라이언트가 이 규칙을 따르고 있지는 않다.
- 서버는 날짜를 파싱할 수 없다면 이를 보수적으로 다루어야한다.

#### 16.6.3 도메인 이름(p.454)
- 국제화 문자를 포함하는 도메인 이름을 '국제화 도메인 네임'이라고 한다. 퓨니코드(punycode)를 이용해서 이를 지원한다.
- RFC 3492에 정의되어있다.
- 예를들어 한글.com은 xn--bj0bj06e.com으로 변환된다.
