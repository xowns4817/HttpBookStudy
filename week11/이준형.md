## 20장 리다이렉션과 부하 균형(p.521)
- HTTP 메시지의 데이터는 여정 중에 많은 프로토콜에 의해 통제된다.
- HTTP가 고려하는 것은 오직 출발지와 목적지 이지만, 중간에 존재하는 미러링된 서버, 웹 프록시, 캐시가 함꼐 하는 웹의 세계에서 HTTP의 목적지는 항상 단순하지만은 않다.
- 이 장에서는 여러가지 리다이렉션 기법들과 그것의 동작 방법과 어떤 부하 균형(load-balancing) 능력을 갖고 있는지 살펴본다.

### 20.1 왜 리다이렉트인가?(p.522)
- 리다이렉션은 현대의 웹에서는 피할 수 없는 현실이다. 왜냐하면 HTTP 애플리케이션은 언제나 다음 3가지를 원하기 때문이다.
    - 신뢰할 수 있는 HTTP 트랜잭션의 수행
    - 지연 최소화
    - 네트워크 대역폭 절약
- 위와 같은 이유들로 웹 콘텐츠는 흔히 여러 장소에 배포된다. 이렇게 하면 한 곳에서 실패한 경우 다른 곳을 이용할 수 있으므로 신뢰성이 개선된다.
- 또한 클라이언트가 보다 가까운 리소스에 접근할 수 있게되어 콘텐츠를 받는 속도가 빨라짐
- 기타 등등.. 여러가지 이점이 있기에 리다이렉트를 한다.
- 리다이렉션의 구현에는 부하 균형의 과제가 포함되는데, 왜냐하면 둘은 서로 공존하기 때문이다.

### 20.2 리다이렉션 할 곳(p.522)
- 서버, 프록시, 캐시, 게이트웨이는 클라이언트가 그들에게 요청을 보내고 그것을 처리한다는 관점에서 보면 클라이언트에게는 모두 서버라고 할 수 있다.
- 이러한 대상들에서는 공통적으로 서버의 특성을 가지고 있기 때문에 많은 리다이렉션 기법이 그들 모두에서 동작한다.
- 그러나 어떤 리다이렉션 기술들은 특정 종류의 종단만을 위해 특별히 설계되어 일반적인 적용이 불가능하다.
- 웹 서버는 IP별로 요청을 다룬다. 똑같이 복제된 서버들로 요청을 분산한다는 것은 같은 URL에 대해 여러 곳에서 온 요청들을 각각 최적의 웹 서버로 보내겠다는 것을 의미한다.
- 프록시는 프로토콜별로 요청을 다룬다. 클라이언트 근처에 프록시 캐시가 있다면, 모든 요청이 프록시 캐시로 흘러 들어가는 것이 이상적이다.

### 20.3 리다이렉션 프로토콜의 개요(p.523)
- 리다이렉션의 목표는 HTTP 메시지를 가용한 웹 서버로 가급적 빨리 보내는 것
- HTTP 메시지는 HTTP 애플리케이션과 라우팅 장치에 영향을 받는다.
    - 브라우저에 프록시 설정
    - DNS가 사용자 주소에 따라 다른 IP로 안내
    - 하나의 메시지는 여러개의 패킷으로 나뉘어 네트워크를 통과하고, 각 스위치와 라우터는 패킷을 어떻게 라우팅할 것인지 결정
    - 웹 서버는 리다이렉트로 요청이 다른 웹서버로 가도록 할 수 있다.
- DNS 리다이렉션을 비롯한 대부분의 기법은 어떤 서버인가에 상관없이 사용할 수 있지만, 브라우저 설정 같은 방법은 프록시로 향하는 트래픽에 대해서만 사용 가능하다.
- [표 20-1]에 나와있는 것은 일반 리다이렉션 방법들이고 [표 20-2]는 프록시와 캐시의 리다이렉션 기법이다. 이것들은 뒤에 각각 나올 것이다.

### 20.4 일반적인 리다이렉션 방법(p.526)
- 이 장에서는 서버와 프록시 양쪽에서 공통으로 쓰이는 여러가지 리다이렉션 방법들을 다뤄본다.

#### 20.4.1 HTTP 리다이렉션(p.526)
- 몇몇 웹 사이트는 HTTP 리다이렉션을 이용해 간단하게 부하를 분산한다.
- [그림 20-1]에 어떤 방식인지 잘 나와있는데.. 사실 이런 방식은 잘 사용 안한다.
- 단점이 몇가지 나오는데, 생각보다 치명적임.
    - 어떤 서버로 리다이렉트할지 결정하려면 원 서버는 상당히 많은 처리를 해야 한다. 때로는 거의 페이지 자체를 제공할 때와 거의 같은 양의 처리가 필요하다.
    - 페이지에 접근할 때마다 두 번의 왕복이 필요하기 때문에, 사용자가 더 오래 기다려야 한다.
    - 만약 리다이렉트 서버가 고장나면 사이트도 고장난다.

#### 20.4.2 DNS 리다이렉션(p.528)
- DNS 서버 자체가 어떤 IP로 안내할지 결정한다. 즉 하나의 domain에 여러 개의 IP가 있을 수 있다는 거다.
- [그림 20-2] 참고. 가장 쉬운 DNS 결정 알고리즘은 단순한 라운드 로빈이다.
- DomainTools - www.naver.com : 223.130.195.95, 125.209.222.142
- DNS 캐싱의 효과 -> DNS 주소 순환은 부하를 순환시키지만, 클라이언트는 known-host 에 대한 DNS-IP 정보를 들고 있기 때문에 이를 재사용하여 부하가 순환되지 않도록 한다. -> 그렇다고 하더라도 전체 클라이언트에 대한 부하는 잘 분산해줄 수 있다.
- 부하 균형 알고리즘 -> 가장 로드가 적은 서버를 추적하여 안내함
- 근접 라우팅 알고리즘 -> 사용자에게 가까운 웹 서버로 안내
- 결함 마스킹 알고리즘 -> 네트워크의 건강 상태를 모니터링하고 장애를 피해 라우팅
- 일반적으로 복잡한 서버추적 알고리즘을 사용하는 DNS를 권위 있는 DNS 서버라고 한다. 이는 여러가지 DNS 알고리즘을 통해 서버의 상태를 모니터링하여 리다이렉트한다.

#### 20.4.3 임의 캐스트 어드레싱(p.533)
- 라우터가 인근 스위치나 웹 서버에게 본인이 가장 가까운 라우터라고 홍보하는 것이다.
- 다만 실험적인 기법이고, 라우팅 누수가 발생할 우려가 있다.

#### 20.4.4 아이피 맥 포워딩(p.534)
- IP가 아닌 MAC 주소로 포워딩
- **MAC 주소 포워딩은 점 대 점으로만 가능하기 때문에, 서버나 프록시는 스위치와 한 홉 거리에 위치**해야한다.

#### 20.4.5 아이피 주소 포워딩(p.535)
- IP를 통한 포워딩을 한다.
- 라우터 대칭성 문제가 있는데, 클라이언트로부터 들어오는 TCP 커셕션을 받아주는 스위치는 그 커넥션을 관리하고 있고, 스위치는 **다른 커넥션이 아니라 그 커넥션을 통해** 클라이언트에게 응답을 돌려주어야한다. 그러므로 **모든 응답은 반드시 그 스위치에게 돌아가야한다.**
- 이를 제어할 수 있는 방법은 두가지가 있다.
    - 패킷의 출발지 아이피 주소를 스위치의 아이피 주소로 바꾼다.
    - 서버에서 클라이언트로 바로가는 경로가 존재하지 않아야 한다.

#### 20.4.6 네트워크 구성요소 제어 프로토콜(p.537)
- Network Element Control Protocol, NECP임
- 네트워크에 있는 주체들끼리 대화하는 프로토콜이다.
- [표 20-3]을 보자.... 그렇다고 한다.

### 20.5 프록시 리다이렉션 방법(p.538)
- 지금까지는 일반적인 리다이렉션 방법들에 대해 이야기했다. 이번 장에선 프록시 리다이렉션에 대해 설명한다.
- 클라이언트는 어떻게 프록시로 가는 방법을 아는가? 여기에는 3가지 방법이 있다. 각각에 대해 이번 장에서 이야기한다.

#### 20.5.1 명시적 브라우저 설정(p.538)
- 브라우저에서 설정하여 특정 프록시를 사용하도록 설정하는 것
- 두가지 중요한 단점이 있다.
    - 브라우저가 설정한 프록시가 응답하지 않더라도 원 서버에 접근하지 않는다.
    - 네트워크 아키텍처를 변경했을 때 그 변경사항을 모든 최종사용자에게 전파하는 것이 어렵다. 오직 사용자가 프록시 설정을 변경해야만 가능하다.

#### 20.5.2 프록시 자동 설정(p.539)
- PAC를 통해 프록시를 자동으로 설정한다.
- 내용에 대해 죽 다루고 있지만.. 사실 별로 와닿지는 않는 내용이다.

### 20.6 캐시 리다이렉션 방법
- 이번절에선 캐시 프록시 서버를 위해 사용되는 리다이렉션 기법에 대해 이야기한다.
- 앞서 나온 프로토콜보다 더 복잡하다..

#### 20.6.1 WCCP 리다이렉션(p.547)
- Web Cache Coordination Protocol, WCCP임. 시스코 시스템즈에서 개발하였다.
- WCCP 리다이렉션 동작
    - 네트워크에 WCCP를 사용할 수 있는 라우터와 다른 캐시와 의사소통할 수 있는 캐시가 포함되어야 한다.
    - 라우터 집합과 캐시들이 WCCP 서비스 그룹을 구성한다.
    - 서비스 그룹의 설정은 어떤 트래픽이 어디로 어떻게 보내지는지, 그리고 서비스 그룹에서 부하가 캐시들 사이에서 어떻게 분산되어야 하는지 명시한다.
    - **만약 서비스 그룹이 HTTP 트래픽을 리다이렉션하도록 설정되어 있다면**, 서비스 그룹의 라우터는 HTTP 요청을 서비스 그룹의 캐시로 보낸다.
    - HTTP 요청이 서비스 그룹의 라우터에 도착했을 때, 라우터는 그 요청을 처리하기 위해 그룹의 캐시 중 하나를 선택
    - 라우터는 요청 패킷을 캐시의 아이피 주소와 함께 캡슐화하거나 아이피 맥 포워딩을 하여 캐시로 보낸다.
    - **만약 캐시가 요청을 처리할 수 없다면**, 패킷은 광범위하게 포워딩되기 위해 라우터로 돌아온다.
    - 서비스 그룹의 구성원들은 지속적으로 다른 구성원들의 가용성을 확인하기 위해 하트비트 메시지를 교환한다.

![WCCP](https://www.cisco.com/c/dam/en/us/td/i/000001-100000/20001-25000/23501-24000/23810.ps/_jcr_content/renditions/23810.jpg)

### 20.7 인터넷 캐시 프로토콜(p.551)
- 인터넷 캐시 프로토콜(ICP)은 캐시들이 형제 캐시에서 일어난 캐시 적중을 찾아볼 수 있도록 해준다.
- 캐시 형제끼리는 원 서버에서 가져오는 것보다 적은 비용으로 콘텐츠를 가져올 수 있다.
- ICP는 일종의 캐시 클러스터링 프로토콜이다.
- 캐시는 이 프로토콜을 사용해 근처의 캐시 모두에게 특정 URL을 가지고 있는지 물어보고, 근처 캐시들은 가지고 있으면 "HIT", 아니라면 "MISS"라고 짧은 메시지로 답한다.

### 20.8 캐시 배열 라우팅 프로토콜(p.553)
- CARP임. 대량의 트래픽은 프록시 서버 자체에도 과도한 부하를 줄 수 있다.
- 이 문제에 대한 해결책 중 하나는 부하를 분산하기 위해 사용하는 프록시 서버를 여러대로 늘리는 것이다.
- CARP는 ICP의 대안이다.
- ICP는 모든 자식에게 브로드 캐스팅하지만, **CARP는 해시를 사용해 어떤 형제 캐시에게 질의할지 결정한다.**
- **저장, 조회가 결정론적이다.** -> 중요

### 20.9 하이퍼텍스트 캐싱 프로토콜(p.557)
- ICP는 HTTP/0.9를 염두에 두고 설계되어 오직 URL만으로 적중을 판단한다.
- HTCP는 URL과 모든 요청 및 응답 헤더를 사용하여 문서의 적중 여부를 파악한다.